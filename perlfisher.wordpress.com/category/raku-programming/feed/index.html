<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>Raku programming &#8211; The Perl Fisher</title>
	<atom:link href="https://perlfisher.wordpress.com/category/raku-programming/feed/" rel="self" type="application/rss+xml" />
	<link>https://perlfisher.wordpress.com</link>
	<description></description>
	<lastBuildDate>Tue, 30 Jun 2020 11:19:53 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='perlfisher.wordpress.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>Raku programming &#8211; The Perl Fisher</title>
		<link>https://perlfisher.wordpress.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://perlfisher.wordpress.com/osd.xml" title="The Perl Fisher" />
	<atom:link rel='hub' href='https://perlfisher.wordpress.com/?pushpress=hub'/>
	<item>
		<title>Rewriting Perl Code for Raku IV: A New Hope</title>
		<link>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/</link>
					<comments>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 08 Dec 2019 11:36:34 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://theperlfisher.wordpress.com/?p=39</guid>

					<description><![CDATA[Back in&#160;Part III&#160;of our series on Raku programming, we talked about some of the basics of OO programming. This time we’ll talk about another aspect of OO programming. Perl objects can be made from any kind of reference, although the most common is a hash. I think Raku objects can do the same, but in<a class="more-link" href="https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku IV: A New&#160;Hope"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Back in&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Part III</a>&nbsp;of our series on Raku programming, we talked about some of the basics of OO programming. This time we’ll talk about another aspect of OO programming. Perl objects can be made from any kind of reference, although the most common is a hash. I think Raku objects can do the same, but in this article we’ll just talk about hash-style Perl objects.</p>



<p>Raku objects let you superclass and subclass them, instantiate them, run methods on them, and store data in them. In previous articles we’ve talked about all but storing data.&nbsp;It’s time to remedy that, and talk about attributes.</p>



<h2>Instance attributes</h2>



<p>We used&nbsp;<code>unit class OLE::Storage_Lite;</code>&nbsp;to declare our class, and&nbsp;<code>method save( $x, $y ) { ... }</code>&nbsp;to create methods. Or in our case rewrite existing functions into methods. Now, we focus our attention on some of the variables that should really be instance attributes, and why.</p>



<p>Let’s get to know which variables behave like attributes, and which don’t. This&nbsp;<strong>will</strong>&nbsp;change how we write our Raku code, but hopefully for the better. We’ll start from the outside in, and look at the API. There are a few “test” scripts that use the module, and this fragment is pretty common.</p>


<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite;
my $oOl = OLE::Storage_Lite-&gt;new('test.xls');
my $oPps = $oOl-&gt;getPpsTree(1);
die( &quot;test.xls must be a OLE file&quot;) unless($oPps);
</pre>


<p>The author creates an object (<em>$oOl</em>) from an existing file, then fetches a tree of “Pps” objects, whatever they are. So, one&nbsp;<em>OLE::Storage_Lite</em>&nbsp;object equals one file. This gives me my first instance variable,&nbsp;the filename.</p>


<pre class="brush: plain; title: ; notranslate">
sub new($$) {
  my($sClass, $sFile) = @_;
  my $oThis = {
    _FILE =&gt; $sFile,
  };
  bless $oThis;
  return $oThis;
}
</pre>


<p>Above is how they wrote it in Perl, and below is how we’d write it (exactly as specified) in Raku:</p>


<pre class="brush: plain; title: ; notranslate">
has $._FILE;

multi method new( $sFile ) {
  self.new( _FILE =&gt; $sFile );
}
</pre>


<p>Later on, we can call&nbsp;<code>my $file = OLE:Storage_Lite.new( 'test.xls' );</code>&nbsp;just like we did in Perl. We wouldn’t even need the&nbsp;<em>new</em>&nbsp;method if we had users call&nbsp;<code>my $file = OLE::Storage_Lite.new( _FILE =&gt; 'text.xls' );</code>. This gives users the option of calling the API in the old Perl fashion or the new Raku fashion without additional work on our part.</p>



<h2>Strict Raku-style</h2>



<p>There’s a problem lurking here, though. The constructor Raku provides us lets us call&nbsp;<code>my $file = OLE::Storage_Lite.new();</code>&nbsp;without specifying a value for&nbsp;<em>$._FILE</em>. If you know Perl’s Moose module, though, the ‘has’ there just might look familiar.</p>



<p>And for good reason. A lot of the ideas from Moose migrated into Raku during its design, and the attributes were one of those. Moose lets you do a lot of things with attributes, and so does Raku. One of those is you can add “adverbs” to them. Let’s do that now.</p>


<pre class="brush: plain; title: ; notranslate">
has $._FILE is required;
</pre>


<p>Calling&nbsp;<code>OLE::Storage_Lite.new()</code>&nbsp;now fails, because you’re not passing in the&nbsp;<em>_FILE</em>&nbsp;argument. That solves one problem. Actually, it solves two, come to think of it. In the original Perl code, you could call&nbsp;<code>OLE:Storage_Lite-&gt;new()</code>&nbsp;too, and it wouldn’t complain. Now we’ve fixed that, with one new term.</p>



<h2>Progressive Typing</h2>



<p>No, we’re not talking about some new editor like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.commaide.com/">Comma</a>&nbsp;(the link&nbsp;<strong>does</strong>&nbsp;work, despite the certificate problem.) Our code would run just fine, as-is. Users could call our&nbsp;<em>.new()</em>&nbsp;API, Raku would make sure the filename existed, and we could go on with translating.</p>



<p>But there’s something more we can take advantage of here, and that is the fact that any Raku object (and anything we can instantiate is an object) is a type as well. We haven’t mentioned that because we really couldn’t use that information until now.</p>



<p>The original Perl code is littered with clues to types, hidden in the variable names. When we wrote our own API call, the Perl code called the file name&nbsp;<em>$sNm.</em>&nbsp;The ‘s’ tells the Perl compiler nothing, but it tells us that&nbsp;<em>$sNm</em>&nbsp;is a String type. Perl may not have true types, but Raku does. Let’s fix our attribute with that in mind.</p>


<pre class="brush: plain; title: ; notranslate">
has Str $._FILE is required;
</pre>


<p>We knew all along that&nbsp;<em>$._FILE</em>&nbsp;is a string of some sort, but telling Raku that lets it allocate space more efficiently. Making sure it’s a required attribute lets anyone that calls&nbsp;<em>new()</em>&nbsp;know if they forget an argument. We could go a little farther with this, but locking down attributes will help in the long run, when we start dealing with the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;built-ins.</p>



<h2>Packing It All In</h2>



<p>We’re now getting to the heart of the module. There’s a lot of mechanics above us, allocating objects and doing math and checking types, and not much below us. The class’ entire purpose is to read and write OLE-formatted files. We’ll talk more about the boilerplate, but here’s the real meat of the file.</p>



<p>Let’s start with what should be simple, reading in data. Just like in Perl, we open a file and get back a “file handle” (assuming the file exists, of course.) By default, calling&nbsp;<code>my $fh = open $._FILE;</code>gives us a read-only file handle. The file handle itself has a bunch of attributes associated with it, but the important one right now is its encoding.</p>



<p>Namely, the fact that it has none. An OLE file is essentially a miniature filesystem (probably based on FAT) packed onto disk, complete with a root directory, subdirectories and files. File have names encoded in UCS-2, but the rest is entirely dependent upon what the application requires.</p>



<p>The upshot of which is that we can’t read the format with something simple like&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;which would read line after line into the&nbsp;<em>@lines</em>&nbsp;array. Instead we’ll use calls like&nbsp;<em>read()</em>and&nbsp;<em>write()</em>&nbsp;that return byte-oriented buffers.</p>



<h2>Buffering…</h2>



<p>All OLE files start off with the header “xD0xCFx11xE0xA1xB1x1AxE1”, so we should probably start there. That’s important twice in the code, in fact. First, when we’re reading off disk, we can check it against what we’ve just read to make sure this file is OLE, and not, say, a JSON file. Later on, when we’re saving out an OLE file, we can write it as the header string.</p>


<pre class="brush: plain; title: ; notranslate">
constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";
</pre>


<p>I’ll make it a constant as well, so when I revisit this code in a month I don’t have to go looking in specs for ‘0xd0 0xcf’ to remember what this is. Reading is straight-forward too. It needs just a byte count.</p>


<pre class="brush: plain; title: ; notranslate">
my Buf $header = $fh.read( 8 );
</pre>


<p>Something important to notice here is the type, ‘Buf’. If our file was in Markdown, or JSON we could get away with just writing&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;like I tried earlier. But these are raw bytes, hindered by no interpretation. Let’s see what happens when we compare these bytes to our&nbsp;<em>HEADER-ID</em>.</p>


<pre class="brush: plain; title: ; notranslate">
t/01-internals.t ............ Cannot use a Buf as a string, but you called the Stringy method on it
  in method _getHeaderInfo at /home/jgoff/GitHub/drforr/raku-OLE-Storage_Lite/lib/OLE/Storage_Lite.pm6 (OLE::Storage_Lite) line 169
  in block &lt;unit&gt; at t/01-internals.t line 42
</pre>


<h2>Another brick in the wall</h2>



<p><strong>Ka-blam</strong>. But… hold the phone here a minute, I just said&nbsp;<code>$header eq HEADER-ID</code>, I didn’t write anything like ‘Stringy’! There’s no ‘Stringy’ in the source… oh.&nbsp;<em>HEADER-ID</em>&nbsp;is a string, so Raku is being helpful. I’m trying to use string comparison (‘eq’) between something that’s not a Str (&nbsp;<em>$header</em>&nbsp;) and something that is (<em>HEADER-ID</em>).</p>



<p>Pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Stringy">Stringy</a>&nbsp;documentation, and look for the Type graph. Midway down you’ll see ‘Buf’ and ‘Str’, as of this writing Buf is on the left, and Str is popular so it’s in the middle.</p>



<p>Trace the inheritance paths from Buf and Str upwards, and you’ll see they pass Buf -&gt; Blob -&gt; Stringy and Str -&gt; Stringy, and stop. What the error message therefore is saying is this, anthropomorphized:</p>



<p>You wanted to convert&nbsp;<em>Buf</em>&nbsp;to&nbsp;<em>Str</em>, and didn’t care how you did it. So I looked. First, on the&nbsp;<em>Buf</em>&nbsp;type. No .Str method there, at least without arguments. No good. So I looked in its parent,&nbsp;<em>Blob</em>. Nothing doing there. Then I looked at&nbsp;<em>Stringy</em>, and couldn’t find anything else.</p>



<p>There’s nothing above me, nothing below. So I’ll let you know I looked for a conversion method in a bunch of places, stopped at&nbsp;<em>Stringy</em>, and couldn’t go any farther. Sorry.</p>



<p><em>Raku</em></p>



<p>You’re probably wondering how to get out of this quandary. Reading the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Blob#method_Str">Blob</a>&nbsp;documentation closely, you might think that the&nbsp;<em>encode</em>&nbsp;method is the way out of our present jam. If you look closer, though, there’s a spanner in the works. “xD0” is the&nbsp;<strong>byte</strong>&nbsp;0xd0, so if you try to decode to ASCII, you run into the problem that ASCII only covers 0x00-07xf, everything outside of that is undefined.</p>



<h2>Packing for vacation</h2>



<p>If you’ve kept up with things, you might surmise by now that the key to our quandary lies in the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins. Specifically&nbsp;<em>unpack()</em>, because we’re trying to “decode” a buffer into something suitable for Raku.</p>



<p>Unless you’ve done things like network programming or security, the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins are going to be unfamiliar territory. The closest analogue of&nbsp;<em>pack()</em>&nbsp;is the builtin&nbsp;<em>sprintf()</em>.</p>



<p>Both of these builtins take a format string telling the compiler how to arrange its arguments. Both of them take a mixture of string and integer arguments afterwards. But while&nbsp;<em>sprintf()</em>&nbsp;takes the arguments and treats its output as a UTF-8 encoded string,&nbsp;<em>pack()</em>&nbsp;takes the same arguments and treats its output as a raw buffer of bytes.</p>



<p>And now you can see one way out of our little predicament. If we could just find the right invocation,&nbsp;<em>pack()</em>&nbsp;would be able to take our string “xd0xcf…” and turn it into a Buf object. Then we could compare the buffer we got by reading 8 bytes to the buffer we expected.</p>



<p>So instead of cluttering up the main code, let’s write a quick test.</p>


<pre class="brush: plain; title: ; notranslate">
use experimental :pack;
constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";

use Test;
my $fh = open "test.xls";
my Buf $buf = $fh.read( 8 );

is $buf, pack( "A8", HEADER-ID ); # Pack 8 ASCII characters
</pre>


<h2>Testing…testing…</h2>



<p>Let’s take it from the top. We tell Raku to use the “experimental”&nbsp;<em>pack()</em>&nbsp;builtin, and declare the header we want to check against. Then we tell Raku we want to use the Test module, and open a new Microsoft Excel test file.</p>



<p>Last, we read a chunk of 8 bytes from the file into a buffer, and check to see that the 8 bytes matches the header we expect to see. Now, how did we get that weird ‘A8’ string in there? I thought&nbsp;<em>pack()</em>&nbsp;looked more like&nbsp;<em>sprintf()</em>?</p>



<p>Well, it does, to an extent. I/O routines like&nbsp;<em>sscanf()</em>&nbsp;and&nbsp;<em>sprintf()</em>&nbsp;can do all sorts of things to your strings and numbers on the way in and out, think for example what ‘%-2.10f’ means in a format specifier, for instance. You can follow along with the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/routine/unpack">unpack()</a>&nbsp;documentation if you like.</p>



<p><em>pack()</em>, by contrast, just takes 8, 16, or 32-bit chunks of your input, and places them into a buffer. The “A” in “A8” says that it wants to convert an ASCII-sized chunk of your input (“xd0” in our case) into a byte in the buffer, so our Buf now looks like ( 0xd0 ).</p>



<p>I could just as well have said “AAAAAAAA” in order to translate all 8 characters of the buffer, but I think it’s a little tidier to use the ‘repeat’ option, and say “A8” in order to convert just 8 characters (yes, yes, I know, they’re&nbsp;<strong>glyphs</strong>, but let’s not confuse matters.)</p>



<p>I could write “A*” just as well, but “A8” makes sure that 8 and only 8 (the number that thou shalt count to…) characters get converted. I doubt that the header in an OLE file will change, but it’s a nice bit of forward planning.</p>



<hr class="wp-block-separator" />



<p>For those of you that made it this far, thank you. As usual, gentle Reader, if you have any comments, criticisms (constructive, please) or questions, feel free to post them below.</p>



<p>Next week I’ll delve deeper into the mysteries of&nbsp;<em>pack()</em>,&nbsp;<em>unpack()</em>&nbsp;and some of the tips and tricks I use to keep on my toes and make sure that I generate clean Microsoft-compatible output.</p>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku III: The Sorceror</title>
		<link>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/</link>
					<comments>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Mon, 02 Dec 2019 12:05:55 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=60</guid>

					<description><![CDATA[Last week, we started testing, learned how to create proper Raku classes, and the basics of functions. This time we’ll take a closer look at functions, arguments, and make some decisions about the API. And maybe while writing this I’ll argue myself out of a decision. It’s happened before. One good thing about writing&#160;about&#160;a module<a class="more-link" href="https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku III: The&#160;Sorceror"</span></a>]]></description>
										<content:encoded><![CDATA[
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Last week</a>, we started testing, learned how to create proper Raku classes, and the basics of functions. This time we’ll take a closer look at functions, arguments, and make some decisions about the API. And maybe while writing this I’ll argue myself out of a decision. It’s happened before.</p>



<p>One good thing about writing&nbsp;<strong>about</strong>&nbsp;a module is that you can slip into a certain mindset. For instance, right now I’m thinking a few paragraphs ahead, wondering how to explain why I changed the API from Perl 5 references to regular Raku types.</p>



<p>It’s at odds with some of the principles I laid down at the start, which states that I should have minimal changes in the API from Perl to Raku. In Perl 5, you would create the “filesystem root” object like so:</p>


<pre class="brush: plain; title: ; notranslate">
my $root = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);
</pre>


<p>with a bunch of references to lists. By all rights, and the principles I set up earlier, the Raku equivalent should be almost exactly the same:</p>


<pre class="brush: plain; title: ; notranslate">
my $root = OLE::Storage_Lite::PPS::Root.new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);
</pre>


<p>In fact, all I did was copy and change two characters, specifically the Perl ‘-&gt;’ to the Raku ‘.’ operator. Clean, and very simple. And I think what I’ll do is actually just change the code back to using the Perl reference, at least in the API. Dereferencing it will be just a few lines, and I’ll have to change it in the tests as well, but I think the pain will be worthwhile.</p>



<p>This way I don’t have to field questions like “Why did you end up potentially breaking old code?” during talks. See, speaking at conferences about your code really <strong>can</strong> be a useful motivator!</p>



<h2>I’d like a formal argument, please</h2>



<p>So, I think I’ve settled on Perl-style formal references, at least for the current iteration. There are actually better ways to do this, but I’ll leave that for the proper Raku version. For right now, quick-n-dirty is the name of the game.</p>



<p>Moving on, we see an important method in the original Perl code, saving an object to disk.</p>


<pre class="brush: plain; title: ; notranslate">
sub save($$;$$) {
  my($oThis, $sFile, $bNoAs, $rhInfo) = @_;
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}
</pre>


<p>As I’ve mentioned before, OLE::Storage_Lite has been around for a long, long time. And it’s obvious here. Function prototypes (<strong>not</strong>&nbsp;signatures, which are a different kettle of fish) and the use of ‘$oThis’ instead of the more conventional ‘$self’.</p>



<h3>Being prototypical</h3>



<p>Prototypes were originally meant as a way to save you from having to write checks in your code. Theoretically, if your function was called&nbsp;<code>sub save($$)</code>&nbsp;and you tried to call it with&nbsp;<code>save($fh)</code>&nbsp;you would get an error, because the ‘$$’ means the subroutine took two arguments, and you gave it just one.</p>



<p>But it also predated objects (yes, Virginia, objects in Perl haven’t been around all&nbsp;<strong>that</strong>&nbsp;long.) and they could have unforeseen side effects. So they were a fad for a while, but quickly faded out of existence.</p>



<p>These days they’re a reason for a more experienced Perl hacker to take the junior aside and explain quietly why we don’t use those anymore, and point them to some modern references, like&nbsp;<em><a href="http://web.archive.org/web/20200212094016/https://www.amazon.com/Modern-Perl-chromatic/dp/1680500880/ref=sr_1_1?keywords=Modern+Perl&amp;qid=1574975397&amp;s=books">Modern Perl</a></em>&nbsp;(not an affiliate link, yet.)</p>



<p>Let’s at least partially convert that to Raku, like so:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs, $rhInfo) {
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}
</pre>


<p>The ‘$oThis’ means that this is a method call, so instead of writing&nbsp;<code>sub save( $oThis, ... )</code>&nbsp;we can rewrite it to a method and gain ‘self’ instead of the arbitrary variable ‘$oThis’. Of course we do have to do a search-and-replace on ‘$oThis’ with ‘self’, but that’s relatively simple. More complex is what to do with the ‘;’ in the original prototype.</p>



<h2>Having options</h2>



<p>It’s worth pointing out that&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>&nbsp;is taken at least in part from another (larger) module,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage">OLE::Storage</a>. This means that the internal code is redundant in a few places. Raku would let us rewrite what we have as:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs, $rhInfo = {}) {
  #0.Initial Setting for saving
  # ..
}
</pre>


<p>making&nbsp;<em>$rhInfo</em>&nbsp;an optional variable with a default value. Now, this is a pretty common pattern for a recursive method, so I did a bit of digging. Namely I grep’ed for ‘save’ in the original (all-in-one)&nbsp;<em>Storage_Lite.pm</em>&nbsp;module, and found no recursive calls to it.</p>



<h2>Debugging both sides now</h2>



<p>This is also where the test suite I wrote earlier comes in handy, as it actually exercises the ‘save’ method. So I added a quick debugging message&nbsp;<code>warn "Saving $rhInfo";</code>&nbsp;to my local copy of the code, and ran the test suite. Seeing just one ‘Saving …’ message in my test output convinced me it wasn’t recursive. So now the code just looks like:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs) {
  #0.Initial Setting for saving
  my %hInfo;
  # ..
}
</pre>


<p>Also, since&nbsp;<em>$rhInfo</em>&nbsp;is created in this method, there’s no reason to leave it as a reference. So the initial ‘r’ goes away, and we have left just ‘%hInfo’. It may get passed in to other methods, but Raku lets us pass hashes and arrays as ordinary variable types, so I’ll take advantage of that.</p>



<p>To be fair, leaving it as a reference would have saved me a bit of typing, but I’d already kind of decided that at least internally I’d try to use Raku types and calling conventions, and that left me with the choice of how to pass variables around.</p>



<h3>Having options</h3>



<p>Finally, there’s the question of what to do with the semicolon. Remember at the start, the function prototype was ‘($$;$$)’ which meant&nbsp;<em>$oThis</em>&nbsp;and&nbsp;<em>$sFile</em>&nbsp;were before the semicolon, and&nbsp;<em>$bData</em>&nbsp;and&nbsp;<em>$rhInfo</em>&nbsp;were after. I can now reveal that ‘;’ in a Perl prototype means that whatever appears afterward is optional.</p>



<p>True to Raku’s nature, I can account for this in at least two ways. One way would be to decide that&nbsp;<em>$bData</em>&nbsp;is always there and just has a default value, probably 0. That would look like&nbsp;<code>method save( $sFile, $bData = 0 )</code>. But the documentation puts&nbsp;<em>$bData</em>&nbsp;in square brackets, indicating that it’s optional.</p>



<p>Raku has an alternate syntax to indicate if a variable is optional, which looks like&nbsp;<code>method save( $sFile, $bData? )</code>. I think this method is better than the alternative syntax because it states clearly that&nbsp;<em>$bData</em>&nbsp;is optional. Both methods work, I just happen to like the ‘?’ modifier.</p>



<h2>Waiting for Huffman</h2>



<p>Moving on, we have this wonderful line of code:</p>


<pre class="brush: plain; title: ; notranslate">
$rhInfo-&gt;{_BIG_BLOCK_SIZE}  = 2**
              (($rhInfo-&gt;{_BIG_BLOCK_SIZE})?
                  _adjust2($rhInfo-&gt;{_BIG_BLOCK_SIZE})  : 9);
</pre>


<p>When I was translating this initially, I was in something of a drone mindset, not truly thinking about what I was doing. I’d copied the&nbsp;<em>$rhInfo</em>&nbsp;variable into the method signature and just kept on writing. I ended up with a statement that I eventually shortened quite a bit.</p>


<pre class="brush: plain; title: ; notranslate">
$rhInfo.&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );
</pre>


<p>The ‘.’ after&nbsp;<em>$rhInfo</em>&nbsp;indicates we’re dealing with a reference, and the &lt;..&gt; notation is now how barewords look inside hashes. The old {_BIG_BLOCK_SIZE} is still there, but it’s pronounced {‘_BIG_BLOCK_SIZE’}. A lot of people use the {‘..’} in Perl already so it’s not a big change, and it actually simplifies the backend enormously.</p>



<p>Also, at the start Larry and Damian pulled statistics on Perl code from CPAN and other repositories. They were looking for operator frequencies, among other things. Frequently used operators like&nbsp;<em>qw()</em>&nbsp;and&nbsp;<em>-&gt;</em>&nbsp;got even shorter in Raku.</p>



<p>Others, like the ternary operator, weren’t so lucky. It got longer, and stretched to ‘?? .. !!’. So this is one place where the code will look a little funky. Maybe one day I’ll write a slang to fix it, but back to work.</p>



<h2>Trimming the verge</h2>



<p>Earlier I mentioned that this module was trimmed down from a much larger full OLE reader/writer. This was the first place that became evident. Since&nbsp;<em>$rhInfo</em>&nbsp;is now called&nbsp;<em>%hInfo</em>&nbsp;and initialized&nbsp;<strong>inside</strong>&nbsp;the method, this statement deserves to be looked at a little closer.</p>


<pre class="brush: plain; title: ; notranslate">
my %hInfo;
%hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );
</pre>


<p>After replacing&nbsp;<em>$rhInfo</em>&nbsp;with&nbsp;<em>%hInfo</em>&nbsp;this is what I got. But since&nbsp;<em>%hInfo</em>&nbsp;is defined just above, the test&nbsp;<code>%hInfo&lt;_BIG_BLOCK_SIZE&gt;</code><em>&nbsp;</em>will never be true, so this entire block can be reduced to:</p>


<pre class="brush: plain; title: ; notranslate">
my %hInfo = _BIG_BLOCK_SIZE =&gt; 2**9;
</pre>


<p>While I’m here I’ll delete&nbsp;<em>_adjust2()</em>. No code pathway uses it, so out it goes. I’ll restore it if I have to, but right now I want the test scripts to pass, and that’s it. I’ve got the original source, and a map from Perl to Raku, and that’s all I need.</p>



<h2>Culling yaks from the herd</h2>



<p>Where there’s smoke there’s fire, so I stop what I’m doing and grep out every ‘sub X’ call in the source, putting it in a scratch monkey. Then I go through the source (which I have below the new Raku source, deleting lines as I go) and look for methods that aren’t used, like&nbsp;<em>adjust2()</em>. I delete each of these methods with&nbsp;<strong>extreme</strong>&nbsp;prejudice, because each line of code I don’t see is one I don’t have to translate.</p>



<p>Checkpoint in git, and now it’s time for a lunch break. Afterwards, I’m getting into the&nbsp;<em>save()</em>method, and see what looks like a new yak to shave. Or a package to translate, to be precise.</p>


<pre class="brush: plain; title: ; notranslate">
  if(ref($sFile) eq 'SCALAR') {
    require IO::Scalar;
    my $oIo = new IO::Scalar $sFile, O_WRONLY;
    $rhInfo-&gt;{_FILEH_} = $oIo;
    # ...
}
</pre>


<p>In both Raku and Perl, you can create a single method called&nbsp;<code>new( $sFile )</code>&nbsp;that treats&nbsp;<em>$sFile</em>&nbsp;as either a filename (scalar), file content (scalar reference) or file handle (scalar object.) In Perl, if we wanted to handle filenames, file contents, or file handles differently, we’d have to switch like this, or have different method names.</p>



<p>In Raku, we can handle this differently. In fact I can write the code to save() to a filename, and add save() to a filehandle later with no modifications needed. Above, I briefly touched on the fact that you can write more than one&nbsp;<em>new()</em>&nbsp;method, as long as the two method signatures were distinct.</p>


<pre class="brush: plain; title: ; notranslate">
multi method save( Str $filename ) {...}
multi method save( IO::Handle $fh ) {...}
</pre>


<p>Raku will let you write two methods called&nbsp;<em>save()</em>, as long as it can tell which one to call at runtime. So, I can call&nbsp;<code>$root.save( '/tmp/test.xlsx' );</code>&nbsp;or&nbsp;<code>$root.save( $out_filehandle );</code>&nbsp;and Raku will “dispatch” it to the right&nbsp;<em>save()</em>&nbsp;method automatically.</p>



<p>We call it ‘multiple dispatch’ for just that reason, dispatching a function call to multiple versions of a method. And this means that I can write the first&nbsp;<em>save( Str $filename )</em>&nbsp;method without worrying about the other methods. I don’t have to add a new if-then branch to the existing code, or modify&nbsp;<em>save()</em>&nbsp;in any way.</p>



<p>I can just write my&nbsp;<em>save()</em>&nbsp;method and ignore the other IO:: types. Also, if someone gets my code later and wants to add a&nbsp;<em>save()</em>&nbsp;method that saves to something I know nothing about, they can write their new&nbsp;<em>save()</em>&nbsp;method without interfering with mine.</p>



<p>In this installment we’ve covered the basics of function and method calls, delved into the ternary operator, removed dead code and learned a little about multiple dispatch. Next time, we’ll open the binary filehandle we created above and delve into the mysteries of&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>.</p>



<p>I’ll also show you a new (yes, I couldn’t resist) grammar-based version of pack() that should cover the entire Perl gamut of packed types, with a bit of patience and a large enough test suite.</p>



<p>As always, gentle Reader, thank you for your time and attention. If you have any (constructive, please) comments, criticisms or questions, please let me know in the comment section below.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/</link>
					<comments>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 24 Nov 2019 12:07:18 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=63</guid>

					<description><![CDATA[Picking up from&#160;Part One, we’d just finished up rewriting a Perl script into the test suite for the Raku translation of&#160;OLE::Storage_Lite. Raku programming is made easier by having lots of tools, but Microsoft documents aren’t yet well-represented in the Raku ecosystem. Being able to read/write OLE allows us to create a whole range of Microsoft<a class="more-link" href="https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku II: Electric&#160;Boogaloo"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Picking up from&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Part One</a>, we’d just finished up rewriting a Perl script into the test suite for the Raku translation of&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>. Raku programming is made easier by having lots of tools, but Microsoft documents aren’t yet well-represented in the Raku ecosystem.</p>



<p>Being able to read/write OLE allows us to create a whole range of Microsoft documents (at least where they’re documented.) Because of its day-to-day use, we’re focusing on Excel here. Many businesses still rely on Excel for their day-to-day task management, time tracking and home-grown processes.</p>



<p>I’ve been known to wax philosophical about this after a few Westmalle Tripels at various conferences. Now is the time for doing something about it. Here’s what our burgeoning test suite looked like, at least in part. The current code is in&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>&nbsp;over on github.com. I’ve gotten rid of most of the Perl 5 test skeleton, but the essence remains.</p>


<pre class="brush: plain; title: ; notranslate">
use v6;
use Test;
use OLE::Storage_Lite;

plan 1;

my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
subtest 'Root', {
  isa-ok $oDt, 'OLE::Storage_Lite::PPS::Root';
  is $oDt.Name, 'Root Entry';
  is-deeply $oDt.Time2nd, [ 0, 0, 16, 4, 10, 100 ];
  # ...
};
done-testing;
</pre>


<p>Originally there really weren’t any Perl 5 tests for this module. I’m sure the original author treated the entire module as a black box, and they were happy to be able to run&nbsp;<em>samples/smpsv.pl</em>, open the new test.xls in Excel, and when it actually read the file, treat that as ‘ok 1’, push it to CPAN and call it a day.</p>



<h2>Testing, testing</h2>



<p>That’s wonderful, and I may eventually adopt that methodology. For the moment, the lack of a test suite leaves me a bit unsatisfied. I suppose I could treat the entire module as a black box and fix the translated version line-by-line as I go through it. I’ll have to do that eventually (spoiler alert: That’s actually where I am – I’m writing these pieces a bit after the fact.)</p>



<p>That leaves me with the question of what to test, and what the quickest way to get there is. The individual Directory, Root and File objects are exposed to the user, and are part of the public API. So it makes some sense to create an object, look at the internals, and do my best to match that in Raku.</p>



<h2>I Think I’m A Clone Now</h2>



<p>There’s always two [implementations] of me standing around… I don’t want to get sidetracked by reading the entire OLE spec. I might start to realize what a huge job this really is, and abandon ship. So, I’m going to limit myself to the following:</p>



<p>Create a narrowly defined 1:1 clone of the exact source of OLE::Storage_Lite in Perl 5. The objects will act exactly like the Perl 5 version, as will the API. This way I don’t have to think about what the API should do, how it should look in Raku, how the objects get laid out, anything fancy. All I need to worry about is:</p>



<ol><li>When I write&nbsp;<code>warn $oDt.raku</code>, does the output look the same as&nbsp;<code>use YAML; warn Dump($oDt);</code>&nbsp;in Perl 5?</li><li>When I write the final file to disk, does the Raku code output exactly the same file as the original Perl 5 version?</li></ol>



<p>That’s it. It takes away a lot of possibilities, but it lets me focus on getting the job done, not how things should look. Being able to test how the individual objects look will tell me that the read API works and saves enough data to be able to reconstruct the object in memory.</p>



<p>Conversely, being able to match the binary output tells me that the write API works, so I’ve effectively tested as much as the original module did. Plus I can automate some of the process, especially on the read side.</p>



<h2>Lost in Translation</h2>



<p>You can check out the current source at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>, and follow along with some of the changes I’ve made. I also made sure to keep a working copy of the original&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>Perl 5 module around. My Raku tree right now is very close to Perl 5.</p>



<p>I can insert a debug statement like&nbsp;<code>die "[$iBlockNo] [$sData]\n"</code>&nbsp;in the Perl 5 code, go to the equivalent line in Raku, and expect that when I run the two test suites, that they’ll die in exactly the same way.</p>



<p>This way when they&nbsp;<strong>don’t</strong>, I can immediately narrow down the problem simply by moving the ‘die’ statements up in the code until they return the same values. The line immediately below the ‘die’ statement will be the culprit.</p>



<h3>The Nitty Gritty Perl Band</h3>



<p>I’ll mention one thing in passing – the original Perl 5 source code is in a single file containing all of the packages. That’s not Raku style, so I’ve unpacked it into lib/OLE/Storage_Lite/* following the usual style of one Perl 5 class – one file.</p>



<p>So, time to get our hands dirty. The new Raku module won’t compile for quite a while, so we’d better put this into git. I’m also using&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.raku.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do my development and eventual push to CPAN, so all of that boilerplate is there too.</p>



<p>So, cue the montage scene of the dedicated Raku hacker pounding away at the keyboard, with the occasional break for food and/or adult beverage. Looking over her shoulder, we see a familiar split-screen view, with Perl 5 code on top, and a new Raku file below.</p>


<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
package OLE::Storage_Lite::PPS::Root;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS);
</pre>

<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root is OLE::Storage_Lite::PPS;
</pre>


<p>Raku has classes where Perl 5 has packages. The ‘unit’ declaration there says that the class declaration takes up the remainder of the file. This is sort of how Perl 5 does it, but gets rid of the ‘1;’ at the end of your package declaration.</p>



<p>It’s also useful for another reason I’m not going to show. Namely that the Perl 5 code is directly below the Raku code, commented out. I’m flipping between vim windows to delete lines as I translate them by hand. So the ‘unit class’ declaration helps in case I accidentally un-comment Perl 5 code – I’ll get big honkin’ warnings when I run the test suite.</p>



<h3>Moosey-ears!</h3>



<p>(for those of you that remember the module’s release)</p>



<p>Raku borrowed liberally from Perl 5’s Moose OO metamodel, to the point where using Raku will feel very similar. Just drop a few bits of syntactic sugar that Moose needed to work under Perl, and it’ll feel the same.</p>



<p>In this case the ‘is’ does the same job as in Moose, to introduce a parent class. Raku doesn’t need the sugar that Moose sweetens your code with, so you can just say your class ‘is’ a subclass of any other class.</p>



<p>Let’s keep rolling along here, with the next lines of the Perl 5 library:</p>


<pre class="brush: plain; title: ; notranslate">
require Exporter;
use strict;
use IO::File;
use IO::Handle;
use Fcntl;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS Exporter);
$VERSION = '0.19';
sub _savePpsSetPnt($$$);
sub _savePpsSetPnt2($$$);
</pre>

<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root:ver&lt;0.19&gt; is OLE::Storage_Lite::PPS;
</pre>


<p>Moving along… Okay, ya caught me, ‘:ver&lt;0.19&gt;’ is something new that we should add. Versions are now integrated into classes, so you can check them and even instantiate based on version number.</p>



<p>The module actually doesn’t export anything, so we don’t need Exporter at all. Raku enables ‘strict’ automatically, has IO modules in core, and doesn”t need Fcntl. The forward declarations aren’t needed for Raku, so all that’s left is the module’s version number, which gets added to the class name. You can add other attributes, too.</p>



<h2>Making things functional</h2>



<p>To keep things simple for me writing the code, and me having to read the code weeks, months or years later, I want as close to a 1:1 relation between Perl 5 and Raku as I can. Another place where this requires an accommodation (but not much of one) is just a few lines down, writing the creation method ‘new’.</p>


<pre class="brush: plain; title: ; notranslate">
sub new ($;$$$) {
    my($sClass, $raTime1st, $raTime2nd, $raChild) = @_;
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    );
}
</pre>


<p>By this point you’ll probably see more of why I say this module is a hard worker. It’s been around a long time, and function prototypes like this are one easy way to tell. Let’s rewrite it in a more modern Perl 5 style before making the jump to Raku, with function signatures.</p>


<pre class="brush: plain; title: ; notranslate">
sub new($sClass, $raTime1st, $raTime2nd, $raChild) {
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    )
}

</pre>


<p>Just drop the old function prototype, and replace it with the variables we need to populate. Well, almost. If you know what a subroutine prototype is, you might think I’m pulling a fast one on you. And you’d be right. Look back at the original Perl 5 code, and you’ll see ‘($;$$$)’ is the prototype.</p>



<p>The ‘;’ separates required variables from optional variables, and we haven’t accounted for that in our Perl 5 code. Since I’m not here to modernize Perl 5 code but convert it to Raku, I’m going to ignore that in Perl 5 and go straight to Raku.</p>


<pre class="brush: plain; title: ; notranslate">
multi method new( @aTime1st?, @aTime2nd?, @aChild? ) {
  self.bless(
    Time1st =&gt; @aTime1st,
    Time2nd =&gt; @aTime2nd,
    Child =&gt; @aChild
  );
}
</pre>


<h2>Under Construction</h2>



<p>And there we are. Now, there’s quite a bit to take in, so I’ll take things slow. The first thing you’ll notice is the keyword ‘multi’. In Perl 5, you get to hand-roll your own constructors, so you can make them any way you like. In this case, the author chose to write&nbsp;<code>new($raTime1st, $raTime2nd, $raChild)</code>, which is pretty common.</p>



<p>Raku gives me a default ‘new’ method, so I only need to hand-roll constructors when I want. Since I want to keep as close as reasonable to the original API, I’ll write a constructor that takes 3 arguments too. In my case I chose to simplify things just a bit here.</p>



<p>I’ve found over several years of writing Raku code that I rarely use references. In Perl 5 they were pretty much the&nbsp;<strong>only</strong>&nbsp;way to pass arrays or hashes into a function, because of its propensity to “flatten” arguments.</p>



<p>In Raku, you can still use the Perl 5 style, but formal argument lists are the way to go in my opinion. If you need to pass both an array and a hash to a Raku function, go for it. I encourage that in my tutorial courses, and recommend it to help break students out of their Perl 5 mindset.</p>



<p>This is not to say that there’s anything wrong with Perl 5’s argument list, in fact they’ve taken some ideas from Raku for formal argument lists, and I encourage that. Cross-pollination of ideas should be encouraged, it’s how both languages grow and add new features.</p>



<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Last week</a>&nbsp;was about the overall module, this week we delved a bit into the OO workings. Next week we’ll talk about references, attributes, and maybe progressive typing.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/</link>
					<comments>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 24 Nov 2019 12:00:00 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=66</guid>

					<description><![CDATA[This time around we’re going to talk about how to rewrite Perl code in Raku. Even in 2019, a lot of the office world revolves around spreadsheets, whether they be Excel,&#160;LibreOffice&#160;or simple .csv files. Perl 5 has a plethora of modules to do this, a quick search for ‘Spreadsheet’ on&#160;MetaCPANshould convince you of that. The<a class="more-link" href="https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for&#160;Raku"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>This time around we’re going to talk about how to rewrite Perl code in Raku. Even in 2019, a lot of the office world revolves around spreadsheets, whether they be Excel,&nbsp;<a href="http://web.archive.org/web/20200212094016/http://libreoffice.org/">LibreOffice</a>&nbsp;or simple .csv files. Perl 5 has a plethora of modules to do this, a quick search for ‘Spreadsheet’ on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/">MetaCPAN</a>should convince you of that.</p>



<p>The Raku world doesn’t have quite as many modules as you’d expect, though. While it’s been around for a few years, “heavy lifting” modules like Spreadsheet stuff really haven’t come around yet. This involves packing and unpacking binary formats, and in Perl 5 this centered around the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins, which are relative newcomers to Raku.</p>



<p>But Raku has built-in binary buffers, which take care of most of the need for pack/unpack. The main reason I can see is the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.microsoft.com/interop/docs/supportingtechnologies.mspx">OLE</a>&nbsp;storage format. Basically it’s Microsoft’s way of packing a file system into a single data file. And at this point the proverbial yaks start to pile up, and reasonable people say “You know, Excel still accepts .csv files, I know how to build those.”</p>



<p>Enter<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">&nbsp;raku-OLE-Storage_Lite</a>&nbsp;– this is my translation-in-progress from Perl 5 to Raku. As of this writing it can read an entire OLE file (without data) and write a good portion of the sample file – I believe I’ve got maybe two methods left to debug.</p>



<h2>Knee deep in yaks</h2>



<p>CSV files are easy to write, but they come with their own set of troubles. When you import a .csv file into your Excel app (or LibreOffice, or whatever) you’re faced with a complex dialog asking you how to import your data, and the average user doesn’t want that every time, they just want to open their spreadsheet.</p>



<p>So, it’s time to follow Liz’s lead and rewrite in Raku an existing module. First thing I did was go to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/Spreadsheet::ParseExcel">Spreadsheet::ParseExcel</a>&nbsp;and see how they did things. Within a few minutes I’d already encountered the first yak. After opening the file, it delegates it to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>, which is much like&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.jamesbrown.com/">James Brown</a>, the “hardest-working man in show business”.</p>



<p>It’s still on version 0.19 at the time of writing, but I assure you that’s only because the current maintainer hasn’t updated the version to reflect reality. It may be legacy Perl rough-and-tumble code, but it’s been around for a long time. It wears its battle scars proudly.</p>



<p>It relies heavily on&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>, which are still&nbsp;<strong>technically</strong>&nbsp;experimental in Raku. The OO and coding style betrays its pre-5.00 origins, and the tests are, well, very pragmatic. “Does it load? Great! Can it convert timestamps internally? Great! Ship it!”</p>



<p>To its credit, there’s a sample directory where you can use&nbsp;<em>smpview.pl</em>&nbsp;to view the contents of the internal filesystem of any OLE file, and a sample writer to create a known-working OLE file. That’ll do as a starting point.</p>



<h3>Buckling down</h3>



<p>So, reading an Excel spreadsheet means reading an OLE file system. And when I say file system, I’m not kidding. Inside your typical .xlsx file, there’s a small header and a root object. The root object contains “pointers” (really file offsets) to a document object, and inside that are file objects, each with pointers to the different blocks.</p>



<p>This is all intended to reflect the original disk layout, so it looks very much like an NTFS superblock and block layout. The documentation seems to have moved to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-oleds/fdc5e702-d09e-4344-a77f-eb079d41f23f">this</a>&nbsp;page detailing OLE 1.0 and 2.0 formats, I’m not at all certain what the current version has.</p>



<p>How are Excel spreadsheets arranged in here? Worksheets are OLE directories, and inside each worksheet, tabs are individual files. How’s that for a bit of inspiration? Luckily the Root directory, Files and nested Directories are all separate objects, with at least a few common methods aggregated into a superclass.</p>



<h2>Legacy Code</h2>



<p>This is a long-winded way of saying the module in question is very much legacy code. And, as I want to bring it into the proverbial light, I’ve got to give some issues some thought.</p>



<ol><li>No useful tests, so I’ll have to write those.</li><li>How much code do I want to sacrifice?</li><li>How much can I save?</li></ol>



<p>Well, I can put off #2 and #3 while writing some tests. Whoa, wait a minute. I don’t have a test file to work with, just some scripts over in sample/. Mumble, mumble, more yaks. Read README, find that smpsv.pl will create one, run that.</p>



<p>Great, I’ve got a sample test.xsl file. But given the amount of potential bit-rot it seems prudent to actually make sure that I’ve got a working Excel file before committing a few days (ha!) to getting a module working. Double-click it, launch into Excel’s cloud-serviced app, find that it’s one of those Win10 panes I’ve never figured out how to close, open task-killer, kill that.</p>



<p>Launch&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.libreoffice.org/">LibreOffice</a>&nbsp;which I happen to have lying around – my current project at work is parsing a spreadsheet in Perl 5, which is what inspired this whole workload.</p>



<p>Yep, that parses; looks a bit odd because it’s coming up with a Japanese font, and some arbitrary English text, but it works. Also, looking at the code it generates all three object types – Root, File and Dir, so it’ll exercise the major code paths. Bonus.</p>



<h2>Testing, testing</h2>



<p>Now I’ve got the makings of a simple test file. The script builds objects individually, so I can run the individual calls, and check that the object’s internals look the way I want.</p>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ ],
  [ 0, 0, 16, 4, 10, 100 ], # 2000/11/4 16:00:00:0000
  [ $oWk, $oDir ]
);
</pre>


<p>In Raku, this converts to:</p>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
</pre>


<p>I’ve made one change already, to make things simpler for Raku users. In Perl, you have to pass lists as references unless you want to use the new function signatures. In Raku, you can just pass lists as you would ordinarily to your method call.</p>



<p>Using native data types rather than passing references around may seem a bit odd at first to new Raku programmers, but the new variable classes are easier to enforce strong typing on later, when you get used to the language.</p>



<h3>Going with the flow</h3>



<p>Now we’ve got something we can test, namely making sure that we’ve got a valid OLE Root document. So, before we go ahead with the code, I’ll share a few little things. I know very little about this code, so I want to make sure that I&nbsp;<strong>intimately</strong>&nbsp;copy each detail of the object at this stage. Later on I might get fancy and replace things with their own object types, but for now, my goal is going to be 1:1 replication.</p>



<p>I tend to like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/tmux/tmux/wiki">tmux</a>&nbsp;as a shell environment, haven’t really gotten along with UIs. So, keeping in mind that I wanted an absolute 1:1 copy of the original object, I ended up doing this:</p>



<ol><li>Switch to new window, open my copy of ‘samples/smpsv.pl’ in vim</li><li>Add ‘use YAML; die Dump( $oDt ) just below the line where it gets created</li><li>Switch to new window, run the sample script, copy the YAML output</li><li>Close the two new windows I created to keep clutter down</li><li>Paste the YAML code into the new Raku test.</li></ol>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
--
  Name: "R\0o\0o\0t\0 \0E\0n\0t\0r\0y\0"
  No: ~
  Time2nd:
    - 0
    - 0
    - 16
    - 4
    - 10
    - 100
# and so on...
</pre>


<p>This should contain all I need to create an OLE file from this set of objects. I’m using this as a sneaky way of not reading the spec, at least not yet. As the old title goes: Algorithm + Data Structure = Program. Using YAML (or Data::Dumper) gives me the data structure, copying the Perl 5 code into Raku gives me the algorithm.</p>



<p>I should almost be able to keep line-for-line fidelity, so when a patch is posted to the Perl 5 source I can import it into Raku without too much trouble. But once I’ve got a better test base and a few users in Raku I’ll probably rewrite this whole module in a more Raku-ready fashion. I can keep the old module around for reference.</p>



<h2>Encoding worries</h2>



<p>But we’ve also got a surprise lurking here. “R\0o\0ot\0 \0E\0n\0t\0r\0y\0” looks like binary garbage, but is actually UCS-2, I think. If it is, then the OLE file is limited to a subset of Unicode. I can put restrictions on it later if I have to, but ATM I actually don’t care.</p>



<p>I’ve done enough time in the i18n salt mines that I know how to deal with this. Store the string in the best format possible (UTF-8 here) internally. When the time comes to write it to the network or disk, translate it to the final encoding.</p>



<p>This way I can see what all the attributes are at a glance without changing encoding. I can also manipulate everything using regular Raku code until the last moment. If I have to, I can use Raku’s gradual typing to constrain the string. More importantly, I don’t have to do any of this&nbsp;<strong>now</strong>.</p>



<h2>Got any change?</h2>



<p>This means I’m going to change things just a little bit more. When data gets added to ‘Name’ I’m going to assume it’s UTF-8. Since I’m not doing any I/O yet, I can make whatever assumptions I want. Keeping the internals simple keeps my life simple, at least.</p>



<p>So I’ll write out a quick&nbsp;<em>is-deeply</em>&nbsp;test and get on with things:</p>


<pre class="brush: plain; title: ; notranslate">
is-deeply $oDt, (
  Name =&gt; 'Root Entry',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
  Child =&gt; ( $oWk, $oDir )
);
</pre>


<p>This looks pretty straightforward, and almost how you’d write the original test in Perl 5. It won’t&nbsp;<strong>run</strong>&nbsp;yet, but that’s something we’ll tackle in the next part in the series.</p>



<p>I’m not done quite yet, because I’ve got a lot of these things to write, and not all of them may have the ‘Child’ attribute. I could write a tiny method that skipped over the ‘Child’ attribute along with anything else I wanted, but that felt clumsy. It looked like:</p>


<pre class="brush: plain; title: ; notranslate">
ok sorta-deeply $oDt, (
  Name =&gt; 'Root Window',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
), ( 'Child' );
</pre>


<p>And notice that&nbsp;<em>sorta-deeply</em>&nbsp;is a function that does all the work, then passes a simple Bool back to the test. I’d end up writing all of the code that&nbsp;<em>is-deeply</em>&nbsp;does (except for the recursion), and get something back that’s less useful.</p>



<p>Next time we’ll get into making these tests pass. I’m writing the next section right after this, but you won’t get to see it for another week or so, I’m afraid. If you have questions or comments about the first part of this series, please feel free to comment below.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Templates II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/</link>
					<comments>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Thu, 08 Aug 2019 11:09:35 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=69</guid>

					<description><![CDATA[Last time&#160;on this adventure writing the&#160;Template Toolkit&#160;language in Raku, we’d just created a small test suite that encompasses some of the problems we’re going to encounter. It’s no use without a grammar and a&#160;bunch&#160;of other parts, but it does give us an idea of what it’s going to look like. The list here is what<a class="more-link" href="https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/">Continue reading <span class="screen-reader-text">"Templates II: Electric&#160;Boogaloo"</span></a>]]></description>
										<content:encoded><![CDATA[
<p><a href="http://web.archive.org/web/20200212094016/http://theperlfisher.com/index.php/2019/07/18/templates-and-a-clean-start/">Last time</a>&nbsp;on this adventure writing the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>&nbsp;language in Raku, we’d just created a small test suite that encompasses some of the problems we’re going to encounter. It’s no use without a grammar and a&nbsp;<strong>bunch</strong>&nbsp;of other parts, but it does give us an idea of what it’s going to look like.</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit::Grammar;
use Template::Toolkit::Actions;

# ... similar lines above this
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
# ... and similar lines below this.
</pre>


<p>The list here is what we’re going to return to&nbsp;<em>render()</em>, and I’d love to make that as simple as it can be without being&nbsp;<strong>too</strong>&nbsp;simple. Let’s focus for the moment just on one bit of the test suite here, the array I’m getting back.</p>


<pre class="brush: plain; title: ; notranslate">
[ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
</pre>


<p>If these elements were&nbsp;<strong>all</strong>&nbsp;strings, then all&nbsp;<strong>render()</strong>&nbsp;would have to do is join the strings together, simples!</p>


<pre class="brush: plain; title: ; notranslate">
method render( Str $text ) returns Str {
  my @terms = # magic to turn text into array of terms
  @terms.join: '';
}
</pre>


<p>Let’s create the ‘Directive’ class and see what happens, though.</p>


<pre class="brush: plain; title: ; notranslate">
class Directive { has $.content }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: '';
# aaDirective&lt;94444485232315&gt;a
</pre>


<p>Whoops, that’s not what we want. Not&nbsp;<strong>bad</strong>&nbsp;exactly, but not what we want, either. Well, not to fear. Remember that in Template Toolkit, directives will always return a string. It may be an&nbsp;<strong>empty</strong>string, but they’ll always return some kind of string.</p>



<p>As a side note, this may not always be true – some directives will even tell the renderer to stop parsing entirely. But it’s a pretty solid starting assumption. For instance, we could say that encountering the STOP directive just makes all future directives return ”.</p>



<p>Of course, I’m harping on the term ‘string’ for a reason. Internally, everything is an object, and every object has a method that returns a readable value. Our Directive class didn’t specify one, so we get the default that returns ‘$name&lt;$address&gt;’.</p>



<p>So, let’s supply our own method.</p>


<pre class="brush: plain; title: ; notranslate">
class Directive { has $.content; method Str { $.content } }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: ', ';
# a, a, name, a
</pre>


<p>There. If we supply a .Str method we can make Directives do what we want. INCLUDE directives would open the file, slurp the contents and return them. Argument directives would take their argument name, look up the value, and return that. Or, more likely, would have a context object passed that does the lookup for them.</p>



<h2>Where do we go from here?</h2>



<p>Next time we’ll convince Grammars and Actions to work together, making processing a template as simple as:</p>


<pre class="brush: plain; title: ; notranslate">
parse-template( $text ).join( '' );
</pre>


<p>Next in this series on writing your own template language using Raku, you should be able to define your own Template Toolkit directives and have them return the pre-processed text. We’ll add support for context and the ability to do simple ‘[% name %]’ tags, and maybe explore how to change ‘[%’..’%]’ tags on-the-fly.</p>



<p>Thank you again, dear reader, for your interest, comments and critiques.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>A Regex amuse-bouche</title>
		<link>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/</link>
					<comments>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Wed, 24 Jul 2019 11:10:22 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=72</guid>

					<description><![CDATA[Before continuing with the Template series, I thought I’d talk briefly about an interesting (well, at least to me) solution to a little problem. System and user libraries (the kind that end in .so or .a, not Perl libraries) have a section at the top that maps a function name (‘load_user’ or whatever) to an<a class="more-link" href="https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/">Continue reading <span class="screen-reader-text">"A Regex amuse-bouche"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Before continuing with the Template series, I thought I’d talk briefly about an interesting (well, at least to me) solution to a little problem. System and user libraries (the kind that end in .so or .a, not Perl libraries) have a section at the top that maps a function name (‘load_user’ or whatever) to an offset into the library, say, 0x193a.</p>



<p>This arrangement worked fine for many years for C, Algol, FORTRAN and most other languages out there. But then along came languages that upset the apple cart, like C++ and Smalltalk, where a programmer could write two ‘load_user’ functions, call ‘load_user(1234)’ or ‘load_user(“Smith, John”)’ and expect the linker to load the right version of ‘load_user.’</p>



<p>The problem here is that the library, the linker and all of the other programs in the tool chain expect there to only be one function called ‘load_user’ in any given library.</p>



<p>Those of us that do Perl 5 and Raku programming don’t have to worry about this, but if you ever want to link to a C++ library, you probably should know at least a bit about “name mangling.”</p>



<p>For a while, utilities like ‘CFront’ for the Macintosh (which the author actually filed bug reports on) were used to “rename” functions like ‘load_user(int)’ and ‘load_user(char*)’ to ‘i_load_user’ and ‘cs_load_user’ before being added to the library, and other tools to do the reverse.</p>



<h2>Has Your Mother Sold Her Mangle?</h2>



<p>Eventually things settled down, and this process of changing names to fit into the library was “baked in” to the tool chains. Not consistently, of course, couldn’t have that. But conventions arose and even today&nbsp;<a href="http://web.archive.org/web/20200212094016/https://en.wikipedia.org/wiki/Name_mangling">Wikipedia</a>&nbsp;lists at least 12 different ways to “mangle” ‘void h(void)’ into the existing library formats.</p>



<p>We’ll just look at the first one, ‘_Z1hv’. The ‘_Z’ can be safely ignored, its purpose there is mainly to tell the linker something “special” is going on. ‘1h’ is the function name, and ‘v’ is its first (and only) parameter. Suppose, then, that you were tasked with writing a tool that undid this name mangling.</p>



<p>Your first cut at extracting something useful might look something like</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_useri' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };
</pre>


<p>Assuming&nbsp;<em>$mangle-me</em>&nbsp;has ‘_Z9load_useri’ in it (The mangled version of ‘void load_user(int)’) the regex engine goes through a bunch of simple steps.</p>



<ul><li>Read and ignore ‘_Z’</li><li>Read and ignore ‘9’</li><li>Capture ‘load_user’ into $0</li><li>Capture ‘i’ into $1</li><li>There is no fifth thing.</li></ul>



<p>But the person that wrote this library is playing silly buggers with someone (obviously&nbsp;<strong>us</strong>&nbsp;in this case) and there’s also a ‘_Z9load_userss’ which comes out of the other end of the mangle looking like ‘void load_user(char*, char*)’, loading a user with first and last names.</p>



<p>Now we’re in a bit of a quandary. Run the same expression and see what happens:</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_userss' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };
</pre>


<p>Sure enough,&nbsp;<em>$1</em>&nbsp;is ‘s’, just as we wanted it, but what about&nbsp;<em>$0</em>? It’s now ‘load_users’, which… y’know, looks too legit to quit. But we must. And now we’re faced with the quandary. Do we make the first parameter an optional capture? ‘m{ … (.)? (.) $ }’ like so?</p>



<p>No, that would capture the ‘r’ of ‘_Z9load_users’. There must be something else in the name that we’re overlooking, some clue… Aha! ‘load_user’ has 9 characters, and look just before it, we’ve got the number 9! Surely that tells us the number of characters in the function name! (and thankfully it actually&nbsp;<strong>does</strong>.)</p>



<h2>Regexes 201</h2>



<p>Now, how can we use this to our advantage? First things first, let’s get rid of some dead weight. We don’t care (for the moment) about parameters, so let’s just match the name and number of characters. And because we’re getting all serious up in here, let’s create a quick test.</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w+) };
is $0, '9';
is $1, 'load_user';
</pre>


<p>Run the test script, see if it passes, I’m sure you know the drill. Go ahead and copy that, I’ll wait. Okay, the tests pass, so it’s time to play. I usually am working in a library that’s in git, so I’m usually on the “edit, run tests, git reset, edit…” treadmill by this point.</p>



<p>So… How do we make use of this number? Well, let’s pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes">Regexes</a>&nbsp;page over at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>and look around. Back in Perl 5 there used to be this feature ‘m{ a{5} }x’ that matched just 5 copies of whatever it was in front of, that might be a good place to start looking.</p>



<p>That’s now morphed into ‘m{ a ** 5 }’. Great, so let’s replace 5 with&nbsp;<em>$0</em>&nbsp;and go for it.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** $0) };
</pre>


<p>“Quantifier quantifies nothing…” That’s weird.&nbsp;<em>$0</em>&nbsp;is right there, staring me in the face. Maybe I just got the syntax wrong somehow?</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** 9) };
</pre>


<p>Nope, that works. What’s going on here?&nbsp;<em>$0</em>&nbsp;is defined… Wait, it’s a variable inside a regex, that&nbsp;<strong>used</strong>&nbsp;to require the ‘e’ modifier, didn’t it? Or something like that… &lt;read the manpage, scratch head… nothing there&gt; Hm. Are we at a dead end?</p>



<h2>Kick it up a notch</h2>



<p>No, we just need to remember about how string interpolation works. In Raku, “Hello, {$name}!” is a perfectly fine way to interpolate variables into your expression, and it works because no matter where it is, {} signals a code block. Let’s try that, surround&nbsp;<em>$0</em>&nbsp;with braces.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {$0}) };
</pre>


<p>Weird. This time the test failed with ” instead of ‘load_user’. Maybe&nbsp;<em>$0</em>&nbsp;really isn’t defined? Now that it’s just regular Raku code, let’s check.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {warn "Got '$0'"; $0}) };
</pre>


<p>“Use of Nil in string context.” So it’s really empty. Now, we have to&nbsp;<strong>really</strong>&nbsp;do some reading. Looking at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#General_quantifier:_**_min..max">general quantifiers</a>&nbsp;says “only basic literal syntax for the right-hand side of the quantifier [what we want to play with] is supported,” so it looks like we’re at a dead end.</p>



<p>But things like ‘{$0}’&nbsp;<strong>do</strong>&nbsp;work, so we&nbsp;<strong>can</strong>&nbsp;use variables. That means that my problem isn’t that the variable is being ignored, it’s just not being populated when I need it. Let’s look at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#Capture_numbers">Capture numbers</a>&nbsp;to see when they get populated.</p>



<p>Aha, you need to “publish” the capture using ‘{}’ right after it. Let’s see if that works…</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) {} (\w ** {warn "Got '$0'"; $0}) };
</pre>


<p>Nope, something else is going on. And the next block down tells us the final solution – ‘:my’. This lets us create a variable inside the scope of the regular expression and use it as well, so let’s do just that.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z'
                     :my $length;          # Put $length in the proper scope
                     (\d+) {$length = +$0} # Capture the length
                     (\w ** {$length})     # And extract that many chars.
                   };
</pre>


<p>And reformat things just a wee bit so we’ve got some room to work with. Now the test actually runs, and reads only as many characters of the function name as needs be.</p>



<h2>And just one more thing…</h2>



<p>It’s not just function names that follow this pattern, it’s also namespaces, and any special types that the function might use as parameters, so let’s package this up into something more useful.</p>


<pre class="brush: plain; title: ; notranslate">
my regexp pascalish-string {
  :my $length;
  (\d+) {$length = +$0}
  (\w ** {$length})
};
'_Z9load_user' ~~ m{ ^ '_Z' &lt;pascalish-string&gt; };
is $/&lt;pascalish-string&gt;[0], 9;
is $/&lt;pascalish-string&gt;[1], 'load_user';
</pre>


<p>Pascal implementations were done back when RAM was at more of a premium, and stored a string like ‘load_user’ as ‘\x{09}load_user’ so the compiler knew how many bytes were available immediately rather than having to guess. It was limiting, but this was on computers like the early Macs (we’re talking pre-OS X, for that matter pre-System 7, for those of you that remember that far back.)</p>



<p>So we can use this&nbsp;<em>&lt;pascalish-string&gt;</em>&nbsp;regular expression anywhere we want to match one of our counted terms. Because we’re using ‘my’ inside a regular expression nested inside another regular expression inside a burrito wrapped in an enigma, there are no scoping troubles.</p>



<p>There are probably other ways of doing this, and I would love to see them. If you do come up with a better way to solve this, let me know in the comments and I’ll work your solution into an upcoming article.</p>



<p>As usual, gentle reader, thank you for your time and attention, and if you have any comments, questions, clarifications or criticisms (constructive, please) let me know.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Templates and a Clean Start</title>
		<link>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/</link>
					<comments>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Thu, 18 Jul 2019 11:11:17 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=75</guid>

					<description><![CDATA[Before I get into the meat of the topic, which will eventually lead to a self-modifying grammar (yes, you heard me, self-modifying…) I have a confession to make, in that a series of articles on the old site may have led people astray. I wrote that series thinking to make parsing things where no grammar<a class="more-link" href="https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/">Continue reading <span class="screen-reader-text">"Templates and a Clean&#160;Start"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Before I get into the meat of the topic, which will eventually lead to a self-modifying grammar (yes, you heard me, self-modifying…) I have a confession to make, in that a series of articles on the old site may have led people astray. I wrote that series thinking to make parsing things where no grammar existed easier.</p>



<p>It may have backfired. So, as a penance, I’m simultaneously pointing theperlfisher.{com,net} to this new site, and starting a new series of articles on Raku programming with a different approach. This time I’ll be incorporating more of my thoughts and what hopefully will be a different approach.</p>



<h2>Begin as you mean to go on.</h2>



<p>I would love to dump the CMS I’m currently using for something written in Raku. Among the many challenges that presents is displaying HTML, and to paraphrase Clint Eastwood,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.youtube.com/watch?v=_VrFV5r8cs0">I do know my limitations.</a>&nbsp;So, I don’t want to write HTML. Ideally, not ever.</p>



<p>So, that means&nbsp;<s>steal</s>&nbsp;borrowing HTML from other sites and making it my own. Since those are usually Perl 5 sites, that means dealing with Template Toolkit. And already I can hear some of you screaming “Raku already handles everything TT used to! Just use interpolated here-docs!”</p>



<p>And, for the most part, you’re absolutely correct. Instead of the clunky ‘[% variable_name %]’ notation you can use clean inline interpolation with ‘{$variable-name}’, and being able to insert blocks of code inline means you don’t have to go through many of the hoops that you’re required to jump through with Template Toolkit.</p>



<p>That’s all absolutely true, and I hope to be able to use all of those features and more in the final CMS, whatever that happens to be. This approach ignores the fact that most HTML out there is written with Template Toolkit, and that rewriting HTML, even if it’s just a few tiny tags, is an investment of time that could be better done elsewhere.</p>



<p>If only there were Template Toolkit for Raku…</p>



<h2>Let’s dive in!</h2>



<p>If you’re not familiar with&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>, it’s a fairly lightweight programming language for writing HTML templates, among others. Please don’t confuse it with a markup language, designed to be rendered&nbsp;<strong>into</strong>&nbsp;HTML. This is a language that lets you combine your own code with a template and generate dynamic displays.</p>


<pre class="brush: plain; title: ; notranslate">
&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;
</pre>


<p>That is a simple bit of Template Toolkit. Doesn’t look like much, does it? It’s obviously a fragment of a proper HTML document because there’s no ‘&lt;html&gt;’..'&lt;/html&gt;’ bracketing it, and obviously whatever’s between ‘[%’ and ‘%]’ is being treated specially. In this case, it’s being rendered by an engine that fills in the name, maybe something like…</p>


<pre class="brush: plain; title: ; notranslate">
$tt.render( 'hello.tt', :name( 'Jeff' ) );
</pre>


<p>where&nbsp;<em>hello.tt</em>&nbsp;is the name of the template file containing the previous code, and ‘Jeff’ is the name we want to substitute. We’ve got a lot of work to go through before we can get there, though. If you’ve read previous articles of mine on the subject, please try to ignore what I’ve said there.</p>



<h3>Off the Deep End</h3>



<p>First things first, we need a package to work in. For this, I generally rely on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.perl6.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do the hard work for me. Start by installing the package with&nbsp;<em>zef</em>, and then we’ll get down to business. (It should be installed by default, if you’re still using rakudobrew please don’t.)</p>



<pre class="wp-block-preformatted">$ zef install App::Mi6
{a bit of noise}
$ mi6 new Template::Toolkit
Successfully created Template-Toolkit
$ cd Template-Toolkit</pre>



<p>Ultimately, we want this test (in t/01-basic.t – go ahead and add it) to pass:</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit;
my $tt = Template::Toolkit.new;
is $tt.render( 'hello.tt', :name( 'Jeff' ) ), '&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;';
</pre>


<p>It’ll fail (and miserably, at that) but at least it’ll give us a goal. Also it should give us an idea of how others will use our API. Let’s think about that for a few moments, just to make sure we’re not painting ourselves into any obvious corners.</p>



<p>In order to be useful, our module has to parse Perl 5 Template Toolkit files, and process them in a way that’s useful in Raku. Certain things will go by the wayside, to be sure, but the core will be a module that lets us load, maybe compile, and fill in a template.</p>



<p>Hrm, I just said ‘fill in’ rather than ‘render’, what I said above. Should I change the method name? No, not really, the new module will still&nbsp;<strong>do</strong>&nbsp;what the Perl 5 code used to, it just won’t do it using Perl 5, so some of the old conventions won’t work. Let’s leave that decision for now, and go on.</p>



<h2>Retrograde is all the rage</h2>



<p>Let’s apply some basic retrograde logic to what we’ve got here, given what we know of Raku tools. In order to get the string ‘&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;’ from ‘&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;’, we need a lot of mechanics at work.</p>



<p>At first glance, it seems pretty obvious that ‘[% name %]’ is a substitution marker, so let’s just do a quick regexp like this:</p>


<pre class="brush: plain; title: ; notranslate">
$text ~~ s:g{ '[%' (\w+) '%]' } = %args{$0};
</pre>


<p>That should replace every marker in the text with something from an&nbsp;<em>%arguments</em>&nbsp;hash that&nbsp;<em>render()</em>&nbsp;supplies to us. End of column, end of story. But not so fast, if all Template Toolkit supplied to us was the ability to substitute values for keys, then … there’s really no need for the module. And in fact, if you look at the docs, it can do many more things for us.</p>



<p>For example, ‘[% INCLUDE %]’ lets us include other template files in our own, ‘[% IF %]’ .. ‘[% END %]’ lets us do things conditionally, and a whole host of other “directives” are available. But you’ll see here the one thing they have in common is they all start with ‘[%’ and end with ‘%]’.</p>



<h3>Hold the phone</h3>



<p>That isn’t entirely true, and in fact there’s going to be another article in the series about that. But it’s a good starting point. We may not know much about what the language itself looks like, but I can tell you that tags are balanced, not nested, and every ‘[%’ opening tag has a ‘%]’ tag that closes it.</p>



<p>I’ll also point out that directives ( ‘[% foo %]’ ) can occur one after another without any intervening white space, and may not occur at all. So already some special cases are starting to creep in.</p>



<p>In fact, let’s put this in as a separate test file entirely. So separate that we’re going to put it in a nested directory, in fact. Let’s open t/parser/01-basic.t and add this set of tests:</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit::Parser;

my $p = Template::Toolkit::Parser.new;

0000, AAAA
0001, AAAB
0010, AABA
0011, AABB
0100, ABAA
0101, ABAB
... # and so on up to
1110, BBBA
1111, BBBB
</pre>


<p>Now just HOLD THE PHONE here… we’re testing directives for Template Toolkit, not binary numbers, and whatever that other column is! Well, that’s true. We want to test text and directives, and make sure that we can get back text when we want it, and directives when we want them.</p>



<p>At first blush you might think it’s just enough to make sure that ‘&lt;h1&gt; Hello,’ is parsed as text, and that ‘[% name %]’ is parsed as a directive, and just leave it at that. But those of you that have worked with regular expressions for a while might wonder how ‘[% name %][% other %]’ gets parsed… does it end at the first ‘%]’, or continue on to the next one?</p>



<p>And what about text mixed with directives? Leading? Trailing text? Wow, a lot of combinations. In fact, if you wanted to be thorough, it wouldn’t hurt to cover all possible combinations of text and directives up to… say, 4 in a row.</p>



<p>Let’s call text ‘T’, and directives ‘D’. I’ve got 4 slots, and only two choices for each. Filling the first slot gives me ‘T_ _ _’ and ‘D_ _ _’, for two choices. I can fill the next slot with ‘T T _ _’, ‘T D _ _’, ‘D T _ _’, and ‘D D _ _’, and I think you can see where we’re going with this.&nbsp;</p>



<p>In fact, replace T with 0 and D with 1, and you’ve got the binary numbers from 0000 to 1111. So, let’s take advantage of this fact, and do some clever editing in our editor of choice:</p>


<pre class="brush: plain; title: ; notranslate">
0010, 0010                            =&gt;
is-deeply the-tree( '0010, AABA       =&gt;
is-deeply the-tree( '0010' ), [ AABA  =&gt;
is-deeply the-tree( '0010' ), [ AABA ];
</pre>


<p>A few quick search-and-replace commands should get you from the first line to the last line. Now it’s looking more like a Raku test, right? We’re not quite there yet, ‘0010’ still doesn’t look like a string of text and directives, and what’s this AABA thing? One more search-and-replace pass, this time global, should solve that.</p>


<pre class="brush: plain; title: ; notranslate">
is-deeply the-tree( '0010' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx1x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
          [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
</pre>


<p>Starting out with the padded binary numbers covers every combination of text and directive possible (at least 4 long). A clever bit of search-and-replace in your favorite editor gives us a working set of test cases that check a set of “real-world” strings, and a file you can almost run. Next time we’ll fill in the details, and get from zero to a minimal (albeit working) Template Toolkit implementation.</p>



<p>As always, dear reader, feel free to post whatever comments, questions, and/or suggestions that you may have, including ideas for future articles. I read and respond to every comment, and thank you for your time.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Logic Programming in Raku</title>
		<link>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/</link>
					<comments>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Fri, 21 Jun 2019 11:12:10 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=78</guid>

					<description><![CDATA[This is a small example of conference-driven development. I’m sitting in the board room at TPCiP – TCP in Pittsburgh surrounded by people doing both Perl 5 and Raku programming, and decided to look again at Picat, working on some simple examples. I was thinking that I might be able to translate some of the<a class="more-link" href="https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/">Continue reading <span class="screen-reader-text">"Logic Programming in&#160;Raku"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>This is a small example of conference-driven development. I’m sitting in the board room at TPCiP – TCP in Pittsburgh surrounded by people doing both Perl 5 and Raku programming, and decided to look again at Picat, working on some simple examples. I was thinking that I might be able to translate some of the simpler backtracking examples from Picat to Raku and here’s a simple example.</p>



<p>First the Picat code:</p>


<pre class="brush: plain; title: ; notranslate">
fib(0,F) =&gt; F=1.
fib(1,F) =&gt; F=1.
fib(N,F),N&gt;1 =&gt; fib(N-1,F1),fib(N-2,F2),F=F1+F2.
</pre>


<p>Now here’s my equivalent Raku code:</p>


<pre class="brush: plain; title: ; notranslate">
multi fib( 0, $F is rw ) { $F = 1 }
multi fib( 1, $F is rw ) { $F = 1 }
multi fib( $N is rw where * &gt; 1, $F is rw ) {
  my ( $F1, $F2 ) = 0, 0;
  my $N1 = $N - 1;
  my $N2 = $N - 2;
  fib( $N1, $F1 ) &amp;&amp; fib( $N2, $F2 ) &amp;&amp; $F = $F1 + $F2
}
</pre>


<p>The Raku version is slightly larger because I need to declare some variables that Picat would ordinarily declare for me ($F1, $F2). There may be a way to work around declaring ($N1, $N2), but otherwise the two versions are identical.</p>



<h2>How does it work?</h2>



<p>You’ve probably guessed based on the inputs that&nbsp;<em>N</em>&nbsp;is index of the Fibonacci number, and&nbsp;<em>F</em>&nbsp;is the Fibonacci number itself. Picat doesn’t require you to declare variables, so you could ask it for the 7th Fibonacci number by calling fib(7,F) and looking at&nbsp;<em>F</em>.</p>


<pre class="brush: plain; title: ; notranslate">
my $Fib = 0;
fib(7,$Fib);
say $Fib     # 21
</pre>


<p>Or you could do the above in Raku, letting the code populate&nbsp;<em>$Fib</em>&nbsp;for you. This code relies on the fact that Raku lets you dispatch not just on signatures, not just on argument types, but on&nbsp;<strong>values</strong>. Look at the base case above:</p>


<pre class="brush: plain; title: ; notranslate">
multi fib( 0, $F is rw ) { ... }
</pre>


<p><em>fi</em>b(…) is the function signature, and this function will get called whenever the first argument is 0, like so: fib(0, $Fib). This happens even if ‘multi fib( $N, $F )’ is the one doing the calling, everything gets run through the same dispatcher each time.</p>



<p>So fib(2, $Fib) calls fib(1, $Fib) which calls ‘multi fib( 1, $F )’ and gives us a base case, for example. This lets the higher-order functions call our base cases, and still get the right value.</p>



<h2>What are we missing?</h2>



<p>Well, the Picat code can do something the Raku code can’t, at least for the moment, and this is what I want to spend some time working on. In Picat, I can call ‘fib(6,F)’ and&nbsp;<em>F</em>&nbsp;will be 13 when the code is done. This works in Raku too.</p>



<p>But Picat will also let you call ‘fib(N,21)’ and&nbsp;<em>N</em>&nbsp;will be 7 when the calculation is finished. Take some time to let that settle. Yes, you can run the calculation both forward and backward. Give&nbsp;<em>N</em>&nbsp;a value, and&nbsp;<em>F</em>&nbsp;will be the Nth Fibonacci number. Give F a value, and it will tell you what&nbsp;<em>N</em>&nbsp;is.</p>



<p>In fact, Picat will go one step further. If you don’t specify a value for either parameter but just specify variables, like ‘fib(N,F)’, then it will generate all the Fibonacci numbers and their indexes until you tell it to stop.</p>



<p>This is because of the backtracking engine that it uses, which I want to see if I can mimick. ‘F=F1+F2’ doesn’t mean “Assign the sum of F1 and F2 to F”. Instead, “If any values are missing, find values that satisfy the equation, and keep generating them until you run out of possibilities.”</p>



<p>That’s a bit of a mouthful, so let’s look at just&nbsp;<em>F1</em>. Supposing F=8 and F2=5, the backtracking engine would search all values of&nbsp;<em>F1</em>, and return just the matching value of 3. Now of course, it can’t search&nbsp;<strong>all</strong>&nbsp;values, because that means you’d be waiting forever, so there are pruning algorithms at work here.</p>



<p>But the same logic can work with any combination of arguments, so if both&nbsp;<em>F1</em>&nbsp;and&nbsp;<em>F2</em>&nbsp;were missing, then the backtracking engine would run through all possible combinations of values (pruned appropriately) until it found a combination that would work.</p>



<p>In this case, since in our example F=8, it would return a bunch of combinations, starting with (F1=1, F2=7), (F1=2, F2=6) and so on. But why, then, you ask, does it only return (F1=3, F2=5)? That’s because each value&nbsp;<em>F1</em>&nbsp;<strong>also</strong>&nbsp;has to satisfy fib(N1,F1), which means that&nbsp;<em>F1</em>&nbsp;has to be a Fibonacci number, as does&nbsp;<em>F2</em>.</p>



<h2>Breakdown</h2>



<p>This is the part where Raku breaks down a little bit. But what I think I might be able to do is use a trick I used a while ago, relying on the fact that operators are just functions, and they dispatch just like other functions. So I should be able to start out with something crude like:</p>


<pre class="brush: plain; title: ; notranslate">
my $F = Operator.new( :lhs(3) );
my Value ($F1, $F2);
$F = $F1 + $F2;
</pre>


<p>This way both&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;are bound to backtracking Values, they return a Operator, and the Operator is part of the backtracking engine. This way once the Operator engine determines the range of possible combinations of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;that add to 3, it can assign them concurrently to&nbsp;<em>@F1.value</em>&nbsp;and&nbsp;<em>@F2.value</em>.</p>



<h2>Smooth Operators</h2>



<p>The Operator and Value classes, along with their overloaded operators, would look something like this:</p>


<pre class="brush: plain; title: ; notranslate">
class Operator {
  has ( $.lhs, $.rhs ); }
class PlusOperator is Operator { }
class AssignmentOperator is Operator {
  method make-combinations() {...} }
class Value {
  has @.value }
multi infix:&lt;=&gt;( Operator $lhs, Operator $rhs ) {
  AssignmentOperator.new( :$lhs, :$rhs );
}
multi infix:&lt;+&gt;( Value $lhs, Value $rhs ) {
  PlusOperator.new( :$lhs, :$rhs );
}
</pre>


<p>This is purely a sketch that I haven’t tried out at all. My idea here is that once you’ve executed ‘$F = $F1 + $F2’,&nbsp;<em>$F</em>&nbsp;will be an&nbsp;<em>AssignmentOperator</em>&nbsp;instance. You should be able to call&nbsp;<em>$F.make-combinations()</em>&nbsp;that will solve the equation ‘3 = $F1 + $F2’ for all (constrained) values of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>.</p>



<p>That would populate&nbsp;<em>@F1.values</em>&nbsp;and&nbsp;<em>@F2.values</em>&nbsp;with (1,2) and (2,1) respectively. I’m about to play my first game of&nbsp;<em>Azul</em>, so I’ll leave the article here. The next article will hopefully implement this so you can see this all working. It won’t quite be a true backtracking engine, but it’s a start.</p>



<p>Dear Reader, thank you for your attention, and please feel free to add comments, questions and suggestions.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Quantum Tunneling</title>
		<link>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/</link>
					<comments>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Mon, 20 May 2019 11:12:46 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=81</guid>

					<description><![CDATA[Introducing the new Perl Fisher site Before I get on to the meat of the article, welcome to the new home of The Perl Fisher. I intend to cover both Perl 5 and Raku programming here, but it’ll be mostly Raku content because that’s the language I find the most fun. Please excuse the dust,<a class="more-link" href="https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/">Continue reading <span class="screen-reader-text">"Quantum Tunneling"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Introducing the new Perl Fisher site</p>



<p>Before I get on to the meat of the article, welcome to the new home of The Perl Fisher. I intend to cover both Perl 5 and Raku programming here, but it’ll be mostly Raku content because that’s the language I find the most fun. Please excuse the dust, I’m still very much settling into the new home, and the overall look of the site is bound to change while I play with the new toys available to me.</p>



<h3>Defeating Thanos with Raku</h3>



<p>Don’t worry, no spoilers here. We’re just going to talk about a little-known feature of Raku, the quantum-tunneling variable type. If you’ve worked with Raku for any length of time, you’ve probably seen or written a class declaration that looks something like below.</p>


<pre class="brush: plain; title: ; notranslate">
class Point2D {
  has Real $.x;
  has Real $.y;
}
</pre>


<p>While the word ‘has’ does the real work, second-sigil syndrome strikes as well, in the shape of the ‘.’ between the scalar sigil ‘$’ and the variable name. Here it’s syntactical sugar for being an attribute name, but we can enlarge that ‘.’ to a ‘*’ and open up a world of possibilities.</p>



<p>When we add the ‘*’ sigil to a variable name, we turn that variable into one that can quantum tunnel between scopes and solve problems that you probably used to do with a global variable. You can read more about dynamic variables and how they differ from ordinary globals at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/variables#The_*_twigil">The_*_twigil</a>at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>.</p>



<h3>Testing, testing</h3>



<p>I’m working on a project to try to augment the Raku grammar debugger with an emulator. The tools we have on CPAN and modules.perl6.org respectively are wonderful, but they’re limited because Raku compiles grammar rules down to single methods, which is wonderful for speed, but makes it almost impossible to look into.</p>



<p>The grammar I’m writing isn’t important at the moment, but the testing part is. Below is a sample subtest that I’m writing for each term of a grammar that’s probably going to have ~50 terms by the time I’m done.</p>


<pre class="brush: plain; title: ; notranslate">
subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
    ok fails( '3g', 'binary-number' );
  };

  is build-ast( '0101', 'binary-number' ), 5;
};
</pre>


<p>This tests the ‘binary-number’ rule to see if it properly fails on ‘0b’ and ‘3g’. ‘0b’ fails because it’s the&nbsp;<strong>prefix</strong>&nbsp;of a binary number, and ‘3g’ because neither 3 nor ‘g’ are binary digits. It also makes certain that ‘0101’ gets translated into the decimal number 5. All important when testing a grammar that parses … well, itself eventually. Oroborous redux, as it were.</p>



<h3>Dry up, will you…</h3>



<p>The test is simple, and straightforward. ‘0b’ should fail, ‘0101’ should be built into a node of an abstract syntax tree. But it’s got some flaws. It talks too much. See how ‘binary-number’ repeats itself? If I want to copy that, rename it to ‘hex-number’ and add a few changes, I have to copy the block, rename all the incidences of ‘binary-number’ to ‘hex-number’ and&nbsp;<strong>then</strong>&nbsp;fix the existing tests.</p>



<p>Thus I run the risk of forgetting to update the name ‘binary-number’. And there’s an even greater bugaboo there. If I&nbsp;<strong>don’t</strong>, the test won’t fail. Because the subtest doesn’t know that it’s supposed to be testing the ‘binary-number’ rule. There are a bunch of ways to solve this problem, of course, but for this post we’re going to use Ant-Man(tm).</p>



<h3>Entering the Quantum Realm</h3>



<p>I don’t want to do&nbsp;<strong>too</strong>&nbsp;much work here, I just want to get rid of the duplicate ‘binary-number’ entries. So, let’s take a look at what&nbsp;<em>fails()</em>&nbsp;does.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}
</pre>


<p>The ‘!?(…)’ casts&nbsp;<em>$g.parse(…)</em>&nbsp;to a Boolean and negates it, so if&nbsp;<em>$g</em>&nbsp;can’t parse the statement, it returns&nbsp;<em>True</em>. So, first let’s make&nbsp;<em>$rule-name</em>&nbsp;optional.&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}
</pre>


<h4>Opening the wormhole</h4>



<p>Now, we’re going to summon Ant-Man(tm). Remember earlier I mentioned that quantum variables use a wormhole? Well, we’re going to open one end of the wormhole right here in our&nbsp;<em>fails()</em>&nbsp;function, just like this.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}
</pre>


<p>Rerun our tests, and … wait, they should fail, we haven’t declared&nbsp;<em>$*ANT-MAN</em>&nbsp;anywhere! Well, just like in quantum physics,&nbsp;<em>$*ANT-MAN</em>&nbsp;doesn’t have enough energy to tunnel over the quantum barrier because we haven’t defined him yet.&nbsp;</p>



<p>So let’s do that, but remember that&nbsp;<em>$*ANT-MAN</em>&nbsp;is a quantum variable, so he can tunnel through the quantum barrier of a function scope. In fact, he can tunnel through any number of them. So, let’s define a new version of&nbsp;<em>subtest()</em>&nbsp;that looks and acts like the old one first before we go boldly where no Raku programmer has gone before.</p>


<pre class="brush: plain; title: ; notranslate">
sub Subtest( Str $rule-name, Block $test-code ) {
  subtest $rule-name, $test-code;
}
</pre>


<p>We should be able now to replace the outer&nbsp;<em>subtest()</em>&nbsp;block with our new&nbsp;<em>Subtest()</em>&nbsp;block, and it should act just as it used to.</p>


<pre class="brush: plain; title: ; notranslate">
Subtest 'binary-number', {
  subtest 'failing', {
    ok fail( '0b', 'binary-number' );
    ...
  };
  ...
};
</pre>


<h4>Tunneling through</h4>



<p>Our test suite still works, and the output still is what we expect. Now, let’s give&nbsp;<em>$*ANT-MAN</em>enough energy to tunnel through the quantum barrier by defining him as the subtest name we want:</p>


<pre class="brush: plain; title: ; notranslate">
sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}
</pre>


<p>And now run our test suite. Which… doesn’t change. Come to think of it, we don’t want it to change. If it&nbsp;<strong>did</strong>&nbsp;change, we’d have to go through and change all of our test suites, which would be bad. So, putting things together, this code works just fine.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}
sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}

Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
  };
};
</pre>


<p>Notice by the way that&nbsp;<em>$*ANT-MAN</em>&nbsp;has tunneled through not one but&nbsp;<strong>two</strong>&nbsp;function signatures to get to where he is. And to prove it, finally, delete the inside ‘binary-number’.</p>


<pre class="brush: plain; title: ; notranslate">
Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b' );
  };
};
</pre>


<p>So ‘binary-number’ gets passed along to&nbsp;<em>$*ANT-MAN</em>&nbsp;who jumps into the quantum realm, tunnels through the outer&nbsp;<strong>and</strong>&nbsp;inner pairs of braces, and finally lands in&nbsp;<em>fails()</em>&nbsp;where he passes the value on to the :rule() declaration. Whew, that’s a lot of work.</p>



<h3>Oh, snap.</h3>



<p>(sorry, couldn’t resist.) If you’re like me, and I know&nbsp;<em>I</em>&nbsp;am, you’ve probably come across a few cases where this technique would come in handy. Especially if you’re dealing with legacy code. Sometimes you need to add just one little flag to a function and set that flag in a top-level handler on one page of a website.</p>



<p>The catch is that between the lower level and the top level there’s a chain of 8 function calls where you have to add that as a parameter. Wouldn’t it be nice if there was a workaround? Well, in Raku there is.</p>



<p>Thanks for getting all the way to the bottom of this, my inaugural article on Raku on the next generation of the Perl Fisher website. Feel free to leave comments and constructive criticism in the comments section below, and come back every so often to watch the website grow over the coming months.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Spacing Out</title>
		<link>https://perlfisher.wordpress.com/2019/04/12/spacing-out/</link>
					<comments>https://perlfisher.wordpress.com/2019/04/12/spacing-out/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Fri, 12 Apr 2019 11:17:13 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=84</guid>

					<description><![CDATA[After having had some comments about the grammar approach I’ve been using, I’ve started to rethink things. I may have isolated at least one problem people may have been having. I’m working on a grammar for a language called ‘picat’ – you can look up a quick explanation at&#160;picat.org. It’s a constraint-based programming language that<a class="more-link" href="https://perlfisher.wordpress.com/2019/04/12/spacing-out/">Continue reading <span class="screen-reader-text">"Spacing Out"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>After having had some comments about the grammar approach I’ve been using, I’ve started to rethink things. I may have isolated at least one problem people may have been having. I’m working on a grammar for a language called ‘picat’ – you can look up a quick explanation at&nbsp;<a href="http://web.archive.org/web/20190814083216/http://www.picat-lang.org/">picat.org</a>.</p>



<p>It’s a constraint-based programming language that maps insanely well onto Perl 6. A fragment of the grammar I’m working on follows, done in a top-down fashion. The actual grammar rule&nbsp;<em>&lt;comment&gt;</em>&nbsp;isn’t the important thing, because this problem can occur with anything.</p>



<p>If you must know, it’s a C-style /* .. */ comment. Of course I ran the test to make sure this little block of code properly matched beforehand. This way I could go along making one small change at a time, simple because it’s fairly late at night and I’ve got a flight to catch tomorrow..&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
&lt;comment&gt;
&lt;comment&gt;
&lt;comment&gt;

'go' '=&gt;'
   'doors(10).'
</pre>


<h3>Breaking up is hard to do</h3>



<p>The natural thing to do here is, of course, say to yourself “Hrm, I’ve got 3&nbsp;<em>&lt;comment&gt;</em>&nbsp;comment blocks in a row. We all know there are only 3 important numbers in computer science, 0, 1, and Infinity. So 3 is wrong and should be replaced with&nbsp;<em>&lt;comment&gt;+</em>.”&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
&lt;comment&gt;+

'go' '=&gt;'
   'doors(10).'
</pre>


<p>I then rerun the test, because I’m sticking to my nighttime rule of “one change, one retest”, and to my horror it breaks. I’ve only changed one thing, but … why is it breaking? Surely &lt;A&gt;+ should at&nbsp;<strong>least</strong>&nbsp;match &lt;A&gt; &lt;A&gt; &lt;A&gt; … that’s how DFA equivalences work in finite automata.</p>



<p>That’s also one point where Perl 6 and traditional DFAs (Deterministic Finite Automata) part ways. After a few years of doing Perl 6 programming, I see Perl 6 as almost overly helpful. Tools like&nbsp;<em>flex</em>&nbsp;and&nbsp;<em>bison</em>&nbsp;made me think of grammars as something that belonged outside the language.</p>



<h3>Where it all breaks down</h3>



<p>Unfortunately modules like&nbsp;<a href="http://web.archive.org/web/20190814083216/https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a>, through&nbsp;<strong>no</strong>&nbsp;fault of their own, can’t quite help here. While it’s a great module to tell you what particular rule or token failed, the problem here is&nbsp;<strong>between</strong>&nbsp;the terms.</p>



<p>&lt;A&gt; {whitespace-optional} &lt;A&gt; is subtly different than &lt;A&gt;+ because &lt;A&gt; &lt;A&gt; lets the parser read whitespace between the two terms; &lt;A&gt;+ assumes the terms come one after the other, whitespace be darned.</p>



<p>So, the simplest solution I have to offer is to let the comment eat the whitespace after it as well, so you can insert your &lt;comment&gt; token anywhere you like and it’ll still eat the whitespace no matter how you add it.</p>



<p>Another solution proposed on Reddit would be to use &lt;A&gt;˽+, with a space between the closing ‘&gt;’ and the modifier. Said user went beyond the call of duty and composed a “Seven stages of whitespace” post to make the point.</p>



<p>The &lt;comment&gt; token I have, like I said, is for C/C++ style “balanced” comments. Here they’re not balanced; /* This is a comment */ but this is not */, and/* This is a comment /* so is this */ this looks like it should but really isn’t. */&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
token comment
  {
  '/*' .+? '*/' \s*
  }
</pre>


<p>And all is well with the grammar. You can put this rule anywhere you like and it’ll behave whether you write &lt;comment&gt; &lt;comment&gt; or &lt;comment&gt;+. This little article was inspired by a Twitter user inspired after reading my first tutorial series. They got into the actual work of creating a grammar and problems started to happen.</p>



<h3>Wrapping up</h3>



<p>My original tutorial series was just that, a tutorial, I felt that getting too deep into the process interrupts the flow, so I didn’t talk about the work that went into it. Now that the series is pretty much done, I think it’ll be beneficial to talk about the actual problems of debugging one of these beasts.</p>



<p>And these thing can most definitely be beasts. Using my&nbsp;<a href="http://web.archive.org/web/20190814083216/https://github.com/drforr/perl6-ANTLR4">ANTLR4 to Perl 6 converter</a>&nbsp;you can generate some incredibly huge grammars. But just generating them doesn’t necessarily mean they’ll compile, although a few do right out of the box, which I’m genuinely amazed at.</p>



<p>The full test suite actually chooses a few grammars, converts them to Perl 6, compiles them and tests against sample input. I’m not sure how faithful they are to the real grammar, but they work.</p>



<p>Perl 6 does amazing things with precompiling and JITing. Grammars and regular expressions are one of the hardest-working things in Perl 6, so they get compiled down to functions. This means I can’t step into them even inside NQP, the dark side of Perl 6.</p>



<p>I’ve got ideas, so I’m going to keep working on grammar stuff. That means when I run into problems, well, it’s time to write another article. So look forward to a new series. Likely with a prosaic name of “Perl 6 Grammars Debun^wDebugged” or something similar. Thank you again, dear reader. Comments, clarifications and questions are of course welcome.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/04/12/spacing-out/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
	</channel>
</rss>
