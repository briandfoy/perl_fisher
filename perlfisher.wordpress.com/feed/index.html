<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>The Perl Fisher</title>
	<atom:link href="https://perlfisher.wordpress.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://perlfisher.wordpress.com</link>
	<description></description>
	<lastBuildDate>Tue, 30 Jun 2020 11:13:19 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='perlfisher.wordpress.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>The Perl Fisher</title>
		<link>https://perlfisher.wordpress.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://perlfisher.wordpress.com/osd.xml" title="The Perl Fisher" />
	<atom:link rel='hub' href='https://perlfisher.wordpress.com/?pushpress=hub'/>
	<item>
		<title>Rewriting Perl code for Raku Part V</title>
		<link>https://perlfisher.wordpress.com/2019/12/15/rewriting-perl-code-for-raku-part-v/</link>
					<comments>https://perlfisher.wordpress.com/2019/12/15/rewriting-perl-code-for-raku-part-v/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 15 Dec 2019 11:19:50 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://theperlfisher.wordpress.com/?p=31</guid>

					<description><![CDATA[Last week&#160;we started to talk about the&#160;pack()&#160;and&#160;unpack()&#160;builtins for Raku and Perl. These arenâ€™t terribly common built-ins to use, so I thought Iâ€™d take some time to go over these in detail and talk about how I use them and debug files that use them. As a gentle reminder,&#160;OLE::Storage_Lite&#160;is a Perl module to read and write<a class="more-link" href="https://perlfisher.wordpress.com/2019/12/15/rewriting-perl-code-for-raku-part-v/">Continue reading <span class="screen-reader-text">"Rewriting Perl code for Raku Part&#160;V"</span></a>]]></description>
										<content:encoded><![CDATA[
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/">Last week</a>&nbsp;we started to talk about the&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>&nbsp;builtins for Raku and Perl. These arenâ€™t terribly common built-ins to use, so I thought Iâ€™d take some time to go over these in detail and talk about how I use them and debug files that use them.</p>



<p>As a gentle reminder,&nbsp;<a href="https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>&nbsp;is a Perl module to read and write a subset of the Microsoft OLE storage format. As part of my effort at the start, Iâ€™ve got a â€œtranslationâ€ of the original Perl code pounded out, without much thought to whether itâ€™ll work, or really even compile. It looks like the Perl version, but with most of the {} changed to &lt;&gt; and -&gt; changed to ..</p>



<p>What to test firstâ€¦ The reading side seems to be the easiest, because I can check object-by-object to see what the data&nbsp;<strong>should</strong>&nbsp;look like. Replicating that for Raku becomes essentially fixing the bugs I know Iâ€™ve introduced on the way.</p>



<h2>Testing testingâ€¦ is this on?</h2>



<p>Before we dive into the Raku code, though, letâ€™s just set up a quick test in Perl. There really wasnâ€™t one to begin with, which is a testament to how well-used the module is. Iâ€™ve got a â€˜test.xlsâ€™ file that Iâ€™ve already checked in LibreOffice to make sure it works, so Iâ€™ll add a test script that reads the file and checks the root object.</p>


<pre class="brush: plain; title: ; notranslate">
use Test::More;
use OLE::Storage_Lite;

my $root = OLE::Storage_Lite-&gt;new( 'sample/test.xls' );
use YAML; die Dump($root);
isa_ok $root, 'OLE::Storage_Lite::PPS::Root';
is $root-&gt;No, 0;
is $root-&gt;PrevPps, 0xfffffffe;
</pre>


<p>You might be reading the code and wondering what the heck&nbsp;<em>die()</em>&nbsp;is doing in a test suite. Itâ€™s not because in my current copy itâ€™s commented out, but itâ€™s a quick and dirty way to get the data for the Raku version of the file, which looks almost the same.</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use OLE::Storage_Lite;

my $root = OLE::Storage_Lite.new( 'sample/test.xls' );
die $root.perl;
isa_ok $root, 'OLE::Storage_Lite::PPS::Root';
is $root.No, 0;
is $root.PrevPps, 0xfffffffe;
</pre>


<p>Notice thereâ€™s hardly any difference overall, just a few minor syntax tweaks. And I donâ€™t need to use YAML. But Iâ€™ve got a Q&amp;D way to run my code, and since my screen looks something like this:</p>



<figure class="wp-block-image size-large"><img data-attachment-id="56" data-permalink="https://perlfisher.wordpress.com/tmux-vim-screen-1-1/" data-orig-file="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png" data-orig-size="1457,1002" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tmux-vim-screen-1-1" data-image-description="" data-medium-file="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=300" data-large-file="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=750" src="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=1024" alt="" class="wp-image-56" srcset="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=1024 1024w, https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=150 150w, https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=300 300w, https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=768 768w, https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png 1457w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>Iâ€™ve got most of what I need in my face. This is all a rather plain&nbsp;<a href="https://github.com/tmux/tmux/wiki">TMUX</a>&nbsp;setup, running multiple panes so I can see whatâ€™s going on. On the left is vim running in split-screen mode with the Perl and Raku test files open. The rest are shells in the Perl and Raku directories, and some commands to get byte dumps of the files.</p>



<p>Iâ€™ve also in my shells set up the following aliases:</p>


<pre class="brush: plain; title: ; notranslate">
alias 5 = "perl -Ilib"
alias 5p = "prove -Ilib"
alias 6 = "perl6 -Ilib"
alias 6p = "prove -e'perl6 -Ilib'"
</pre>


<p>This way I can run both Perl and Raku test suites with just a few keystrokes, and not have to worry about details such as&nbsp;<em>-I</em>&nbsp;paths. Youâ€™re of course welcome to do things exactly the same, completely different, or even radically better than I am, in which case please let me know.</p>



<p>You might notice the use of the languageâ€™s old name here. I havenâ€™t changed over to the new binaries yet, but the techniques Iâ€™ll talk about here wonâ€™t change.</p>



<h2>Keeping it Clean</h2>



<p>We now have two scripts that should produce the same output, but probably wonâ€™t, for any number of reasons. Iâ€™ve got a whole articleâ€™s worth of things that I had to do to make the new module compile, let alone run. But thatâ€™s for a later issue.</p>



<p>Letâ€™s start out with this section, which might be familiar to longtime (ha!) readers.&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
  $rhInfo-&gt;{_FILEH_}-&gt;seek(0, 0);
  $rhInfo-&gt;{_FILEH_}-&gt;read($sWk, 8);
  return undef unless($sWk eq &quot;xD0xCFx11xE0xA1xB1x1AxE1&quot;);
</pre>


<p>This is in Perl, of course. In Raku Iâ€™ve chosen to write</p>


<pre class="brush: plain; title: ; notranslate">
  $file.seek( 0, SeekFromBeginning );
  my Str $sWk = $file.read( 8 ).unpack('A8');
  die "Header ID incorrect" if $sWk ne HEADER-ID;
</pre>


<p>Itâ€™s a bit ungraceful to&nbsp;<em>die()</em>&nbsp;inside a module, but this guarantees that execution stops way before it can cause a hard-to-debug problem down the road. The first change is that Iâ€™ve refactored&nbsp;<code>$rhInfo-&gt;{_FILEH_}</code>&nbsp;out into its own&nbsp;<em>$file</em>&nbsp;variable so I donâ€™t have to repeat references to&nbsp;<em>$rhInfo</em>&nbsp;all over the place, like the original.</p>



<p>Next is using the built-in&nbsp;<em>IO::Handle</em>&nbsp;constant â€˜SeekFromBeginningâ€™ instead of the rather anodyne 0 as in Perl. Probably the parent&nbsp;<em>OLE::Storage</em>&nbsp;module looked ahead in the file to determine something before reading in earnest. Iâ€™m keeping it here for no good reason other than it might be nice to separate â€˜readâ€™ functionality into a different method.</p>



<h3>Diving in</h3>



<p>The next line will cause some consternation, so Iâ€™ll unpack it slowly. The original author used Hungarian notation for their variable names, so the â€˜sâ€™ of&nbsp;<em>$sWk</em>&nbsp;means that itâ€™s a string type. Iâ€™ve adopted this for the Raku code as well, actually enforcing the variable type without additional code.</p>



<p>File handles have both a fancy&nbsp;<em>lines()</em>&nbsp;method that lets you read files line-by-line, and a raw&nbsp;<em>read()</em>method that lets you read raw bytes. If I stopped right here and just looked at the raw bytes, the code would actually fail, and Iâ€™ve talked about why in earlier parts. Suffice to say that&nbsp;<em>read()</em>returns a buffer of uninterpreted bytes, not a string that you have to decode later.</p>



<p>Decoding here is the job of the&nbsp;<em>unpack()</em>&nbsp;statement. It acts just like its Perl counterpart, but is experimental. Lucky for me, it implements enough of the Perl builtin that I can use it to read the entire OLE file.&nbsp;</p>



<p>Now, unlike other builtins (again, keeping in mind itâ€™s experimental,) itâ€™s only available as a method call. There is a version of&nbsp;<em>unpack()</em>&nbsp;that works on multiple arguments, but if you try to call it as a builtin, expect:</p>


<pre class="brush: plain; title: ; notranslate">
===SORRY!=== Error while compiling -e
Undeclared routine:
    unpack used at line 1. Did you mean 'pack'?
</pre>


<p>This may be fixed in your version, feel free to try it and let me know if I should upgrade&nbsp;<img src="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f642.png" alt="ğŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" />&nbsp;In any case, the last bit youâ€™re wondering about is the â€˜A8â€™ business as its argument. I think this isnâ€™t explained correctly in the documentation, so Iâ€™ll explain in my own way.</p>



<p><em>read()</em>&nbsp;returns a raw string of bytes, without interpretation. If it sees hex 041, it doesnâ€™t â€œknowâ€ if you meant the ASCII character â€˜Aâ€™ or the number 41, so it doesnâ€™t interpret the data, it just puts the data into the buffer. It relies on the the Buf(fer)â€™s&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>&nbsp;methods to assign types to the data.</p>



<p>So finally,&nbsp;<code>unpack( "A8" )</code>&nbsp;pulls out 8 â€œASCIIâ€ characters and puts them into&nbsp;<em>$sWk</em>. Now I used scare-quotes there because ASCII is a 7-bit encoding, not 8 bits as many people seem to think. It only encodes from 0x00-0x7f, so anything over that isnâ€™t legal ASCII.</p>



<p>Which just means that the â€œAâ€ of â€œA8â€ doesnâ€™t truly correspond to ASCII, but itâ€™s close enough. So, we call&nbsp;<em>unpack( â€œA8â€ )</em>&nbsp;on the buffer that&nbsp;<em>$file.read( 8 )</em>&nbsp;returns, and get back a string that we can finally check against our header.</p>



<h2>Debugging</h2>



<p>But what if the header isnâ€™t what we expect? Your first instinct might be to say you mustâ€™ve screwed up and sent it the wrong file. Luckily itâ€™s pretty easy to check that, just call&nbsp;<code>$file.slurp.print;</code>&nbsp;Thatâ€™ll tell you the contents quickly. If itâ€™s text youâ€™ve probably got the wrong file â€“ OLE files do contain text but itâ€™s usually zipâ€™ed or in UCS-2.</p>



<p>Letâ€™s assume though that itâ€™s an actual binary file, and a real spreadsheet that Excel (or LibreOffice in my case) can read. Since the headers donâ€™t match, it must be a different version of OLE that our code isnâ€™t ready to handle.</p>



<p>That means we need to know what the first 8 bytes of the file actually are. Weâ€™ve got a bunch of tools at our disposal, but what I want to introduce is&nbsp;<em>hexdump(1)</em>&nbsp;(donâ€™t worry about the (1), force of habit.) Run this command on the file:</p>


<pre class="brush: plain; title: ; notranslate">
hexdump -C sample-file.xls | head -1
</pre>


<p>This should generate something like this:</p>


<pre class="brush: plain; title: ; notranslate">
00000000  d0 c9 11 a0 af b1 13 d1  00 00 00 00 00 00 00 00  |................|
</pre>


<p>(original bytes changed to protect the innocent file) The numbers on the left (â€˜00000000â€™) tell us how far we are into the file (in hex), the next two groups of 8 are the hex values of the individual bytes of the file, and the dots between â€˜|..|â€™ are where any printable characters would appear, if there were any.</p>



<p>So now we know what the first 8 bytes of this file look like, and we can add (without much muss or fuss) some checks to our original file, and come up with this:</p>


<pre class="brush: plain; title: ; notranslate">
$file.seek( 0, SeekFromBeginning );
my Str $sWk = $file.read( 8 ).unpack('A8');
die "Unknown OLE header!" if $sWk eq "xd0xc9x11xa0xafxb1x13xd1";
die "Header ID incorrect" if $sWk ne HEADER-ID;
</pre>


<p>This check isnâ€™t in my source, so donâ€™t go looking for it. As far as I know there arenâ€™t any other OLE header strings than what I check for, but then Iâ€™m trying to get away without reading the spec. My blood pressure doesnâ€™t need that.</p>



<h2>Getting at the details</h2>



<p>Of course, binary packed formats contain more stuff than just ASCII strings. OLE was originally written in the days of 16-bit CPUs, so itâ€™s got other ways to pack in data. Letâ€™s look at a fragment of the file format: (not from the spec, this is just my interpretation)</p>


<pre class="brush: plain; title: ; notranslate">
0000: 0xD0 0xCF 0x11 0xE0 0xA1 0xB1 0x1A 0xE1 # header
0008: 0x00 0x09           # size of large block of data (in power-of-2)
000a: 0x00 0x06           # size of small block of data
000c: 0x00 0x00 0x00 0x03 # Number of BDB blocks
0010: 0xff 0xff 0xff 0xfe # Starting block
</pre>


<p>So, this is the first 20 (0x0010+4) bytes of an OLE header block. You may have already caught on to the fact that there are at least 3 sizes of data here. The first 8 bytes on line 0000 is the header data we talked about ad nauseam.</p>



<p>Next, the header says that a â€œlargeâ€ block of data is 2**9 bytes long, and a â€œsmallâ€ block of data is 2**6 bytes long, this time in pairs of bytes. Finally weâ€™ve got the number of BDB blocks (whatever those are, probably Berkeley DB) and the starting blockâ€™s index number, all in 4-byte chunks.</p>



<p>This means we need to read 2 2-byte chunks and 2 4-byte chunks into memory. This time though, we have to read them as numbers. Once again,&nbsp;<em>unpack()</em>&nbsp;comes to the rescue. Last time we used the â€˜Aâ€™ character, this time weâ€™ll do something just a little bit different.</p>



<p>Letâ€™s read the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/routine/unpack">documentation</a>&nbsp;for&nbsp;<em>unpack()</em>&nbsp;to see what we can use. Halfway down the page we come to a table which gives us the letter abbreviations for each type of data we can read, and what it is in terms of where it is in memory.</p>



<p>For now, replace the term â€˜elementâ€™ with â€˜byteâ€™ while youâ€™re reading the documentation. We need to read (0x00, 0x09) as a 2-byte integer, so letâ€™s look for â€œtwo elementsâ€ on the right-hand side. â€œExtracts two elements and returns them as a single unsigned integerâ€ seems to be what we need.</p>



<p>So it looks like the letter we need to use is â€œSâ€, and since we only want to read one at a time, thatâ€™s all we need. But the original Perl source uses â€œvâ€, so thatâ€™s what Iâ€™ll use as well.</p>


<pre class="brush: plain; title: ; notranslate">
  $iWk = _getInfoFromFile($rhInfo-&gt;{_FILEH_}, 0x1E, 2, &quot;v&quot;);
  return undef unless(defined($iWk));
  $rhInfo-&gt;{_BIG_BLOCK_SIZE} = 2 ** $iWk;
</pre>


<p>But as you can see, the Perl source creates a wrapper around the&nbsp;<em>pack()</em>&nbsp;method, much to my annoyance. Iâ€™d prefer to simply write this:</p>


<pre class="brush: plain; title: ; notranslate">
$iWk = $file.read( 2 ).unpack( &quot;v&quot; );
%hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2**$iWk;
</pre>


<p>but to keep things looking as similar to the original Perl code as I can, my code looks like&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
  my Int $iWk = self._getInfoFromFile( $file, 0x1E, 2, &quot;v&quot; );
  die &quot;Big block size missing&quot; unless defined( $iWk );
  %hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2 ** $iWk;
</pre>


<p>which is just one line longer, and thatâ€™s because of the safety check. Of course,&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>can take more than one format character at time. In Perl, thereâ€™s yet another mini-language (like regex, and what used to be called the&nbsp;<em>format</em>&nbsp;statement) for these builtins, and thatâ€™s not quite done yet.</p>



<p>But you can still take the entire header weâ€™ve collected so far, and write it into a single&nbsp;<em>unpack()</em>statement like so:</p>


<pre class="brush: plain; title: ; notranslate">
my ( $header, $large-size, $small-size, $num-bdbs, $start-block ) =
  $file.read( 20 ).unpack( "A8 vv VV" );
</pre>


<p>This format is of course much more compact and much easier to read. In all probability once I get done with the main module Iâ€™ll convert everything over to this style and the code will become much, much quieter. Binary protocols, especially those for moisture evaporators, tend to have lots of code that looks like:</p>


<pre class="brush: plain; title: ; notranslate">
my $rev = $file.read(2).unpack("v")
if $rev == 0x01 {
  $r2 = $file.read(2).unpack("v");
} else {
  $d2 = $file.read(4).unpack("V");
}
</pre>


<p>where the next bytes you read depend upon the version of the protocol. Even though Iâ€™ve just been rattling off code based on the Perl version, I donâ€™t know what the protocol may&nbsp;<strong>do</strong>&nbsp;at any given point. So it makes sense to read just one int or long ahead while developing.</p>



<p>I could read a version number as â€œVâ€ because they started out using â€œv1â€, â€œv2â€ and so on up to â€œv42792643522â€. But then 30 lines and 2 revs later they may have changed from â€œVâ€ to â€œvccâ€ because they wanted to support â€œv2.1.0â€ style.</p>



<p>And if that header were something like â€œA8 V CC* V vvâ€ I have to go back and break up the format string and statement at the very least. If I go term-by-term I just have to find the version number and add an if-then statement just below.</p>



<p>Now that youâ€™ve got a fairly good grounding in&nbsp;<em>unpack()</em>, I think itâ€™s time for break. Next time weâ€™ll cover writing our file back out, the most fun part of the operation.</p>



<hr class="wp-block-separator" />



<p>Again, many thanks to those of you that have read this far. As usual, Gentle Reader, please feel free to leave constructive questions, comments, critiques and improvements in the comment section. I do require an email address for validation, but I donâ€™t use it for any other purpose. Thank you again, and Iâ€™ll see you in part VI of this series.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/12/15/rewriting-perl-code-for-raku-part-v/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>

		<media:content url="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=1024" medium="image" />
	</item>
		<item>
		<title>Rewriting Perl Code for Raku IV: A New Hope</title>
		<link>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/</link>
					<comments>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 08 Dec 2019 11:36:34 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://theperlfisher.wordpress.com/?p=39</guid>

					<description><![CDATA[Back in&#160;Part III&#160;of our series on Raku programming, we talked about some of the basics of OO programming. This time weâ€™ll talk about another aspect of OO programming. Perl objects can be made from any kind of reference, although the most common is a hash. I think Raku objects can do the same, but in<a class="more-link" href="https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku IV: A New&#160;Hope"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Back in&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Part III</a>&nbsp;of our series on Raku programming, we talked about some of the basics of OO programming. This time weâ€™ll talk about another aspect of OO programming. Perl objects can be made from any kind of reference, although the most common is a hash. I think Raku objects can do the same, but in this article weâ€™ll just talk about hash-style Perl objects.</p>



<p>Raku objects let you superclass and subclass them, instantiate them, run methods on them, and store data in them. In previous articles weâ€™ve talked about all but storing data.&nbsp;Itâ€™s time to remedy that, and talk about attributes.</p>



<h2>Instance attributes</h2>



<p>We used&nbsp;<code>unit class OLE::Storage_Lite;</code>&nbsp;to declare our class, and&nbsp;<code>method save( $x, $y ) { ... }</code>&nbsp;to create methods. Or in our case rewrite existing functions into methods. Now, we focus our attention on some of the variables that should really be instance attributes, and why.</p>



<p>Letâ€™s get to know which variables behave like attributes, and which donâ€™t. This&nbsp;<strong>will</strong>&nbsp;change how we write our Raku code, but hopefully for the better. Weâ€™ll start from the outside in, and look at the API. There are a few â€œtestâ€ scripts that use the module, and this fragment is pretty common.</p>


<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite;
my $oOl = OLE::Storage_Lite-&gt;new('test.xls');
my $oPps = $oOl-&gt;getPpsTree(1);
die( &quot;test.xls must be a OLE file&quot;) unless($oPps);
</pre>


<p>The author creates an object (<em>$oOl</em>) from an existing file, then fetches a tree of â€œPpsâ€ objects, whatever they are. So, one&nbsp;<em>OLE::Storage_Lite</em>&nbsp;object equals one file. This gives me my first instance variable,&nbsp;the filename.</p>


<pre class="brush: plain; title: ; notranslate">
sub new($$) {
  my($sClass, $sFile) = @_;
  my $oThis = {
    _FILE =&gt; $sFile,
  };
  bless $oThis;
  return $oThis;
}
</pre>


<p>Above is how they wrote it in Perl, and below is how weâ€™d write it (exactly as specified) in Raku:</p>


<pre class="brush: plain; title: ; notranslate">
has $._FILE;

multi method new( $sFile ) {
  self.new( _FILE =&gt; $sFile );
}
</pre>


<p>Later on, we can call&nbsp;<code>my $file = OLE:Storage_Lite.new( 'test.xls' );</code>&nbsp;just like we did in Perl. We wouldnâ€™t even need the&nbsp;<em>new</em>&nbsp;method if we had users call&nbsp;<code>my $file = OLE::Storage_Lite.new( _FILE =&gt; 'text.xls' );</code>. This gives users the option of calling the API in the old Perl fashion or the new Raku fashion without additional work on our part.</p>



<h2>Strict Raku-style</h2>



<p>Thereâ€™s a problem lurking here, though. The constructor Raku provides us lets us call&nbsp;<code>my $file = OLE::Storage_Lite.new();</code>&nbsp;without specifying a value for&nbsp;<em>$._FILE</em>. If you know Perlâ€™s Moose module, though, the â€˜hasâ€™ there just might look familiar.</p>



<p>And for good reason. A lot of the ideas from Moose migrated into Raku during its design, and the attributes were one of those. Moose lets you do a lot of things with attributes, and so does Raku. One of those is you can add â€œadverbsâ€ to them. Letâ€™s do that now.</p>


<pre class="brush: plain; title: ; notranslate">
has $._FILE is required;
</pre>


<p>Calling&nbsp;<code>OLE::Storage_Lite.new()</code>&nbsp;now fails, because youâ€™re not passing in the&nbsp;<em>_FILE</em>&nbsp;argument. That solves one problem. Actually, it solves two, come to think of it. In the original Perl code, you could call&nbsp;<code>OLE:Storage_Lite-&gt;new()</code>&nbsp;too, and it wouldnâ€™t complain. Now weâ€™ve fixed that, with one new term.</p>



<h2>Progressive Typing</h2>



<p>No, weâ€™re not talking about some new editor like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.commaide.com/">Comma</a>&nbsp;(the link&nbsp;<strong>does</strong>&nbsp;work, despite the certificate problem.) Our code would run just fine, as-is. Users could call our&nbsp;<em>.new()</em>&nbsp;API, Raku would make sure the filename existed, and we could go on with translating.</p>



<p>But thereâ€™s something more we can take advantage of here, and that is the fact that any Raku object (and anything we can instantiate is an object) is a type as well. We havenâ€™t mentioned that because we really couldnâ€™t use that information until now.</p>



<p>The original Perl code is littered with clues to types, hidden in the variable names. When we wrote our own API call, the Perl code called the file name&nbsp;<em>$sNm.</em>&nbsp;The â€˜sâ€™ tells the Perl compiler nothing, but it tells us that&nbsp;<em>$sNm</em>&nbsp;is a String type. Perl may not have true types, but Raku does. Letâ€™s fix our attribute with that in mind.</p>


<pre class="brush: plain; title: ; notranslate">
has Str $._FILE is required;
</pre>


<p>We knew all along that&nbsp;<em>$._FILE</em>&nbsp;is a string of some sort, but telling Raku that lets it allocate space more efficiently. Making sure itâ€™s a required attribute lets anyone that calls&nbsp;<em>new()</em>&nbsp;know if they forget an argument. We could go a little farther with this, but locking down attributes will help in the long run, when we start dealing with the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;built-ins.</p>



<h2>Packing It All In</h2>



<p>Weâ€™re now getting to the heart of the module. Thereâ€™s a lot of mechanics above us, allocating objects and doing math and checking types, and not much below us. The classâ€™ entire purpose is to read and write OLE-formatted files. Weâ€™ll talk more about the boilerplate, but hereâ€™s the real meat of the file.</p>



<p>Letâ€™s start with what should be simple, reading in data. Just like in Perl, we open a file and get back a â€œfile handleâ€ (assuming the file exists, of course.) By default, calling&nbsp;<code>my $fh = open $._FILE;</code>gives us a read-only file handle. The file handle itself has a bunch of attributes associated with it, but the important one right now is its encoding.</p>



<p>Namely, the fact that it has none. An OLE file is essentially a miniature filesystem (probably based on FAT) packed onto disk, complete with a root directory, subdirectories and files. File have names encoded in UCS-2, but the rest is entirely dependent upon what the application requires.</p>



<p>The upshot of which is that we canâ€™t read the format with something simple like&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;which would read line after line into the&nbsp;<em>@lines</em>&nbsp;array. Instead weâ€™ll use calls like&nbsp;<em>read()</em>and&nbsp;<em>write()</em>&nbsp;that return byte-oriented buffers.</p>



<h2>Bufferingâ€¦</h2>



<p>All OLE files start off with the header â€œxD0xCFx11xE0xA1xB1x1AxE1â€, so we should probably start there. Thatâ€™s important twice in the code, in fact. First, when weâ€™re reading off disk, we can check it against what weâ€™ve just read to make sure this file is OLE, and not, say, a JSON file. Later on, when weâ€™re saving out an OLE file, we can write it as the header string.</p>


<pre class="brush: plain; title: ; notranslate">
constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";
</pre>


<p>Iâ€™ll make it a constant as well, so when I revisit this code in a month I donâ€™t have to go looking in specs for â€˜0xd0 0xcfâ€™ to remember what this is. Reading is straight-forward too. It needs just a byte count.</p>


<pre class="brush: plain; title: ; notranslate">
my Buf $header = $fh.read( 8 );
</pre>


<p>Something important to notice here is the type, â€˜Bufâ€™. If our file was in Markdown, or JSON we could get away with just writing&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;like I tried earlier. But these are raw bytes, hindered by no interpretation. Letâ€™s see what happens when we compare these bytes to our&nbsp;<em>HEADER-ID</em>.</p>


<pre class="brush: plain; title: ; notranslate">
t/01-internals.t ............ Cannot use a Buf as a string, but you called the Stringy method on it
  in method _getHeaderInfo at /home/jgoff/GitHub/drforr/raku-OLE-Storage_Lite/lib/OLE/Storage_Lite.pm6 (OLE::Storage_Lite) line 169
  in block &lt;unit&gt; at t/01-internals.t line 42
</pre>


<h2>Another brick in the wall</h2>



<p><strong>Ka-blam</strong>. Butâ€¦ hold the phone here a minute, I just said&nbsp;<code>$header eq HEADER-ID</code>, I didnâ€™t write anything like â€˜Stringyâ€™! Thereâ€™s no â€˜Stringyâ€™ in the sourceâ€¦ oh.&nbsp;<em>HEADER-ID</em>&nbsp;is a string, so Raku is being helpful. Iâ€™m trying to use string comparison (â€˜eqâ€™) between something thatâ€™s not a Str (&nbsp;<em>$header</em>&nbsp;) and something that is (<em>HEADER-ID</em>).</p>



<p>Pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Stringy">Stringy</a>&nbsp;documentation, and look for the Type graph. Midway down youâ€™ll see â€˜Bufâ€™ and â€˜Strâ€™, as of this writing Buf is on the left, and Str is popular so itâ€™s in the middle.</p>



<p>Trace the inheritance paths from Buf and Str upwards, and youâ€™ll see they pass Buf -&gt; Blob -&gt; Stringy and Str -&gt; Stringy, and stop. What the error message therefore is saying is this, anthropomorphized:</p>



<p>You wanted to convert&nbsp;<em>Buf</em>&nbsp;to&nbsp;<em>Str</em>, and didnâ€™t care how you did it. So I looked. First, on the&nbsp;<em>Buf</em>&nbsp;type. No .Str method there, at least without arguments. No good. So I looked in its parent,&nbsp;<em>Blob</em>. Nothing doing there. Then I looked at&nbsp;<em>Stringy</em>, and couldnâ€™t find anything else.</p>



<p>Thereâ€™s nothing above me, nothing below. So Iâ€™ll let you know I looked for a conversion method in a bunch of places, stopped at&nbsp;<em>Stringy</em>, and couldnâ€™t go any farther. Sorry.</p>



<p><em>Raku</em></p>



<p>Youâ€™re probably wondering how to get out of this quandary. Reading the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Blob#method_Str">Blob</a>&nbsp;documentation closely, you might think that the&nbsp;<em>encode</em>&nbsp;method is the way out of our present jam. If you look closer, though, thereâ€™s a spanner in the works. â€œxD0â€ is the&nbsp;<strong>byte</strong>&nbsp;0xd0, so if you try to decode to ASCII, you run into the problem that ASCII only covers 0x00-07xf, everything outside of that is undefined.</p>



<h2>Packing for vacation</h2>



<p>If youâ€™ve kept up with things, you might surmise by now that the key to our quandary lies in the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins. Specifically&nbsp;<em>unpack()</em>, because weâ€™re trying to â€œdecodeâ€ a buffer into something suitable for Raku.</p>



<p>Unless youâ€™ve done things like network programming or security, the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins are going to be unfamiliar territory. The closest analogue of&nbsp;<em>pack()</em>&nbsp;is the builtin&nbsp;<em>sprintf()</em>.</p>



<p>Both of these builtins take a format string telling the compiler how to arrange its arguments. Both of them take a mixture of string and integer arguments afterwards. But while&nbsp;<em>sprintf()</em>&nbsp;takes the arguments and treats its output as a UTF-8 encoded string,&nbsp;<em>pack()</em>&nbsp;takes the same arguments and treats its output as a raw buffer of bytes.</p>



<p>And now you can see one way out of our little predicament. If we could just find the right invocation,&nbsp;<em>pack()</em>&nbsp;would be able to take our string â€œxd0xcfâ€¦â€ and turn it into a Buf object. Then we could compare the buffer we got by reading 8 bytes to the buffer we expected.</p>



<p>So instead of cluttering up the main code, letâ€™s write a quick test.</p>


<pre class="brush: plain; title: ; notranslate">
use experimental :pack;
constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";

use Test;
my $fh = open "test.xls";
my Buf $buf = $fh.read( 8 );

is $buf, pack( "A8", HEADER-ID ); # Pack 8 ASCII characters
</pre>


<h2>Testingâ€¦testingâ€¦</h2>



<p>Letâ€™s take it from the top. We tell Raku to use the â€œexperimentalâ€&nbsp;<em>pack()</em>&nbsp;builtin, and declare the header we want to check against. Then we tell Raku we want to use the Test module, and open a new Microsoft Excel test file.</p>



<p>Last, we read a chunk of 8 bytes from the file into a buffer, and check to see that the 8 bytes matches the header we expect to see. Now, how did we get that weird â€˜A8â€™ string in there? I thought&nbsp;<em>pack()</em>&nbsp;looked more like&nbsp;<em>sprintf()</em>?</p>



<p>Well, it does, to an extent. I/O routines like&nbsp;<em>sscanf()</em>&nbsp;and&nbsp;<em>sprintf()</em>&nbsp;can do all sorts of things to your strings and numbers on the way in and out, think for example what â€˜%-2.10fâ€™ means in a format specifier, for instance. You can follow along with the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/routine/unpack">unpack()</a>&nbsp;documentation if you like.</p>



<p><em>pack()</em>, by contrast, just takes 8, 16, or 32-bit chunks of your input, and places them into a buffer. The â€œAâ€ in â€œA8â€ says that it wants to convert an ASCII-sized chunk of your input (â€œxd0â€ in our case) into a byte in the buffer, so our Buf now looks like ( 0xd0 ).</p>



<p>I could just as well have said â€œAAAAAAAAâ€ in order to translate all 8 characters of the buffer, but I think itâ€™s a little tidier to use the â€˜repeatâ€™ option, and say â€œA8â€ in order to convert just 8 characters (yes, yes, I know, theyâ€™re&nbsp;<strong>glyphs</strong>, but letâ€™s not confuse matters.)</p>



<p>I could write â€œA*â€ just as well, but â€œA8â€ makes sure that 8 and only 8 (the number that thou shalt count toâ€¦) characters get converted. I doubt that the header in an OLE file will change, but itâ€™s a nice bit of forward planning.</p>



<hr class="wp-block-separator" />



<p>For those of you that made it this far, thank you. As usual, gentle Reader, if you have any comments, criticisms (constructive, please) or questions, feel free to post them below.</p>



<p>Next week Iâ€™ll delve deeper into the mysteries of&nbsp;<em>pack()</em>,&nbsp;<em>unpack()</em>&nbsp;and some of the tips and tricks I use to keep on my toes and make sure that I generate clean Microsoft-compatible output.</p>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku III: The Sorceror</title>
		<link>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/</link>
					<comments>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Mon, 02 Dec 2019 12:05:55 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=60</guid>

					<description><![CDATA[Last week, we started testing, learned how to create proper Raku classes, and the basics of functions. This time weâ€™ll take a closer look at functions, arguments, and make some decisions about the API. And maybe while writing this Iâ€™ll argue myself out of a decision. Itâ€™s happened before. One good thing about writing&#160;about&#160;a module<a class="more-link" href="https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku III: The&#160;Sorceror"</span></a>]]></description>
										<content:encoded><![CDATA[
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Last week</a>, we started testing, learned how to create proper Raku classes, and the basics of functions. This time weâ€™ll take a closer look at functions, arguments, and make some decisions about the API. And maybe while writing this Iâ€™ll argue myself out of a decision. Itâ€™s happened before.</p>



<p>One good thing about writing&nbsp;<strong>about</strong>&nbsp;a module is that you can slip into a certain mindset. For instance, right now Iâ€™m thinking a few paragraphs ahead, wondering how to explain why I changed the API from Perl 5 references to regular Raku types.</p>



<p>Itâ€™s at odds with some of the principles I laid down at the start, which states that I should have minimal changes in the API from Perl to Raku. In Perl 5, you would create the â€œfilesystem rootâ€ object like so:</p>


<pre class="brush: plain; title: ; notranslate">
my $root = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);
</pre>


<p>with a bunch of references to lists. By all rights, and the principles I set up earlier, the Raku equivalent should be almost exactly the same:</p>


<pre class="brush: plain; title: ; notranslate">
my $root = OLE::Storage_Lite::PPS::Root.new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);
</pre>


<p>In fact, all I did was copy and change two characters, specifically the Perl â€˜-&gt;â€™ to the Raku â€˜.â€™ operator. Clean, and very simple. And I think what Iâ€™ll do is actually just change the code back to using the Perl reference, at least in the API. Dereferencing it will be just a few lines, and Iâ€™ll have to change it in the tests as well, but I think the pain will be worthwhile.</p>



<p>This way I donâ€™t have to field questions like â€œWhy did you end up potentially breaking old code?â€ during talks. See, speaking at conferences about your code reallyÂ <strong>can</strong>Â be a useful motivator!</p>



<h2>Iâ€™d like a formal argument, please</h2>



<p>So, I think Iâ€™ve settled on Perl-style formal references, at least for the current iteration. There are actually better ways to do this, but Iâ€™ll leave that for the proper Raku version. For right now, quick-n-dirty is the name of the game.</p>



<p>Moving on, we see an important method in the original Perl code, saving an object to disk.</p>


<pre class="brush: plain; title: ; notranslate">
sub save($$;$$) {
  my($oThis, $sFile, $bNoAs, $rhInfo) = @_;
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}
</pre>


<p>As Iâ€™ve mentioned before, OLE::Storage_Lite has been around for a long, long time. And itâ€™s obvious here. Function prototypes (<strong>not</strong>&nbsp;signatures, which are a different kettle of fish) and the use of â€˜$oThisâ€™ instead of the more conventional â€˜$selfâ€™.</p>



<h3>Being prototypical</h3>



<p>Prototypes were originally meant as a way to save you from having to write checks in your code. Theoretically, if your function was called&nbsp;<code>sub save($$)</code>&nbsp;and you tried to call it with&nbsp;<code>save($fh)</code>&nbsp;you would get an error, because the â€˜$$â€™ means the subroutine took two arguments, and you gave it just one.</p>



<p>But it also predated objects (yes, Virginia, objects in Perl havenâ€™t been around all&nbsp;<strong>that</strong>&nbsp;long.) and they could have unforeseen side effects. So they were a fad for a while, but quickly faded out of existence.</p>



<p>These days theyâ€™re a reason for a more experienced Perl hacker to take the junior aside and explain quietly why we donâ€™t use those anymore, and point them to some modern references, like&nbsp;<em><a href="http://web.archive.org/web/20200212094016/https://www.amazon.com/Modern-Perl-chromatic/dp/1680500880/ref=sr_1_1?keywords=Modern+Perl&amp;qid=1574975397&amp;s=books">Modern Perl</a></em>&nbsp;(not an affiliate link, yet.)</p>



<p>Letâ€™s at least partially convert that to Raku, like so:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs, $rhInfo) {
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}
</pre>


<p>The â€˜$oThisâ€™ means that this is a method call, so instead of writing&nbsp;<code>sub save( $oThis, ... )</code>&nbsp;we can rewrite it to a method and gain â€˜selfâ€™ instead of the arbitrary variable â€˜$oThisâ€™. Of course we do have to do a search-and-replace on â€˜$oThisâ€™ with â€˜selfâ€™, but thatâ€™s relatively simple. More complex is what to do with the â€˜;â€™ in the original prototype.</p>



<h2>Having options</h2>



<p>Itâ€™s worth pointing out that&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>&nbsp;is taken at least in part from another (larger) module,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage">OLE::Storage</a>. This means that the internal code is redundant in a few places. Raku would let us rewrite what we have as:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs, $rhInfo = {}) {
  #0.Initial Setting for saving
  # ..
}
</pre>


<p>making&nbsp;<em>$rhInfo</em>&nbsp;an optional variable with a default value. Now, this is a pretty common pattern for a recursive method, so I did a bit of digging. Namely I grepâ€™ed for â€˜saveâ€™ in the original (all-in-one)&nbsp;<em>Storage_Lite.pm</em>&nbsp;module, and found no recursive calls to it.</p>



<h2>Debugging both sides now</h2>



<p>This is also where the test suite I wrote earlier comes in handy, as it actually exercises the â€˜saveâ€™ method. So I added a quick debugging message&nbsp;<code>warn "Saving $rhInfo";</code>&nbsp;to my local copy of the code, and ran the test suite. Seeing just one â€˜Saving â€¦â€™ message in my test output convinced me it wasnâ€™t recursive. So now the code just looks like:</p>


<pre class="brush: plain; title: ; notranslate">
method save($sFile, $bNoAs) {
  #0.Initial Setting for saving
  my %hInfo;
  # ..
}
</pre>


<p>Also, since&nbsp;<em>$rhInfo</em>&nbsp;is created in this method, thereâ€™s no reason to leave it as a reference. So the initial â€˜râ€™ goes away, and we have left just â€˜%hInfoâ€™. It may get passed in to other methods, but Raku lets us pass hashes and arrays as ordinary variable types, so Iâ€™ll take advantage of that.</p>



<p>To be fair, leaving it as a reference would have saved me a bit of typing, but Iâ€™d already kind of decided that at least internally Iâ€™d try to use Raku types and calling conventions, and that left me with the choice of how to pass variables around.</p>



<h3>Having options</h3>



<p>Finally, thereâ€™s the question of what to do with the semicolon. Remember at the start, the function prototype was â€˜($$;$$)â€™ which meant&nbsp;<em>$oThis</em>&nbsp;and&nbsp;<em>$sFile</em>&nbsp;were before the semicolon, and&nbsp;<em>$bData</em>&nbsp;and&nbsp;<em>$rhInfo</em>&nbsp;were after. I can now reveal that â€˜;â€™ in a Perl prototype means that whatever appears afterward is optional.</p>



<p>True to Rakuâ€™s nature, I can account for this in at least two ways. One way would be to decide that&nbsp;<em>$bData</em>&nbsp;is always there and just has a default value, probably 0. That would look like&nbsp;<code>method save( $sFile, $bData = 0 )</code>. But the documentation puts&nbsp;<em>$bData</em>&nbsp;in square brackets, indicating that itâ€™s optional.</p>



<p>Raku has an alternate syntax to indicate if a variable is optional, which looks like&nbsp;<code>method save( $sFile, $bData? )</code>. I think this method is better than the alternative syntax because it states clearly that&nbsp;<em>$bData</em>&nbsp;is optional. Both methods work, I just happen to like the â€˜?â€™ modifier.</p>



<h2>Waiting for Huffman</h2>



<p>Moving on, we have this wonderful line of code:</p>


<pre class="brush: plain; title: ; notranslate">
$rhInfo-&gt;{_BIG_BLOCK_SIZE}  = 2**
              (($rhInfo-&gt;{_BIG_BLOCK_SIZE})?
                  _adjust2($rhInfo-&gt;{_BIG_BLOCK_SIZE})  : 9);
</pre>


<p>When I was translating this initially, I was in something of a drone mindset, not truly thinking about what I was doing. Iâ€™d copied the&nbsp;<em>$rhInfo</em>&nbsp;variable into the method signature and just kept on writing. I ended up with a statement that I eventually shortened quite a bit.</p>


<pre class="brush: plain; title: ; notranslate">
$rhInfo.&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );
</pre>


<p>The â€˜.â€™ after&nbsp;<em>$rhInfo</em>&nbsp;indicates weâ€™re dealing with a reference, and the &lt;..&gt; notation is now how barewords look inside hashes. The old {_BIG_BLOCK_SIZE} is still there, but itâ€™s pronounced {â€˜_BIG_BLOCK_SIZEâ€™}. A lot of people use the {â€˜..â€™} in Perl already so itâ€™s not a big change, and it actually simplifies the backend enormously.</p>



<p>Also, at the start Larry and Damian pulled statistics on Perl code from CPAN and other repositories. They were looking for operator frequencies, among other things. Frequently used operators like&nbsp;<em>qw()</em>&nbsp;and&nbsp;<em>-&gt;</em>&nbsp;got even shorter in Raku.</p>



<p>Others, like the ternary operator, werenâ€™t so lucky. It got longer, and stretched to â€˜?? .. !!â€™. So this is one place where the code will look a little funky. Maybe one day Iâ€™ll write a slang to fix it, but back to work.</p>



<h2>Trimming the verge</h2>



<p>Earlier I mentioned that this module was trimmed down from a much larger full OLE reader/writer. This was the first place that became evident. Since&nbsp;<em>$rhInfo</em>&nbsp;is now called&nbsp;<em>%hInfo</em>&nbsp;and initialized&nbsp;<strong>inside</strong>&nbsp;the method, this statement deserves to be looked at a little closer.</p>


<pre class="brush: plain; title: ; notranslate">
my %hInfo;
%hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );
</pre>


<p>After replacing&nbsp;<em>$rhInfo</em>&nbsp;with&nbsp;<em>%hInfo</em>&nbsp;this is what I got. But since&nbsp;<em>%hInfo</em>&nbsp;is defined just above, the test&nbsp;<code>%hInfo&lt;_BIG_BLOCK_SIZE&gt;</code><em>&nbsp;</em>will never be true, so this entire block can be reduced to:</p>


<pre class="brush: plain; title: ; notranslate">
my %hInfo = _BIG_BLOCK_SIZE =&gt; 2**9;
</pre>


<p>While Iâ€™m here Iâ€™ll delete&nbsp;<em>_adjust2()</em>. No code pathway uses it, so out it goes. Iâ€™ll restore it if I have to, but right now I want the test scripts to pass, and thatâ€™s it. Iâ€™ve got the original source, and a map from Perl to Raku, and thatâ€™s all I need.</p>



<h2>Culling yaks from the herd</h2>



<p>Where thereâ€™s smoke thereâ€™s fire, so I stop what Iâ€™m doing and grep out every â€˜sub Xâ€™ call in the source, putting it in a scratch monkey. Then I go through the source (which I have below the new Raku source, deleting lines as I go) and look for methods that arenâ€™t used, like&nbsp;<em>adjust2()</em>. I delete each of these methods with&nbsp;<strong>extreme</strong>&nbsp;prejudice, because each line of code I donâ€™t see is one I donâ€™t have to translate.</p>



<p>Checkpoint in git, and now itâ€™s time for a lunch break. Afterwards, Iâ€™m getting into the&nbsp;<em>save()</em>method, and see what looks like a new yak to shave. Or a package to translate, to be precise.</p>


<pre class="brush: plain; title: ; notranslate">
  if(ref($sFile) eq 'SCALAR') {
    require IO::Scalar;
    my $oIo = new IO::Scalar $sFile, O_WRONLY;
    $rhInfo-&gt;{_FILEH_} = $oIo;
    # ...
}
</pre>


<p>In both Raku and Perl, you can create a single method called&nbsp;<code>new( $sFile )</code>&nbsp;that treats&nbsp;<em>$sFile</em>&nbsp;as either a filename (scalar), file content (scalar reference) or file handle (scalar object.) In Perl, if we wanted to handle filenames, file contents, or file handles differently, weâ€™d have to switch like this, or have different method names.</p>



<p>In Raku, we can handle this differently. In fact I can write the code to save() to a filename, and add save() to a filehandle later with no modifications needed. Above, I briefly touched on the fact that you can write more than one&nbsp;<em>new()</em>&nbsp;method, as long as the two method signatures were distinct.</p>


<pre class="brush: plain; title: ; notranslate">
multi method save( Str $filename ) {...}
multi method save( IO::Handle $fh ) {...}
</pre>


<p>Raku will let you write two methods called&nbsp;<em>save()</em>, as long as it can tell which one to call at runtime. So, I can call&nbsp;<code>$root.save( '/tmp/test.xlsx' );</code>&nbsp;or&nbsp;<code>$root.save( $out_filehandle );</code>&nbsp;and Raku will â€œdispatchâ€ it to the right&nbsp;<em>save()</em>&nbsp;method automatically.</p>



<p>We call it â€˜multiple dispatchâ€™ for just that reason, dispatching a function call to multiple versions of a method. And this means that I can write the first&nbsp;<em>save( Str $filename )</em>&nbsp;method without worrying about the other methods. I donâ€™t have to add a new if-then branch to the existing code, or modify&nbsp;<em>save()</em>&nbsp;in any way.</p>



<p>I can just write my&nbsp;<em>save()</em>&nbsp;method and ignore the other IO:: types. Also, if someone gets my code later and wants to add a&nbsp;<em>save()</em>&nbsp;method that saves to something I know nothing about, they can write their new&nbsp;<em>save()</em>&nbsp;method without interfering with mine.</p>



<p>In this installment weâ€™ve covered the basics of function and method calls, delved into the ternary operator, removed dead code and learned a little about multiple dispatch. Next time, weâ€™ll open the binary filehandle we created above and delve into the mysteries of&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>.</p>



<p>Iâ€™ll also show you a new (yes, I couldnâ€™t resist) grammar-based version of pack() that should cover the entire Perl gamut of packed types, with a bit of patience and a large enough test suite.</p>



<p>As always, gentle Reader, thank you for your time and attention. If you have any (constructive, please) comments, criticisms or questions, please let me know in the comment section below.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/</link>
					<comments>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 24 Nov 2019 12:07:18 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=63</guid>

					<description><![CDATA[Picking up from&#160;Part One, weâ€™d just finished up rewriting a Perl script into the test suite for the Raku translation of&#160;OLE::Storage_Lite. Raku programming is made easier by having lots of tools, but Microsoft documents arenâ€™t yet well-represented in the Raku ecosystem. Being able to read/write OLE allows us to create a whole range of Microsoft<a class="more-link" href="https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for Raku II: Electric&#160;Boogaloo"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Picking up from&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Part One</a>, weâ€™d just finished up rewriting a Perl script into the test suite for the Raku translation of&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>. Raku programming is made easier by having lots of tools, but Microsoft documents arenâ€™t yet well-represented in the Raku ecosystem.</p>



<p>Being able to read/write OLE allows us to create a whole range of Microsoft documents (at least where theyâ€™re documented.) Because of its day-to-day use, weâ€™re focusing on Excel here. Many businesses still rely on Excel for their day-to-day task management, time tracking and home-grown processes.</p>



<p>Iâ€™ve been known to wax philosophical about this after a few Westmalle Tripels at various conferences. Now is the time for doing something about it. Hereâ€™s what our burgeoning test suite looked like, at least in part. The current code is in&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>&nbsp;over on github.com. Iâ€™ve gotten rid of most of the Perl 5 test skeleton, but the essence remains.</p>


<pre class="brush: plain; title: ; notranslate">
use v6;
use Test;
use OLE::Storage_Lite;

plan 1;

my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
subtest 'Root', {
  isa-ok $oDt, 'OLE::Storage_Lite::PPS::Root';
  is $oDt.Name, 'Root Entry';
  is-deeply $oDt.Time2nd, [ 0, 0, 16, 4, 10, 100 ];
  # ...
};
done-testing;
</pre>


<p>Originally there really werenâ€™t any Perl 5 tests for this module. Iâ€™m sure the original author treated the entire module as a black box, and they were happy to be able to run&nbsp;<em>samples/smpsv.pl</em>, open the new test.xls in Excel, and when it actually read the file, treat that as â€˜ok 1â€™, push it to CPAN and call it a day.</p>



<h2>Testing, testing</h2>



<p>Thatâ€™s wonderful, and I may eventually adopt that methodology. For the moment, the lack of a test suite leaves me a bit unsatisfied. I suppose I could treat the entire module as a black box and fix the translated version line-by-line as I go through it. Iâ€™ll have to do that eventually (spoiler alert: Thatâ€™s actually where I am â€“ Iâ€™m writing these pieces a bit after the fact.)</p>



<p>That leaves me with the question of what to test, and what the quickest way to get there is. The individual Directory, Root and File objects are exposed to the user, and are part of the public API. So it makes some sense to create an object, look at the internals, and do my best to match that in Raku.</p>



<h2>I Think Iâ€™m A Clone Now</h2>



<p>Thereâ€™s always two [implementations] of me standing aroundâ€¦ I donâ€™t want to get sidetracked by reading the entire OLE spec. I might start to realize what a huge job this really is, and abandon ship. So, Iâ€™m going to limit myself to the following:</p>



<p>Create a narrowly defined 1:1 clone of the exact source of OLE::Storage_Lite in Perl 5. The objects will act exactly like the Perl 5 version, as will the API. This way I donâ€™t have to think about what the API should do, how it should look in Raku, how the objects get laid out, anything fancy. All I need to worry about is:</p>



<ol><li>When I write&nbsp;<code>warn $oDt.raku</code>, does the output look the same as&nbsp;<code>use YAML; warn Dump($oDt);</code>&nbsp;in Perl 5?</li><li>When I write the final file to disk, does the Raku code output exactly the same file as the original Perl 5 version?</li></ol>



<p>Thatâ€™s it. It takes away a lot of possibilities, but it lets me focus on getting the job done, not how things should look. Being able to test how the individual objects look will tell me that the read API works and saves enough data to be able to reconstruct the object in memory.</p>



<p>Conversely, being able to match the binary output tells me that the write API works, so Iâ€™ve effectively tested as much as the original module did. Plus I can automate some of the process, especially on the read side.</p>



<h2>Lost in Translation</h2>



<p>You can check out the current source at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>, and follow along with some of the changes Iâ€™ve made. I also made sure to keep a working copy of the original&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>Perl 5 module around. My Raku tree right now is very close to Perl 5.</p>



<p>I can insert a debug statement like&nbsp;<code>die "[$iBlockNo] [$sData]\n"</code>&nbsp;in the Perl 5 code, go to the equivalent line in Raku, and expect that when I run the two test suites, that theyâ€™ll die in exactly the same way.</p>



<p>This way when they&nbsp;<strong>donâ€™t</strong>, I can immediately narrow down the problem simply by moving the â€˜dieâ€™ statements up in the code until they return the same values. The line immediately below the â€˜dieâ€™ statement will be the culprit.</p>



<h3>The Nitty Gritty Perl Band</h3>



<p>Iâ€™ll mention one thing in passing â€“ the original Perl 5 source code is in a single file containing all of the packages. Thatâ€™s not Raku style, so Iâ€™ve unpacked it into lib/OLE/Storage_Lite/* following the usual style of one Perl 5 class â€“ one file.</p>



<p>So, time to get our hands dirty. The new Raku module wonâ€™t compile for quite a while, so weâ€™d better put this into git. Iâ€™m also using&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.raku.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do my development and eventual push to CPAN, so all of that boilerplate is there too.</p>



<p>So, cue the montage scene of the dedicated Raku hacker pounding away at the keyboard, with the occasional break for food and/or adult beverage. Looking over her shoulder, we see a familiar split-screen view, with Perl 5 code on top, and a new Raku file below.</p>


<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
package OLE::Storage_Lite::PPS::Root;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS);
</pre>

<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root is OLE::Storage_Lite::PPS;
</pre>


<p>Raku has classes where Perl 5 has packages. The â€˜unitâ€™ declaration there says that the class declaration takes up the remainder of the file. This is sort of how Perl 5 does it, but gets rid of the â€˜1;â€™ at the end of your package declaration.</p>



<p>Itâ€™s also useful for another reason Iâ€™m not going to show. Namely that the Perl 5 code is directly below the Raku code, commented out. Iâ€™m flipping between vim windows to delete lines as I translate them by hand. So the â€˜unit classâ€™ declaration helps in case I accidentally un-comment Perl 5 code â€“ Iâ€™ll get big honkinâ€™ warnings when I run the test suite.</p>



<h3>Moosey-ears!</h3>



<p>(for those of you that remember the moduleâ€™s release)</p>



<p>Raku borrowed liberally from Perl 5â€™s Moose OO metamodel, to the point where using Raku will feel very similar. Just drop a few bits of syntactic sugar that Moose needed to work under Perl, and itâ€™ll feel the same.</p>



<p>In this case the â€˜isâ€™ does the same job as in Moose, to introduce a parent class. Raku doesnâ€™t need the sugar that Moose sweetens your code with, so you can just say your class â€˜isâ€™ a subclass of any other class.</p>



<p>Letâ€™s keep rolling along here, with the next lines of the Perl 5 library:</p>


<pre class="brush: plain; title: ; notranslate">
require Exporter;
use strict;
use IO::File;
use IO::Handle;
use Fcntl;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS Exporter);
$VERSION = '0.19';
sub _savePpsSetPnt($$$);
sub _savePpsSetPnt2($$$);
</pre>

<pre class="brush: plain; title: ; notranslate">
use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root:ver&lt;0.19&gt; is OLE::Storage_Lite::PPS;
</pre>


<p>Moving alongâ€¦ Okay, ya caught me, â€˜:ver&lt;0.19&gt;â€™ is something new that we should add. Versions are now integrated into classes, so you can check them and even instantiate based on version number.</p>



<p>The module actually doesnâ€™t export anything, so we donâ€™t need Exporter at all. Raku enables â€˜strictâ€™ automatically, has IO modules in core, and doesnâ€t need Fcntl. The forward declarations arenâ€™t needed for Raku, so all thatâ€™s left is the moduleâ€™s version number, which gets added to the class name. You can add other attributes, too.</p>



<h2>Making things functional</h2>



<p>To keep things simple for me writing the code, and me having to read the code weeks, months or years later, I want as close to a 1:1 relation between Perl 5 and Raku as I can. Another place where this requires an accommodation (but not much of one) is just a few lines down, writing the creation method â€˜newâ€™.</p>


<pre class="brush: plain; title: ; notranslate">
sub new ($;$$$) {
    my($sClass, $raTime1st, $raTime2nd, $raChild) = @_;
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    );
}
</pre>


<p>By this point youâ€™ll probably see more of why I say this module is a hard worker. Itâ€™s been around a long time, and function prototypes like this are one easy way to tell. Letâ€™s rewrite it in a more modern Perl 5 style before making the jump to Raku, with function signatures.</p>


<pre class="brush: plain; title: ; notranslate">
sub new($sClass, $raTime1st, $raTime2nd, $raChild) {
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    )
}

</pre>


<p>Just drop the old function prototype, and replace it with the variables we need to populate. Well, almost. If you know what a subroutine prototype is, you might think Iâ€™m pulling a fast one on you. And youâ€™d be right. Look back at the original Perl 5 code, and youâ€™ll see â€˜($;$$$)â€™ is the prototype.</p>



<p>The â€˜;â€™ separates required variables from optional variables, and we havenâ€™t accounted for that in our Perl 5 code. Since Iâ€™m not here to modernize Perl 5 code but convert it to Raku, Iâ€™m going to ignore that in Perl 5 and go straight to Raku.</p>


<pre class="brush: plain; title: ; notranslate">
multi method new( @aTime1st?, @aTime2nd?, @aChild? ) {
  self.bless(
    Time1st =&gt; @aTime1st,
    Time2nd =&gt; @aTime2nd,
    Child =&gt; @aChild
  );
}
</pre>


<h2>Under Construction</h2>



<p>And there we are. Now, thereâ€™s quite a bit to take in, so Iâ€™ll take things slow. The first thing youâ€™ll notice is the keyword â€˜multiâ€™. In Perl 5, you get to hand-roll your own constructors, so you can make them any way you like. In this case, the author chose to write&nbsp;<code>new($raTime1st, $raTime2nd, $raChild)</code>, which is pretty common.</p>



<p>Raku gives me a default â€˜newâ€™ method, so I only need to hand-roll constructors when I want. Since I want to keep as close as reasonable to the original API, Iâ€™ll write a constructor that takes 3 arguments too. In my case I chose to simplify things just a bit here.</p>



<p>Iâ€™ve found over several years of writing Raku code that I rarely use references. In Perl 5 they were pretty much the&nbsp;<strong>only</strong>&nbsp;way to pass arrays or hashes into a function, because of its propensity to â€œflattenâ€ arguments.</p>



<p>In Raku, you can still use the Perl 5 style, but formal argument lists are the way to go in my opinion. If you need to pass both an array and a hash to a Raku function, go for it. I encourage that in my tutorial courses, and recommend it to help break students out of their Perl 5 mindset.</p>



<p>This is not to say that thereâ€™s anything wrong with Perl 5â€™s argument list, in fact theyâ€™ve taken some ideas from Raku for formal argument lists, and I encourage that. Cross-pollination of ideas should be encouraged, itâ€™s how both languages grow and add new features.</p>



<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Last week</a>&nbsp;was about the overall module, this week we delved a bit into the OO workings. Next week weâ€™ll talk about references, attributes, and maybe progressive typing.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Rewriting Perl Code for Raku</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/</link>
					<comments>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Sun, 24 Nov 2019 12:00:00 +0000</pubDate>
				<category><![CDATA[Perl programming]]></category>
		<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=66</guid>

					<description><![CDATA[This time around weâ€™re going to talk about how to rewrite Perl code in Raku. Even in 2019, a lot of the office world revolves around spreadsheets, whether they be Excel,&#160;LibreOffice&#160;or simple .csv files. Perl 5 has a plethora of modules to do this, a quick search for â€˜Spreadsheetâ€™ on&#160;MetaCPANshould convince you of that. The<a class="more-link" href="https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/">Continue reading <span class="screen-reader-text">"Rewriting Perl Code for&#160;Raku"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>This time around weâ€™re going to talk about how to rewrite Perl code in Raku. Even in 2019, a lot of the office world revolves around spreadsheets, whether they be Excel,&nbsp;<a href="http://web.archive.org/web/20200212094016/http://libreoffice.org/">LibreOffice</a>&nbsp;or simple .csv files. Perl 5 has a plethora of modules to do this, a quick search for â€˜Spreadsheetâ€™ on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/">MetaCPAN</a>should convince you of that.</p>



<p>The Raku world doesnâ€™t have quite as many modules as youâ€™d expect, though. While itâ€™s been around for a few years, â€œheavy liftingâ€ modules like Spreadsheet stuff really havenâ€™t come around yet. This involves packing and unpacking binary formats, and in Perl 5 this centered around the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins, which are relative newcomers to Raku.</p>



<p>But Raku has built-in binary buffers, which take care of most of the need for pack/unpack. The main reason I can see is the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.microsoft.com/interop/docs/supportingtechnologies.mspx">OLE</a>&nbsp;storage format. Basically itâ€™s Microsoftâ€™s way of packing a file system into a single data file. And at this point the proverbial yaks start to pile up, and reasonable people say â€œYou know, Excel still accepts .csv files, I know how to build those.â€</p>



<p>Enter<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">&nbsp;raku-OLE-Storage_Lite</a>&nbsp;â€“ this is my translation-in-progress from Perl 5 to Raku. As of this writing it can read an entire OLE file (without data) and write a good portion of the sample file â€“ I believe Iâ€™ve got maybe two methods left to debug.</p>



<h2>Knee deep in yaks</h2>



<p>CSV files are easy to write, but they come with their own set of troubles. When you import a .csv file into your Excel app (or LibreOffice, or whatever) youâ€™re faced with a complex dialog asking you how to import your data, and the average user doesnâ€™t want that every time, they just want to open their spreadsheet.</p>



<p>So, itâ€™s time to follow Lizâ€™s lead and rewrite in Raku an existing module. First thing I did was go to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/Spreadsheet::ParseExcel">Spreadsheet::ParseExcel</a>&nbsp;and see how they did things. Within a few minutes Iâ€™d already encountered the first yak. After opening the file, it delegates it to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>, which is much like&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.jamesbrown.com/">James Brown</a>, the â€œhardest-working man in show businessâ€.</p>



<p>Itâ€™s still on version 0.19 at the time of writing, but I assure you thatâ€™s only because the current maintainer hasnâ€™t updated the version to reflect reality. It may be legacy Perl rough-and-tumble code, but itâ€™s been around for a long time. It wears its battle scars proudly.</p>



<p>It relies heavily on&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>, which are still&nbsp;<strong>technically</strong>&nbsp;experimental in Raku. The OO and coding style betrays its pre-5.00 origins, and the tests are, well, very pragmatic. â€œDoes it load? Great! Can it convert timestamps internally? Great! Ship it!â€</p>



<p>To its credit, thereâ€™s a sample directory where you can use&nbsp;<em>smpview.pl</em>&nbsp;to view the contents of the internal filesystem of any OLE file, and a sample writer to create a known-working OLE file. Thatâ€™ll do as a starting point.</p>



<h3>Buckling down</h3>



<p>So, reading an Excel spreadsheet means reading an OLE file system. And when I say file system, Iâ€™m not kidding. Inside your typical .xlsx file, thereâ€™s a small header and a root object. The root object contains â€œpointersâ€ (really file offsets) to a document object, and inside that are file objects, each with pointers to the different blocks.</p>



<p>This is all intended to reflect the original disk layout, so it looks very much like an NTFS superblock and block layout. The documentation seems to have moved to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-oleds/fdc5e702-d09e-4344-a77f-eb079d41f23f">this</a>&nbsp;page detailing OLE 1.0 and 2.0 formats, Iâ€™m not at all certain what the current version has.</p>



<p>How are Excel spreadsheets arranged in here? Worksheets are OLE directories, and inside each worksheet, tabs are individual files. Howâ€™s that for a bit of inspiration? Luckily the Root directory, Files and nested Directories are all separate objects, with at least a few common methods aggregated into a superclass.</p>



<h2>Legacy Code</h2>



<p>This is a long-winded way of saying the module in question is very much legacy code. And, as I want to bring it into the proverbial light, Iâ€™ve got to give some issues some thought.</p>



<ol><li>No useful tests, so Iâ€™ll have to write those.</li><li>How much code do I want to sacrifice?</li><li>How much can I save?</li></ol>



<p>Well, I can put off #2 and #3 while writing some tests. Whoa, wait a minute. I donâ€™t have a test file to work with, just some scripts over in sample/. Mumble, mumble, more yaks. Read README, find that smpsv.pl will create one, run that.</p>



<p>Great, Iâ€™ve got a sample test.xsl file. But given the amount of potential bit-rot it seems prudent to actually make sure that Iâ€™ve got a working Excel file before committing a few days (ha!) to getting a module working. Double-click it, launch into Excelâ€™s cloud-serviced app, find that itâ€™s one of those Win10 panes Iâ€™ve never figured out how to close, open task-killer, kill that.</p>



<p>Launch&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.libreoffice.org/">LibreOffice</a>&nbsp;which I happen to have lying around â€“ my current project at work is parsing a spreadsheet in Perl 5, which is what inspired this whole workload.</p>



<p>Yep, that parses; looks a bit odd because itâ€™s coming up with a Japanese font, and some arbitrary English text, but it works. Also, looking at the code it generates all three object types â€“ Root, File and Dir, so itâ€™ll exercise the major code paths. Bonus.</p>



<h2>Testing, testing</h2>



<p>Now Iâ€™ve got the makings of a simple test file. The script builds objects individually, so I can run the individual calls, and check that the objectâ€™s internals look the way I want.</p>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ ],
  [ 0, 0, 16, 4, 10, 100 ], # 2000/11/4 16:00:00:0000
  [ $oWk, $oDir ]
);
</pre>


<p>In Raku, this converts to:</p>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
</pre>


<p>Iâ€™ve made one change already, to make things simpler for Raku users. In Perl, you have to pass lists as references unless you want to use the new function signatures. In Raku, you can just pass lists as you would ordinarily to your method call.</p>



<p>Using native data types rather than passing references around may seem a bit odd at first to new Raku programmers, but the new variable classes are easier to enforce strong typing on later, when you get used to the language.</p>



<h3>Going with the flow</h3>



<p>Now weâ€™ve got something we can test, namely making sure that weâ€™ve got a valid OLE Root document. So, before we go ahead with the code, Iâ€™ll share a few little things. I know very little about this code, so I want to make sure that I&nbsp;<strong>intimately</strong>&nbsp;copy each detail of the object at this stage. Later on I might get fancy and replace things with their own object types, but for now, my goal is going to be 1:1 replication.</p>



<p>I tend to like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/tmux/tmux/wiki">tmux</a>&nbsp;as a shell environment, havenâ€™t really gotten along with UIs. So, keeping in mind that I wanted an absolute 1:1 copy of the original object, I ended up doing this:</p>



<ol><li>Switch to new window, open my copy of â€˜samples/smpsv.plâ€™ in vim</li><li>Add â€˜use YAML; die Dump( $oDt ) just below the line where it gets created</li><li>Switch to new window, run the sample script, copy the YAML output</li><li>Close the two new windows I created to keep clutter down</li><li>Paste the YAML code into the new Raku test.</li></ol>


<pre class="brush: plain; title: ; notranslate">
my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
--
  Name: "R\0o\0o\0t\0 \0E\0n\0t\0r\0y\0"
  No: ~
  Time2nd:
    - 0
    - 0
    - 16
    - 4
    - 10
    - 100
# and so on...
</pre>


<p>This should contain all I need to create an OLE file from this set of objects. Iâ€™m using this as a sneaky way of not reading the spec, at least not yet. As the old title goes: Algorithm + Data Structure = Program. Using YAML (or Data::Dumper) gives me the data structure, copying the Perl 5 code into Raku gives me the algorithm.</p>



<p>I should almost be able to keep line-for-line fidelity, so when a patch is posted to the Perl 5 source I can import it into Raku without too much trouble. But once Iâ€™ve got a better test base and a few users in Raku Iâ€™ll probably rewrite this whole module in a more Raku-ready fashion. I can keep the old module around for reference.</p>



<h2>Encoding worries</h2>



<p>But weâ€™ve also got a surprise lurking here. â€œR\0o\0ot\0 \0E\0n\0t\0r\0y\0â€ looks like binary garbage, but is actually UCS-2, I think. If it is, then the OLE file is limited to a subset of Unicode. I can put restrictions on it later if I have to, but ATM I actually donâ€™t care.</p>



<p>Iâ€™ve done enough time in the i18n salt mines that I know how to deal with this. Store the string in the best format possible (UTF-8 here) internally. When the time comes to write it to the network or disk, translate it to the final encoding.</p>



<p>This way I can see what all the attributes are at a glance without changing encoding. I can also manipulate everything using regular Raku code until the last moment. If I have to, I can use Rakuâ€™s gradual typing to constrain the string. More importantly, I donâ€™t have to do any of this&nbsp;<strong>now</strong>.</p>



<h2>Got any change?</h2>



<p>This means Iâ€™m going to change things just a little bit more. When data gets added to â€˜Nameâ€™ Iâ€™m going to assume itâ€™s UTF-8. Since Iâ€™m not doing any I/O yet, I can make whatever assumptions I want. Keeping the internals simple keeps my life simple, at least.</p>



<p>So Iâ€™ll write out a quick&nbsp;<em>is-deeply</em>&nbsp;test and get on with things:</p>


<pre class="brush: plain; title: ; notranslate">
is-deeply $oDt, (
  Name =&gt; 'Root Entry',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
  Child =&gt; ( $oWk, $oDir )
);
</pre>


<p>This looks pretty straightforward, and almost how youâ€™d write the original test in Perl 5. It wonâ€™t&nbsp;<strong>run</strong>&nbsp;yet, but thatâ€™s something weâ€™ll tackle in the next part in the series.</p>



<p>Iâ€™m not done quite yet, because Iâ€™ve got a lot of these things to write, and not all of them may have the â€˜Childâ€™ attribute. I could write a tiny method that skipped over the â€˜Childâ€™ attribute along with anything else I wanted, but that felt clumsy. It looked like:</p>


<pre class="brush: plain; title: ; notranslate">
ok sorta-deeply $oDt, (
  Name =&gt; 'Root Window',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
), ( 'Child' );
</pre>


<p>And notice that&nbsp;<em>sorta-deeply</em>&nbsp;is a function that does all the work, then passes a simple Bool back to the test. Iâ€™d end up writing all of the code that&nbsp;<em>is-deeply</em>&nbsp;does (except for the recursion), and get something back thatâ€™s less useful.</p>



<p>Next time weâ€™ll get into making these tests pass. Iâ€™m writing the next section right after this, but you wonâ€™t get to see it for another week or so, Iâ€™m afraid. If you have questions or comments about the first part of this series, please feel free to comment below.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Templates II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/</link>
					<comments>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Thu, 08 Aug 2019 11:09:35 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=69</guid>

					<description><![CDATA[Last time&#160;on this adventure writing the&#160;Template Toolkit&#160;language in Raku, weâ€™d just created a small test suite that encompasses some of the problems weâ€™re going to encounter. Itâ€™s no use without a grammar and a&#160;bunch&#160;of other parts, but it does give us an idea of what itâ€™s going to look like. The list here is what<a class="more-link" href="https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/">Continue reading <span class="screen-reader-text">"Templates II: Electric&#160;Boogaloo"</span></a>]]></description>
										<content:encoded><![CDATA[
<p><a href="http://web.archive.org/web/20200212094016/http://theperlfisher.com/index.php/2019/07/18/templates-and-a-clean-start/">Last time</a>&nbsp;on this adventure writing the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>&nbsp;language in Raku, weâ€™d just created a small test suite that encompasses some of the problems weâ€™re going to encounter. Itâ€™s no use without a grammar and a&nbsp;<strong>bunch</strong>&nbsp;of other parts, but it does give us an idea of what itâ€™s going to look like.</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit::Grammar;
use Template::Toolkit::Actions;

# ... similar lines above this
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
# ... and similar lines below this.
</pre>


<p>The list here is what weâ€™re going to return to&nbsp;<em>render()</em>, and Iâ€™d love to make that as simple as it can be without being&nbsp;<strong>too</strong>&nbsp;simple. Letâ€™s focus for the moment just on one bit of the test suite here, the array Iâ€™m getting back.</p>


<pre class="brush: plain; title: ; notranslate">
[ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
</pre>


<p>If these elements were&nbsp;<strong>all</strong>&nbsp;strings, then all&nbsp;<strong>render()</strong>&nbsp;would have to do is join the strings together, simples!</p>


<pre class="brush: plain; title: ; notranslate">
method render( Str $text ) returns Str {
  my @terms = # magic to turn text into array of terms
  @terms.join: '';
}
</pre>


<p>Letâ€™s create the â€˜Directiveâ€™ class and see what happens, though.</p>


<pre class="brush: plain; title: ; notranslate">
class Directive { has $.content }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: '';
# aaDirective&lt;94444485232315&gt;a
</pre>


<p>Whoops, thatâ€™s not what we want. Not&nbsp;<strong>bad</strong>&nbsp;exactly, but not what we want, either. Well, not to fear. Remember that in Template Toolkit, directives will always return a string. It may be an&nbsp;<strong>empty</strong>string, but theyâ€™ll always return some kind of string.</p>



<p>As a side note, this may not always be true â€“ some directives will even tell the renderer to stop parsing entirely. But itâ€™s a pretty solid starting assumption. For instance, we could say that encountering the STOP directive just makes all future directives return â€.</p>



<p>Of course, Iâ€™m harping on the term â€˜stringâ€™ for a reason. Internally, everything is an object, and every object has a method that returns a readable value. Our Directive class didnâ€™t specify one, so we get the default that returns â€˜$name&lt;$address&gt;â€™.</p>



<p>So, letâ€™s supply our own method.</p>


<pre class="brush: plain; title: ; notranslate">
class Directive { has $.content; method Str { $.content } }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: ', ';
# a, a, name, a
</pre>


<p>There. If we supply a .Str method we can make Directives do what we want. INCLUDE directives would open the file, slurp the contents and return them. Argument directives would take their argument name, look up the value, and return that. Or, more likely, would have a context object passed that does the lookup for them.</p>



<h2>Where do we go from here?</h2>



<p>Next time weâ€™ll convince Grammars and Actions to work together, making processing a template as simple as:</p>


<pre class="brush: plain; title: ; notranslate">
parse-template( $text ).join( '' );
</pre>


<p>Next in this series on writing your own template language using Raku, you should be able to define your own Template Toolkit directives and have them return the pre-processed text. Weâ€™ll add support for context and the ability to do simple â€˜[% name %]â€™ tags, and maybe explore how to change â€˜[%â€™..â€™%]â€™ tags on-the-fly.</p>



<p>Thank you again, dear reader, for your interest, comments and critiques.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>A Regex amuse-bouche</title>
		<link>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/</link>
					<comments>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Wed, 24 Jul 2019 11:10:22 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=72</guid>

					<description><![CDATA[Before continuing with the Template series, I thought Iâ€™d talk briefly about an interesting (well, at least to me) solution to a little problem. System and user libraries (the kind that end in .so or .a, not Perl libraries) have a section at the top that maps a function name (â€˜load_userâ€™ or whatever) to an<a class="more-link" href="https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/">Continue reading <span class="screen-reader-text">"A Regex amuse-bouche"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Before continuing with the Template series, I thought Iâ€™d talk briefly about an interesting (well, at least to me) solution to a little problem. System and user libraries (the kind that end in .so or .a, not Perl libraries) have a section at the top that maps a function name (â€˜load_userâ€™ or whatever) to an offset into the library, say, 0x193a.</p>



<p>This arrangement worked fine for many years for C, Algol, FORTRAN and most other languages out there. But then along came languages that upset the apple cart, like C++ and Smalltalk, where a programmer could write two â€˜load_userâ€™ functions, call â€˜load_user(1234)â€™ or â€˜load_user(â€œSmith, Johnâ€)â€™ and expect the linker to load the right version of â€˜load_user.â€™</p>



<p>The problem here is that the library, the linker and all of the other programs in the tool chain expect there to only be one function called â€˜load_userâ€™ in any given library.</p>



<p>Those of us that do Perl 5 and Raku programming donâ€™t have to worry about this, but if you ever want to link to a C++ library, you probably should know at least a bit about â€œname mangling.â€</p>



<p>For a while, utilities like â€˜CFrontâ€™ for the Macintosh (which the author actually filed bug reports on) were used to â€œrenameâ€ functions like â€˜load_user(int)â€™ and â€˜load_user(char*)â€™ to â€˜i_load_userâ€™ and â€˜cs_load_userâ€™ before being added to the library, and other tools to do the reverse.</p>



<h2>Has Your Mother Sold Her Mangle?</h2>



<p>Eventually things settled down, and this process of changing names to fit into the library was â€œbaked inâ€ to the tool chains. Not consistently, of course, couldnâ€™t have that. But conventions arose and even today&nbsp;<a href="http://web.archive.org/web/20200212094016/https://en.wikipedia.org/wiki/Name_mangling">Wikipedia</a>&nbsp;lists at least 12 different ways to â€œmangleâ€ â€˜void h(void)â€™ into the existing library formats.</p>



<p>Weâ€™ll just look at the first one, â€˜_Z1hvâ€™. The â€˜_Zâ€™ can be safely ignored, its purpose there is mainly to tell the linker something â€œspecialâ€ is going on. â€˜1hâ€™ is the function name, and â€˜vâ€™ is its first (and only) parameter. Suppose, then, that you were tasked with writing a tool that undid this name mangling.</p>



<p>Your first cut at extracting something useful might look something like</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_useri' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };
</pre>


<p>Assuming&nbsp;<em>$mangle-me</em>&nbsp;has â€˜_Z9load_useriâ€™ in it (The mangled version of â€˜void load_user(int)â€™) the regex engine goes through a bunch of simple steps.</p>



<ul><li>Read and ignore â€˜_Zâ€™</li><li>Read and ignore â€˜9â€™</li><li>Capture â€˜load_userâ€™ into $0</li><li>Capture â€˜iâ€™ into $1</li><li>There is no fifth thing.</li></ul>



<p>But the person that wrote this library is playing silly buggers with someone (obviously&nbsp;<strong>us</strong>&nbsp;in this case) and thereâ€™s also a â€˜_Z9load_userssâ€™ which comes out of the other end of the mangle looking like â€˜void load_user(char*, char*)â€™, loading a user with first and last names.</p>



<p>Now weâ€™re in a bit of a quandary. Run the same expression and see what happens:</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_userss' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };
</pre>


<p>Sure enough,&nbsp;<em>$1</em>&nbsp;is â€˜sâ€™, just as we wanted it, but what about&nbsp;<em>$0</em>? Itâ€™s now â€˜load_usersâ€™, whichâ€¦ yâ€™know, looks too legit to quit. But we must. And now weâ€™re faced with the quandary. Do we make the first parameter an optional capture? â€˜m{ â€¦ (.)? (.) $ }â€™ like so?</p>



<p>No, that would capture the â€˜râ€™ of â€˜_Z9load_usersâ€™. There must be something else in the name that weâ€™re overlooking, some clueâ€¦ Aha! â€˜load_userâ€™ has 9 characters, and look just before it, weâ€™ve got the number 9! Surely that tells us the number of characters in the function name! (and thankfully it actually&nbsp;<strong>does</strong>.)</p>



<h2>Regexes 201</h2>



<p>Now, how can we use this to our advantage? First things first, letâ€™s get rid of some dead weight. We donâ€™t care (for the moment) about parameters, so letâ€™s just match the name and number of characters. And because weâ€™re getting all serious up in here, letâ€™s create a quick test.</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w+) };
is $0, '9';
is $1, 'load_user';
</pre>


<p>Run the test script, see if it passes, Iâ€™m sure you know the drill. Go ahead and copy that, Iâ€™ll wait. Okay, the tests pass, so itâ€™s time to play. I usually am working in a library thatâ€™s in git, so Iâ€™m usually on the â€œedit, run tests, git reset, editâ€¦â€ treadmill by this point.</p>



<p>Soâ€¦ How do we make use of this number? Well, letâ€™s pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes">Regexes</a>&nbsp;page over at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>and look around. Back in Perl 5 there used to be this feature â€˜m{ a{5} }xâ€™ that matched just 5 copies of whatever it was in front of, that might be a good place to start looking.</p>



<p>Thatâ€™s now morphed into â€˜m{ a ** 5 }â€™. Great, so letâ€™s replace 5 with&nbsp;<em>$0</em>&nbsp;and go for it.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** $0) };
</pre>


<p>â€œQuantifier quantifies nothingâ€¦â€ Thatâ€™s weird.&nbsp;<em>$0</em>&nbsp;is right there, staring me in the face. Maybe I just got the syntax wrong somehow?</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** 9) };
</pre>


<p>Nope, that works. Whatâ€™s going on here?&nbsp;<em>$0</em>&nbsp;is definedâ€¦ Wait, itâ€™s a variable inside a regex, that&nbsp;<strong>used</strong>&nbsp;to require the â€˜eâ€™ modifier, didnâ€™t it? Or something like thatâ€¦ &lt;read the manpage, scratch headâ€¦ nothing there&gt; Hm. Are we at a dead end?</p>



<h2>Kick it up a notch</h2>



<p>No, we just need to remember about how string interpolation works. In Raku, â€œHello, {$name}!â€ is a perfectly fine way to interpolate variables into your expression, and it works because no matter where it is, {} signals a code block. Letâ€™s try that, surround&nbsp;<em>$0</em>&nbsp;with braces.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {$0}) };
</pre>


<p>Weird. This time the test failed with â€ instead of â€˜load_userâ€™. Maybe&nbsp;<em>$0</em>&nbsp;really isnâ€™t defined? Now that itâ€™s just regular Raku code, letâ€™s check.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {warn "Got '$0'"; $0}) };
</pre>


<p>â€œUse of Nil in string context.â€ So itâ€™s really empty. Now, we have to&nbsp;<strong>really</strong>&nbsp;do some reading. Looking at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#General_quantifier:_**_min..max">general quantifiers</a>&nbsp;says â€œonly basic literal syntax for the right-hand side of the quantifier [what we want to play with] is supported,â€ so it looks like weâ€™re at a dead end.</p>



<p>But things like â€˜{$0}â€™&nbsp;<strong>do</strong>&nbsp;work, so we&nbsp;<strong>can</strong>&nbsp;use variables. That means that my problem isnâ€™t that the variable is being ignored, itâ€™s just not being populated when I need it. Letâ€™s look at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#Capture_numbers">Capture numbers</a>&nbsp;to see when they get populated.</p>



<p>Aha, you need to â€œpublishâ€ the capture using â€˜{}â€™ right after it. Letâ€™s see if that worksâ€¦</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) {} (\w ** {warn "Got '$0'"; $0}) };
</pre>


<p>Nope, something else is going on. And the next block down tells us the final solution â€“ â€˜:myâ€™. This lets us create a variable inside the scope of the regular expression and use it as well, so letâ€™s do just that.</p>


<pre class="brush: plain; title: ; notranslate">
'_Z9load_user' ~~ m{ ^ '_Z'
                     :my $length;          # Put $length in the proper scope
                     (\d+) {$length = +$0} # Capture the length
                     (\w ** {$length})     # And extract that many chars.
                   };
</pre>


<p>And reformat things just a wee bit so weâ€™ve got some room to work with. Now the test actually runs, and reads only as many characters of the function name as needs be.</p>



<h2>And just one more thingâ€¦</h2>



<p>Itâ€™s not just function names that follow this pattern, itâ€™s also namespaces, and any special types that the function might use as parameters, so letâ€™s package this up into something more useful.</p>


<pre class="brush: plain; title: ; notranslate">
my regexp pascalish-string {
  :my $length;
  (\d+) {$length = +$0}
  (\w ** {$length})
};
'_Z9load_user' ~~ m{ ^ '_Z' &lt;pascalish-string&gt; };
is $/&lt;pascalish-string&gt;[0], 9;
is $/&lt;pascalish-string&gt;[1], 'load_user';
</pre>


<p>Pascal implementations were done back when RAM was at more of a premium, and stored a string like â€˜load_userâ€™ as â€˜\x{09}load_userâ€™ so the compiler knew how many bytes were available immediately rather than having to guess. It was limiting, but this was on computers like the early Macs (weâ€™re talking pre-OS X, for that matter pre-System 7, for those of you that remember that far back.)</p>



<p>So we can use this&nbsp;<em>&lt;pascalish-string&gt;</em>&nbsp;regular expression anywhere we want to match one of our counted terms. Because weâ€™re using â€˜myâ€™ inside a regular expression nested inside another regular expression inside a burrito wrapped in an enigma, there are no scoping troubles.</p>



<p>There are probably other ways of doing this, and I would love to see them. If you do come up with a better way to solve this, let me know in the comments and Iâ€™ll work your solution into an upcoming article.</p>



<p>As usual, gentle reader, thank you for your time and attention, and if you have any comments, questions, clarifications or criticisms (constructive, please) let me know.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Templates and a Clean Start</title>
		<link>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/</link>
					<comments>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Thu, 18 Jul 2019 11:11:17 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=75</guid>

					<description><![CDATA[Before I get into the meat of the topic, which will eventually lead to a self-modifying grammar (yes, you heard me, self-modifyingâ€¦) I have a confession to make, in that a series of articles on the old site may have led people astray. I wrote that series thinking to make parsing things where no grammar<a class="more-link" href="https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/">Continue reading <span class="screen-reader-text">"Templates and a Clean&#160;Start"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Before I get into the meat of the topic, which will eventually lead to a self-modifying grammar (yes, you heard me, self-modifyingâ€¦) I have a confession to make, in that a series of articles on the old site may have led people astray. I wrote that series thinking to make parsing things where no grammar existed easier.</p>



<p>It may have backfired. So, as a penance, Iâ€™m simultaneously pointing theperlfisher.{com,net} to this new site, and starting a new series of articles on Raku programming with a different approach. This time Iâ€™ll be incorporating more of my thoughts and what hopefully will be a different approach.</p>



<h2>Begin as you mean to go on.</h2>



<p>I would love to dump the CMS Iâ€™m currently using for something written in Raku. Among the many challenges that presents is displaying HTML, and to paraphrase Clint Eastwood,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.youtube.com/watch?v=_VrFV5r8cs0">I do know my limitations.</a>&nbsp;So, I donâ€™t want to write HTML. Ideally, not ever.</p>



<p>So, that means&nbsp;<s>steal</s>&nbsp;borrowing HTML from other sites and making it my own. Since those are usually Perl 5 sites, that means dealing with Template Toolkit. And already I can hear some of you screaming â€œRaku already handles everything TT used to! Just use interpolated here-docs!â€</p>



<p>And, for the most part, youâ€™re absolutely correct. Instead of the clunky â€˜[% variable_name %]â€™ notation you can use clean inline interpolation with â€˜{$variable-name}â€™, and being able to insert blocks of code inline means you donâ€™t have to go through many of the hoops that youâ€™re required to jump through with Template Toolkit.</p>



<p>Thatâ€™s all absolutely true, and I hope to be able to use all of those features and more in the final CMS, whatever that happens to be. This approach ignores the fact that most HTML out there is written with Template Toolkit, and that rewriting HTML, even if itâ€™s just a few tiny tags, is an investment of time that could be better done elsewhere.</p>



<p>If only there were Template Toolkit for Rakuâ€¦</p>



<h2>Letâ€™s dive in!</h2>



<p>If youâ€™re not familiar with&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>, itâ€™s a fairly lightweight programming language for writing HTML templates, among others. Please donâ€™t confuse it with a markup language, designed to be rendered&nbsp;<strong>into</strong>&nbsp;HTML. This is a language that lets you combine your own code with a template and generate dynamic displays.</p>


<pre class="brush: plain; title: ; notranslate">
&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;
</pre>


<p>That is a simple bit of Template Toolkit. Doesnâ€™t look like much, does it? Itâ€™s obviously a fragment of a proper HTML document because thereâ€™s no â€˜&lt;html&gt;â€™..'&lt;/html&gt;â€™ bracketing it, and obviously whateverâ€™s between â€˜[%â€™ and â€˜%]â€™ is being treated specially. In this case, itâ€™s being rendered by an engine that fills in the name, maybe something likeâ€¦</p>


<pre class="brush: plain; title: ; notranslate">
$tt.render( 'hello.tt', :name( 'Jeff' ) );
</pre>


<p>where&nbsp;<em>hello.tt</em>&nbsp;is the name of the template file containing the previous code, and â€˜Jeffâ€™ is the name we want to substitute. Weâ€™ve got a lot of work to go through before we can get there, though. If youâ€™ve read previous articles of mine on the subject, please try to ignore what Iâ€™ve said there.</p>



<h3>Off the Deep End</h3>



<p>First things first, we need a package to work in. For this, I generally rely on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.perl6.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do the hard work for me. Start by installing the package with&nbsp;<em>zef</em>, and then weâ€™ll get down to business. (It should be installed by default, if youâ€™re still using rakudobrew please donâ€™t.)</p>



<pre class="wp-block-preformatted">$ zef install App::Mi6
{a bit of noise}
$ mi6 new Template::Toolkit
Successfully created Template-Toolkit
$ cd Template-Toolkit</pre>



<p>Ultimately, we want this test (in t/01-basic.t â€“ go ahead and add it) to pass:</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit;
my $tt = Template::Toolkit.new;
is $tt.render( 'hello.tt', :name( 'Jeff' ) ), '&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;';
</pre>


<p>Itâ€™ll fail (and miserably, at that) but at least itâ€™ll give us a goal. Also it should give us an idea of how others will use our API. Letâ€™s think about that for a few moments, just to make sure weâ€™re not painting ourselves into any obvious corners.</p>



<p>In order to be useful, our module has to parse Perl 5 Template Toolkit files, and process them in a way thatâ€™s useful in Raku. Certain things will go by the wayside, to be sure, but the core will be a module that lets us load, maybe compile, and fill in a template.</p>



<p>Hrm, I just said â€˜fill inâ€™ rather than â€˜renderâ€™, what I said above. Should I change the method name? No, not really, the new module will still&nbsp;<strong>do</strong>&nbsp;what the Perl 5 code used to, it just wonâ€™t do it using Perl 5, so some of the old conventions wonâ€™t work. Letâ€™s leave that decision for now, and go on.</p>



<h2>Retrograde is all the rage</h2>



<p>Letâ€™s apply some basic retrograde logic to what weâ€™ve got here, given what we know of Raku tools. In order to get the string â€˜&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;â€™ from â€˜&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;â€™, we need a lot of mechanics at work.</p>



<p>At first glance, it seems pretty obvious that â€˜[% name %]â€™ is a substitution marker, so letâ€™s just do a quick regexp like this:</p>


<pre class="brush: plain; title: ; notranslate">
$text ~~ s:g{ '[%' (\w+) '%]' } = %args{$0};
</pre>


<p>That should replace every marker in the text with something from an&nbsp;<em>%arguments</em>&nbsp;hash that&nbsp;<em>render()</em>&nbsp;supplies to us. End of column, end of story. But not so fast, if all Template Toolkit supplied to us was the ability to substitute values for keys, then â€¦ thereâ€™s really no need for the module. And in fact, if you look at the docs, it can do many more things for us.</p>



<p>For example, â€˜[% INCLUDE %]â€™ lets us include other template files in our own, â€˜[% IF %]â€™ .. â€˜[% END %]â€™ lets us do things conditionally, and a whole host of other â€œdirectivesâ€ are available. But youâ€™ll see here the one thing they have in common is they all start with â€˜[%â€™ and end with â€˜%]â€™.</p>



<h3>Hold the phone</h3>



<p>That isnâ€™t entirely true, and in fact thereâ€™s going to be another article in the series about that. But itâ€™s a good starting point. We may not know much about what the language itself looks like, but I can tell you that tags are balanced, not nested, and every â€˜[%â€™ opening tag has a â€˜%]â€™ tag that closes it.</p>



<p>Iâ€™ll also point out that directives ( â€˜[% foo %]â€™ ) can occur one after another without any intervening white space, and may not occur at all. So already some special cases are starting to creep in.</p>



<p>In fact, letâ€™s put this in as a separate test file entirely. So separate that weâ€™re going to put it in a nested directory, in fact. Letâ€™s open t/parser/01-basic.t and add this set of tests:</p>


<pre class="brush: plain; title: ; notranslate">
use Test;
use Template::Toolkit::Parser;

my $p = Template::Toolkit::Parser.new;

0000, AAAA
0001, AAAB
0010, AABA
0011, AABB
0100, ABAA
0101, ABAB
... # and so on up to
1110, BBBA
1111, BBBB
</pre>


<p>Now just HOLD THE PHONE hereâ€¦ weâ€™re testing directives for Template Toolkit, not binary numbers, and whatever that other column is! Well, thatâ€™s true. We want to test text and directives, and make sure that we can get back text when we want it, and directives when we want them.</p>



<p>At first blush you might think itâ€™s just enough to make sure that â€˜&lt;h1&gt; Hello,â€™ is parsed as text, and that â€˜[% name %]â€™ is parsed as a directive, and just leave it at that. But those of you that have worked with regular expressions for a while might wonder how â€˜[% name %][% other %]â€™ gets parsedâ€¦ does it end at the first â€˜%]â€™, or continue on to the next one?</p>



<p>And what about text mixed with directives? Leading? Trailing text? Wow, a lot of combinations. In fact, if you wanted to be thorough, it wouldnâ€™t hurt to cover all possible combinations of text and directives up toâ€¦ say, 4 in a row.</p>



<p>Letâ€™s call text â€˜Tâ€™, and directives â€˜Dâ€™. Iâ€™ve got 4 slots, and only two choices for each. Filling the first slot gives me â€˜T_ _ _â€™ and â€˜D_ _ _â€™, for two choices. I can fill the next slot with â€˜T T _ _â€™, â€˜T D _ _â€™, â€˜D T _ _â€™, and â€˜D D _ _â€™, and I think you can see where weâ€™re going with this.&nbsp;</p>



<p>In fact, replace T with 0 and D with 1, and youâ€™ve got the binary numbers from 0000 to 1111. So, letâ€™s take advantage of this fact, and do some clever editing in our editor of choice:</p>


<pre class="brush: plain; title: ; notranslate">
0010, 0010                            =&gt;
is-deeply the-tree( '0010, AABA       =&gt;
is-deeply the-tree( '0010' ), [ AABA  =&gt;
is-deeply the-tree( '0010' ), [ AABA ];
</pre>


<p>A few quick search-and-replace commands should get you from the first line to the last line. Now itâ€™s looking more like a Raku test, right? Weâ€™re not quite there yet, â€˜0010â€™ still doesnâ€™t look like a string of text and directives, and whatâ€™s this AABA thing? One more search-and-replace pass, this time global, should solve that.</p>


<pre class="brush: plain; title: ; notranslate">
is-deeply the-tree( '0010' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx1x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
          [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
</pre>


<p>Starting out with the padded binary numbers covers every combination of text and directive possible (at least 4 long). A clever bit of search-and-replace in your favorite editor gives us a working set of test cases that check a set of â€œreal-worldâ€ strings, and a file you can almost run. Next time weâ€™ll fill in the details, and get from zero to a minimal (albeit working) Template Toolkit implementation.</p>



<p>As always, dear reader, feel free to post whatever comments, questions, and/or suggestions that you may have, including ideas for future articles. I read and respond to every comment, and thank you for your time.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Logic Programming in Raku</title>
		<link>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/</link>
					<comments>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Fri, 21 Jun 2019 11:12:10 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=78</guid>

					<description><![CDATA[This is a small example of conference-driven development. Iâ€™m sitting in the board room at TPCiP â€“ TCP in Pittsburgh surrounded by people doing both Perl 5 and Raku programming, and decided to look again at Picat, working on some simple examples. I was thinking that I might be able to translate some of the<a class="more-link" href="https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/">Continue reading <span class="screen-reader-text">"Logic Programming in&#160;Raku"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>This is a small example of conference-driven development. Iâ€™m sitting in the board room at TPCiP â€“ TCP in Pittsburgh surrounded by people doing both Perl 5 and Raku programming, and decided to look again at Picat, working on some simple examples. I was thinking that I might be able to translate some of the simpler backtracking examples from Picat to Raku and hereâ€™s a simple example.</p>



<p>First the Picat code:</p>


<pre class="brush: plain; title: ; notranslate">
fib(0,F) =&gt; F=1.
fib(1,F) =&gt; F=1.
fib(N,F),N&gt;1 =&gt; fib(N-1,F1),fib(N-2,F2),F=F1+F2.
</pre>


<p>Now hereâ€™s my equivalent Raku code:</p>


<pre class="brush: plain; title: ; notranslate">
multi fib( 0, $F is rw ) { $F = 1 }
multi fib( 1, $F is rw ) { $F = 1 }
multi fib( $N is rw where * &gt; 1, $F is rw ) {
  my ( $F1, $F2 ) = 0, 0;
  my $N1 = $N - 1;
  my $N2 = $N - 2;
  fib( $N1, $F1 ) &amp;&amp; fib( $N2, $F2 ) &amp;&amp; $F = $F1 + $F2
}
</pre>


<p>The Raku version is slightly larger because I need to declare some variables that Picat would ordinarily declare for me ($F1, $F2). There may be a way to work around declaring ($N1, $N2), but otherwise the two versions are identical.</p>



<h2>How does it work?</h2>



<p>Youâ€™ve probably guessed based on the inputs that&nbsp;<em>N</em>&nbsp;is index of the Fibonacci number, and&nbsp;<em>F</em>&nbsp;is the Fibonacci number itself. Picat doesnâ€™t require you to declare variables, so you could ask it for the 7th Fibonacci number by calling fib(7,F) and looking at&nbsp;<em>F</em>.</p>


<pre class="brush: plain; title: ; notranslate">
my $Fib = 0;
fib(7,$Fib);
say $Fib     # 21
</pre>


<p>Or you could do the above in Raku, letting the code populate&nbsp;<em>$Fib</em>&nbsp;for you. This code relies on the fact that Raku lets you dispatch not just on signatures, not just on argument types, but on&nbsp;<strong>values</strong>. Look at the base case above:</p>


<pre class="brush: plain; title: ; notranslate">
multi fib( 0, $F is rw ) { ... }
</pre>


<p><em>fi</em>b(â€¦) is the function signature, and this function will get called whenever the first argument is 0, like so: fib(0, $Fib). This happens even if â€˜multi fib( $N, $F )â€™ is the one doing the calling, everything gets run through the same dispatcher each time.</p>



<p>So fib(2, $Fib) calls fib(1, $Fib) which calls â€˜multi fib( 1, $F )â€™ and gives us a base case, for example. This lets the higher-order functions call our base cases, and still get the right value.</p>



<h2>What are we missing?</h2>



<p>Well, the Picat code can do something the Raku code canâ€™t, at least for the moment, and this is what I want to spend some time working on. In Picat, I can call â€˜fib(6,F)â€™ and&nbsp;<em>F</em>&nbsp;will be 13 when the code is done. This works in Raku too.</p>



<p>But Picat will also let you call â€˜fib(N,21)â€™ and&nbsp;<em>N</em>&nbsp;will be 7 when the calculation is finished. Take some time to let that settle. Yes, you can run the calculation both forward and backward. Give&nbsp;<em>N</em>&nbsp;a value, and&nbsp;<em>F</em>&nbsp;will be the Nth Fibonacci number. Give F a value, and it will tell you what&nbsp;<em>N</em>&nbsp;is.</p>



<p>In fact, Picat will go one step further. If you donâ€™t specify a value for either parameter but just specify variables, like â€˜fib(N,F)â€™, then it will generate all the Fibonacci numbers and their indexes until you tell it to stop.</p>



<p>This is because of the backtracking engine that it uses, which I want to see if I can mimick. â€˜F=F1+F2â€™ doesnâ€™t mean â€œAssign the sum of F1 and F2 to Fâ€. Instead, â€œIf any values are missing, find values that satisfy the equation, and keep generating them until you run out of possibilities.â€</p>



<p>Thatâ€™s a bit of a mouthful, so letâ€™s look at just&nbsp;<em>F1</em>. Supposing F=8 and F2=5, the backtracking engine would search all values of&nbsp;<em>F1</em>, and return just the matching value of 3. Now of course, it canâ€™t search&nbsp;<strong>all</strong>&nbsp;values, because that means youâ€™d be waiting forever, so there are pruning algorithms at work here.</p>



<p>But the same logic can work with any combination of arguments, so if both&nbsp;<em>F1</em>&nbsp;and&nbsp;<em>F2</em>&nbsp;were missing, then the backtracking engine would run through all possible combinations of values (pruned appropriately) until it found a combination that would work.</p>



<p>In this case, since in our example F=8, it would return a bunch of combinations, starting with (F1=1, F2=7), (F1=2, F2=6) and so on. But why, then, you ask, does it only return (F1=3, F2=5)? Thatâ€™s because each value&nbsp;<em>F1</em>&nbsp;<strong>also</strong>&nbsp;has to satisfy fib(N1,F1), which means that&nbsp;<em>F1</em>&nbsp;has to be a Fibonacci number, as does&nbsp;<em>F2</em>.</p>



<h2>Breakdown</h2>



<p>This is the part where Raku breaks down a little bit. But what I think I might be able to do is use a trick I used a while ago, relying on the fact that operators are just functions, and they dispatch just like other functions. So I should be able to start out with something crude like:</p>


<pre class="brush: plain; title: ; notranslate">
my $F = Operator.new( :lhs(3) );
my Value ($F1, $F2);
$F = $F1 + $F2;
</pre>


<p>This way both&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;are bound to backtracking Values, they return a Operator, and the Operator is part of the backtracking engine. This way once the Operator engine determines the range of possible combinations of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;that add to 3, it can assign them concurrently to&nbsp;<em>@F1.value</em>&nbsp;and&nbsp;<em>@F2.value</em>.</p>



<h2>Smooth Operators</h2>



<p>The Operator and Value classes, along with their overloaded operators, would look something like this:</p>


<pre class="brush: plain; title: ; notranslate">
class Operator {
  has ( $.lhs, $.rhs ); }
class PlusOperator is Operator { }
class AssignmentOperator is Operator {
  method make-combinations() {...} }
class Value {
  has @.value }
multi infix:&lt;=&gt;( Operator $lhs, Operator $rhs ) {
  AssignmentOperator.new( :$lhs, :$rhs );
}
multi infix:&lt;+&gt;( Value $lhs, Value $rhs ) {
  PlusOperator.new( :$lhs, :$rhs );
}
</pre>


<p>This is purely a sketch that I havenâ€™t tried out at all. My idea here is that once youâ€™ve executed â€˜$F = $F1 + $F2â€™,&nbsp;<em>$F</em>&nbsp;will be an&nbsp;<em>AssignmentOperator</em>&nbsp;instance. You should be able to call&nbsp;<em>$F.make-combinations()</em>&nbsp;that will solve the equation â€˜3 = $F1 + $F2â€™ for all (constrained) values of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>.</p>



<p>That would populate&nbsp;<em>@F1.values</em>&nbsp;and&nbsp;<em>@F2.values</em>&nbsp;with (1,2) and (2,1) respectively. Iâ€™m about to play my first game of&nbsp;<em>Azul</em>, so Iâ€™ll leave the article here. The next article will hopefully implement this so you can see this all working. It wonâ€™t quite be a true backtracking engine, but itâ€™s a start.</p>



<p>Dear Reader, thank you for your attention, and please feel free to add comments, questions and suggestions.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
		<item>
		<title>Quantum Tunneling</title>
		<link>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/</link>
					<comments>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/#respond</comments>
		
		<dc:creator><![CDATA[Perl Fisher]]></dc:creator>
		<pubDate>Mon, 20 May 2019 11:12:46 +0000</pubDate>
				<category><![CDATA[Raku programming]]></category>
		<guid isPermaLink="false">http://perlfisher.wordpress.com/?p=81</guid>

					<description><![CDATA[Introducing the new Perl Fisher site Before I get on to the meat of the article, welcome to the new home of The Perl Fisher. I intend to cover both Perl 5 and Raku programming here, but itâ€™ll be mostly Raku content because thatâ€™s the language I find the most fun. Please excuse the dust,<a class="more-link" href="https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/">Continue reading <span class="screen-reader-text">"Quantum Tunneling"</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Introducing the new Perl Fisher site</p>



<p>Before I get on to the meat of the article, welcome to the new home of The Perl Fisher. I intend to cover both Perl 5 and Raku programming here, but itâ€™ll be mostly Raku content because thatâ€™s the language I find the most fun. Please excuse the dust, Iâ€™m still very much settling into the new home, and the overall look of the site is bound to change while I play with the new toys available to me.</p>



<h3>Defeating Thanos with Raku</h3>



<p>Donâ€™t worry, no spoilers here. Weâ€™re just going to talk about a little-known feature of Raku, the quantum-tunneling variable type. If youâ€™ve worked with Raku for any length of time, youâ€™ve probably seen or written a class declaration that looks something like below.</p>


<pre class="brush: plain; title: ; notranslate">
class Point2D {
  has Real $.x;
  has Real $.y;
}
</pre>


<p>While the word â€˜hasâ€™ does the real work, second-sigil syndrome strikes as well, in the shape of the â€˜.â€™ between the scalar sigil â€˜$â€™ and the variable name. Here itâ€™s syntactical sugar for being an attribute name, but we can enlarge that â€˜.â€™ to a â€˜*â€™ and open up a world of possibilities.</p>



<p>When we add the â€˜*â€™ sigil to a variable name, we turn that variable into one that can quantum tunnel between scopes and solve problems that you probably used to do with a global variable. You can read more about dynamic variables and how they differ from ordinary globals at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/variables#The_*_twigil">The_*_twigil</a>at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>.</p>



<h3>Testing, testing</h3>



<p>Iâ€™m working on a project to try to augment the Raku grammar debugger with an emulator. The tools we have on CPAN and modules.perl6.org respectively are wonderful, but theyâ€™re limited because Raku compiles grammar rules down to single methods, which is wonderful for speed, but makes it almost impossible to look into.</p>



<p>The grammar Iâ€™m writing isnâ€™t important at the moment, but the testing part is. Below is a sample subtest that Iâ€™m writing for each term of a grammar thatâ€™s probably going to have ~50 terms by the time Iâ€™m done.</p>


<pre class="brush: plain; title: ; notranslate">
subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
    ok fails( '3g', 'binary-number' );
  };

  is build-ast( '0101', 'binary-number' ), 5;
};
</pre>


<p>This tests the â€˜binary-numberâ€™ rule to see if it properly fails on â€˜0bâ€™ and â€˜3gâ€™. â€˜0bâ€™ fails because itâ€™s the&nbsp;<strong>prefix</strong>&nbsp;of a binary number, and â€˜3gâ€™ because neither 3 nor â€˜gâ€™ are binary digits. It also makes certain that â€˜0101â€™ gets translated into the decimal number 5. All important when testing a grammar that parses â€¦ well, itself eventually. Oroborous redux, as it were.</p>



<h3>Dry up, will youâ€¦</h3>



<p>The test is simple, and straightforward. â€˜0bâ€™ should fail, â€˜0101â€™ should be built into a node of an abstract syntax tree. But itâ€™s got some flaws. It talks too much. See how â€˜binary-numberâ€™ repeats itself? If I want to copy that, rename it to â€˜hex-numberâ€™ and add a few changes, I have to copy the block, rename all the incidences of â€˜binary-numberâ€™ to â€˜hex-numberâ€™ and&nbsp;<strong>then</strong>&nbsp;fix the existing tests.</p>



<p>Thus I run the risk of forgetting to update the name â€˜binary-numberâ€™. And thereâ€™s an even greater bugaboo there. If I&nbsp;<strong>donâ€™t</strong>, the test wonâ€™t fail. Because the subtest doesnâ€™t know that itâ€™s supposed to be testing the â€˜binary-numberâ€™ rule. There are a bunch of ways to solve this problem, of course, but for this post weâ€™re going to use Ant-Man(tm).</p>



<h3>Entering the Quantum Realm</h3>



<p>I donâ€™t want to do&nbsp;<strong>too</strong>&nbsp;much work here, I just want to get rid of the duplicate â€˜binary-numberâ€™ entries. So, letâ€™s take a look at what&nbsp;<em>fails()</em>&nbsp;does.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}
</pre>


<p>The â€˜!?(â€¦)â€™ casts&nbsp;<em>$g.parse(â€¦)</em>&nbsp;to a Boolean and negates it, so if&nbsp;<em>$g</em>&nbsp;canâ€™t parse the statement, it returns&nbsp;<em>True</em>. So, first letâ€™s make&nbsp;<em>$rule-name</em>&nbsp;optional.&nbsp;</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}
</pre>


<h4>Opening the wormhole</h4>



<p>Now, weâ€™re going to summon Ant-Man(tm). Remember earlier I mentioned that quantum variables use a wormhole? Well, weâ€™re going to open one end of the wormhole right here in our&nbsp;<em>fails()</em>&nbsp;function, just like this.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}
</pre>


<p>Rerun our tests, and â€¦ wait, they should fail, we havenâ€™t declared&nbsp;<em>$*ANT-MAN</em>&nbsp;anywhere! Well, just like in quantum physics,&nbsp;<em>$*ANT-MAN</em>&nbsp;doesnâ€™t have enough energy to tunnel over the quantum barrier because we havenâ€™t defined him yet.&nbsp;</p>



<p>So letâ€™s do that, but remember that&nbsp;<em>$*ANT-MAN</em>&nbsp;is a quantum variable, so he can tunnel through the quantum barrier of a function scope. In fact, he can tunnel through any number of them. So, letâ€™s define a new version of&nbsp;<em>subtest()</em>&nbsp;that looks and acts like the old one first before we go boldly where no Raku programmer has gone before.</p>


<pre class="brush: plain; title: ; notranslate">
sub Subtest( Str $rule-name, Block $test-code ) {
  subtest $rule-name, $test-code;
}
</pre>


<p>We should be able now to replace the outer&nbsp;<em>subtest()</em>&nbsp;block with our new&nbsp;<em>Subtest()</em>&nbsp;block, and it should act just as it used to.</p>


<pre class="brush: plain; title: ; notranslate">
Subtest 'binary-number', {
  subtest 'failing', {
    ok fail( '0b', 'binary-number' );
    ...
  };
  ...
};
</pre>


<h4>Tunneling through</h4>



<p>Our test suite still works, and the output still is what we expect. Now, letâ€™s give&nbsp;<em>$*ANT-MAN</em>enough energy to tunnel through the quantum barrier by defining him as the subtest name we want:</p>


<pre class="brush: plain; title: ; notranslate">
sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}
</pre>


<p>And now run our test suite. Whichâ€¦ doesnâ€™t change. Come to think of it, we donâ€™t want it to change. If it&nbsp;<strong>did</strong>&nbsp;change, weâ€™d have to go through and change all of our test suites, which would be bad. So, putting things together, this code works just fine.</p>


<pre class="brush: plain; title: ; notranslate">
sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}
sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}

Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
  };
};
</pre>


<p>Notice by the way that&nbsp;<em>$*ANT-MAN</em>&nbsp;has tunneled through not one but&nbsp;<strong>two</strong>&nbsp;function signatures to get to where he is. And to prove it, finally, delete the inside â€˜binary-numberâ€™.</p>


<pre class="brush: plain; title: ; notranslate">
Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b' );
  };
};
</pre>


<p>So â€˜binary-numberâ€™ gets passed along to&nbsp;<em>$*ANT-MAN</em>&nbsp;who jumps into the quantum realm, tunnels through the outer&nbsp;<strong>and</strong>&nbsp;inner pairs of braces, and finally lands in&nbsp;<em>fails()</em>&nbsp;where he passes the value on to the :rule() declaration. Whew, thatâ€™s a lot of work.</p>



<h3>Oh, snap.</h3>



<p>(sorry, couldnâ€™t resist.) If youâ€™re like me, and I know&nbsp;<em>I</em>&nbsp;am, youâ€™ve probably come across a few cases where this technique would come in handy. Especially if youâ€™re dealing with legacy code. Sometimes you need to add just one little flag to a function and set that flag in a top-level handler on one page of a website.</p>



<p>The catch is that between the lower level and the top level thereâ€™s a chain of 8 function calls where you have to add that as a parameter. Wouldnâ€™t it be nice if there was a workaround? Well, in Raku there is.</p>



<p>Thanks for getting all the way to the bottom of this, my inaugural article on Raku on the next generation of the Perl Fisher website. Feel free to leave comments and constructive criticism in the comments section below, and come back every so often to watch the website grow over the coming months.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/dcfbf9237da4c5ca3f8b972e1dddc8f1?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">theperlfisherdaaea6189e</media:title>
		</media:content>
	</item>
	</channel>
</rss>
