<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress.com" created="2020-06-30 16:20"-->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>The Perl Fisher</title>
	<link>https://perlfisher.wordpress.com</link>
	<description></description>
	<pubDate>Tue, 30 Jun 2020 16:20:31 +0000</pubDate>
	<language></language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://wordpress.com/</wp:base_site_url>
	<wp:base_blog_url>https://perlfisher.wordpress.com</wp:base_blog_url>

	<wp:author><wp:author_id>188942822</wp:author_id><wp:author_login><![CDATA[theperlfisherdaaea6189e]]></wp:author_login><wp:author_email><![CDATA[theperlfisher@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[Perl Fisher]]></wp:author_display_name><wp:author_first_name><![CDATA[Perl]]></wp:author_first_name><wp:author_last_name><![CDATA[Fisher]]></wp:author_last_name></wp:author>

	<wp:category><wp:term_id>1130904</wp:term_id><wp:category_nicename>perl-programming</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Perl programming]]></wp:cat_name>
</wp:category>
	<wp:category><wp:term_id>701879959</wp:term_id><wp:category_nicename>raku-programming</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Raku programming]]></wp:cat_name>
</wp:category>
	<wp:category><wp:term_id>1</wp:term_id><wp:category_nicename>uncategorized</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name>
</wp:category>
	<wp:tag><wp:term_id>5226</wp:term_id><wp:tag_slug>perl</wp:tag_slug><wp:tag_name><![CDATA[Perl]]></wp:tag_name>
</wp:tag>
	<wp:tag><wp:term_id>1130904</wp:term_id><wp:tag_slug>perl-programming</wp:tag_slug><wp:tag_name><![CDATA[Perl programming]]></wp:tag_name>
</wp:tag>
	<wp:tag><wp:term_id>358014</wp:term_id><wp:tag_slug>raku</wp:tag_slug><wp:tag_name><![CDATA[Raku]]></wp:tag_name>
</wp:tag>
	<wp:tag><wp:term_id>701879959</wp:term_id><wp:tag_slug>raku-programming</wp:tag_slug><wp:tag_name><![CDATA[Raku programming]]></wp:tag_name>
</wp:tag>
	<wp:term><wp:term_id>1359</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[primary]]></wp:term_slug><wp:term_name><![CDATA[Primary]]></wp:term_name>
</wp:term>
	<wp:term><wp:term_id>1360</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[social]]></wp:term_slug><wp:term_name><![CDATA[Social]]></wp:term_name>
</wp:term>

	<generator>http://wordpress.com/</generator>
<image>
		<url>http://s0.wp.com/i/buttonw-com.png</url>
		<title>The Perl Fisher</title>
		<link>https://perlfisher.wordpress.com</link>
	</image>
		
	<item>
		<title>Rewriting Perl Code for Raku</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku/</link>
		<pubDate>Sun, 24 Nov 2019 12:00:00 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=66</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>This time around we’re going to talk about how to rewrite Perl code in Raku. Even in 2019, a lot of the office world revolves around spreadsheets, whether they be Excel,&nbsp;<a href="http://web.archive.org/web/20200212094016/http://libreoffice.org/">LibreOffice</a>&nbsp;or simple .csv files. Perl 5 has a plethora of modules to do this, a quick search for ‘Spreadsheet’ on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/">MetaCPAN</a>should convince you of that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The Raku world doesn’t have quite as many modules as you’d expect, though. While it’s been around for a few years, “heavy lifting” modules like Spreadsheet stuff really haven’t come around yet. This involves packing and unpacking binary formats, and in Perl 5 this centered around the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins, which are relative newcomers to Raku.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But Raku has built-in binary buffers, which take care of most of the need for pack/unpack. The main reason I can see is the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.microsoft.com/interop/docs/supportingtechnologies.mspx">OLE</a>&nbsp;storage format. Basically it’s Microsoft’s way of packing a file system into a single data file. And at this point the proverbial yaks start to pile up, and reasonable people say “You know, Excel still accepts .csv files, I know how to build those.”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Enter<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">&nbsp;raku-OLE-Storage_Lite</a>&nbsp;– this is my translation-in-progress from Perl 5 to Raku. As of this writing it can read an entire OLE file (without data) and write a good portion of the sample file – I believe I’ve got maybe two methods left to debug.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Knee deep in yaks</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>CSV files are easy to write, but they come with their own set of troubles. When you import a .csv file into your Excel app (or LibreOffice, or whatever) you’re faced with a complex dialog asking you how to import your data, and the average user doesn’t want that every time, they just want to open their spreadsheet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, it’s time to follow Liz’s lead and rewrite in Raku an existing module. First thing I did was go to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/Spreadsheet::ParseExcel">Spreadsheet::ParseExcel</a>&nbsp;and see how they did things. Within a few minutes I’d already encountered the first yak. After opening the file, it delegates it to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>, which is much like&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.jamesbrown.com/">James Brown</a>, the “hardest-working man in show business”.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It’s still on version 0.19 at the time of writing, but I assure you that’s only because the current maintainer hasn’t updated the version to reflect reality. It may be legacy Perl rough-and-tumble code, but it’s been around for a long time. It wears its battle scars proudly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It relies heavily on&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>, which are still&nbsp;<strong>technically</strong>&nbsp;experimental in Raku. The OO and coding style betrays its pre-5.00 origins, and the tests are, well, very pragmatic. “Does it load? Great! Can it convert timestamps internally? Great! Ship it!”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To its credit, there’s a sample directory where you can use&nbsp;<em>smpview.pl</em>&nbsp;to view the contents of the internal filesystem of any OLE file, and a sample writer to create a known-working OLE file. That’ll do as a starting point.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Buckling down</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>So, reading an Excel spreadsheet means reading an OLE file system. And when I say file system, I’m not kidding. Inside your typical .xlsx file, there’s a small header and a root object. The root object contains “pointers” (really file offsets) to a document object, and inside that are file objects, each with pointers to the different blocks.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is all intended to reflect the original disk layout, so it looks very much like an NTFS superblock and block layout. The documentation seems to have moved to&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-oleds/fdc5e702-d09e-4344-a77f-eb079d41f23f">this</a>&nbsp;page detailing OLE 1.0 and 2.0 formats, I’m not at all certain what the current version has.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>How are Excel spreadsheets arranged in here? Worksheets are OLE directories, and inside each worksheet, tabs are individual files. How’s that for a bit of inspiration? Luckily the Root directory, Files and nested Directories are all separate objects, with at least a few common methods aggregated into a superclass.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Legacy Code</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This is a long-winded way of saying the module in question is very much legacy code. And, as I want to bring it into the proverbial light, I’ve got to give some issues some thought.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>No useful tests, so I’ll have to write those.</li><li>How much code do I want to sacrifice?</li><li>How much can I save?</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Well, I can put off #2 and #3 while writing some tests. Whoa, wait a minute. I don’t have a test file to work with, just some scripts over in sample/. Mumble, mumble, more yaks. Read README, find that smpsv.pl will create one, run that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Great, I’ve got a sample test.xsl file. But given the amount of potential bit-rot it seems prudent to actually make sure that I’ve got a working Excel file before committing a few days (ha!) to getting a module working. Double-click it, launch into Excel’s cloud-serviced app, find that it’s one of those Win10 panes I’ve never figured out how to close, open task-killer, kill that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Launch&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.libreoffice.org/">LibreOffice</a>&nbsp;which I happen to have lying around – my current project at work is parsing a spreadsheet in Perl 5, which is what inspired this whole workload.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Yep, that parses; looks a bit odd because it’s coming up with a Japanese font, and some arbitrary English text, but it works. Also, looking at the code it generates all three object types – Root, File and Dir, so it’ll exercise the major code paths. Bonus.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Testing, testing</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now I’ve got the makings of a simple test file. The script builds objects individually, so I can run the individual calls, and check that the object’s internals look the way I want.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $oDt = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ ],
  [ 0, 0, 16, 4, 10, 100 ], # 2000/11/4 16:00:00:0000
  [ $oWk, $oDir ]
);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In Raku, this converts to:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>I’ve made one change already, to make things simpler for Raku users. In Perl, you have to pass lists as references unless you want to use the new function signatures. In Raku, you can just pass lists as you would ordinarily to your method call.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Using native data types rather than passing references around may seem a bit odd at first to new Raku programmers, but the new variable classes are easier to enforce strong typing on later, when you get used to the language.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Going with the flow</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now we’ve got something we can test, namely making sure that we’ve got a valid OLE Root document. So, before we go ahead with the code, I’ll share a few little things. I know very little about this code, so I want to make sure that I&nbsp;<strong>intimately</strong>&nbsp;copy each detail of the object at this stage. Later on I might get fancy and replace things with their own object types, but for now, my goal is going to be 1:1 replication.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I tend to like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/tmux/tmux/wiki">tmux</a>&nbsp;as a shell environment, haven’t really gotten along with UIs. So, keeping in mind that I wanted an absolute 1:1 copy of the original object, I ended up doing this:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Switch to new window, open my copy of ‘samples/smpsv.pl’ in vim</li><li>Add ‘use YAML; die Dump( $oDt ) just below the line where it gets created</li><li>Switch to new window, run the sample script, copy the YAML output</li><li>Close the two new windows I created to keep clutter down</li><li>Paste the YAML code into the new Raku test.</li></ol>
<!-- /wp:list -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
--
  Name: "R\0o\0o\0t\0 \0E\0n\0t\0r\0y\0"
  No: ~
  Time2nd:
    - 0
    - 0
    - 16
    - 4
    - 10
    - 100
# and so on...</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This should contain all I need to create an OLE file from this set of objects. I’m using this as a sneaky way of not reading the spec, at least not yet. As the old title goes: Algorithm + Data Structure = Program. Using YAML (or Data::Dumper) gives me the data structure, copying the Perl 5 code into Raku gives me the algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I should almost be able to keep line-for-line fidelity, so when a patch is posted to the Perl 5 source I can import it into Raku without too much trouble. But once I’ve got a better test base and a few users in Raku I’ll probably rewrite this whole module in a more Raku-ready fashion. I can keep the old module around for reference.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Encoding worries</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>But we’ve also got a surprise lurking here. “R\0o\0ot\0 \0E\0n\0t\0r\0y\0” looks like binary garbage, but is actually UCS-2, I think. If it is, then the OLE file is limited to a subset of Unicode. I can put restrictions on it later if I have to, but ATM I actually don’t care.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve done enough time in the i18n salt mines that I know how to deal with this. Store the string in the best format possible (UTF-8 here) internally. When the time comes to write it to the network or disk, translate it to the final encoding.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This way I can see what all the attributes are at a glance without changing encoding. I can also manipulate everything using regular Raku code until the last moment. If I have to, I can use Raku’s gradual typing to constrain the string. More importantly, I don’t have to do any of this&nbsp;<strong>now</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Got any change?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This means I’m going to change things just a little bit more. When data gets added to ‘Name’ I’m going to assume it’s UTF-8. Since I’m not doing any I/O yet, I can make whatever assumptions I want. Keeping the internals simple keeps my life simple, at least.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So I’ll write out a quick&nbsp;<em>is-deeply</em>&nbsp;test and get on with things:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">is-deeply $oDt, (
  Name =&gt; 'Root Entry',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
  Child =&gt; ( $oWk, $oDir )
);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This looks pretty straightforward, and almost how you’d write the original test in Perl 5. It won’t&nbsp;<strong>run</strong>&nbsp;yet, but that’s something we’ll tackle in the next part in the series.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’m not done quite yet, because I’ve got a lot of these things to write, and not all of them may have the ‘Child’ attribute. I could write a tiny method that skipped over the ‘Child’ attribute along with anything else I wanted, but that felt clumsy. It looked like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">ok sorta-deeply $oDt, (
  Name =&gt; 'Root Window',
  Time2nd =&gt; ( 0, 0, 16, 4, 10, 100 ),
  # ...
), ( 'Child' );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And notice that&nbsp;<em>sorta-deeply</em>&nbsp;is a function that does all the work, then passes a simple Bool back to the test. I’d end up writing all of the code that&nbsp;<em>is-deeply</em>&nbsp;does (except for the recursion), and get something back that’s less useful.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next time we’ll get into making these tests pass. I’m writing the next section right after this, but you won’t get to see it for another week or so, I’m afraid. If you have questions or comments about the first part of this series, please feel free to comment below.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>66</wp:post_id>
		<wp:post_date>2019-11-24 13:00:00</wp:post_date>
		<wp:post_date_gmt>2019-11-24 12:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rewriting-perl-code-for-raku</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="perl-programming"><![CDATA[Perl programming]]></category>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515347]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025508712]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Templates II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/08/08/templates-ii-electric-boogaloo/</link>
		<pubDate>Thu, 08 Aug 2019 11:09:35 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=69</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p><a href="http://web.archive.org/web/20200212094016/http://theperlfisher.com/index.php/2019/07/18/templates-and-a-clean-start/">Last time</a>&nbsp;on this adventure writing the&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>&nbsp;language in Raku, we’d just created a small test suite that encompasses some of the problems we’re going to encounter. It’s no use without a grammar and a&nbsp;<strong>bunch</strong>&nbsp;of other parts, but it does give us an idea of what it’s going to look like.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;
use Template::Toolkit::Grammar;
use Template::Toolkit::Actions;

# ... similar lines above this
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];
# ... and similar lines below this.</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The list here is what we’re going to return to&nbsp;<em>render()</em>, and I’d love to make that as simple as it can be without being&nbsp;<strong>too</strong>&nbsp;simple. Let’s focus for the moment just on one bit of the test suite here, the array I’m getting back.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">[ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>If these elements were&nbsp;<strong>all</strong>&nbsp;strings, then all&nbsp;<strong>render()</strong>&nbsp;would have to do is join the strings together, simples!</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method render( Str $text ) returns Str {
  my @terms = # magic to turn text into array of terms
  @terms.join: '';
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Let’s create the ‘Directive’ class and see what happens, though.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Directive { has $.content }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: '';
# aaDirective&lt;94444485232315&gt;a</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Whoops, that’s not what we want. Not&nbsp;<strong>bad</strong>&nbsp;exactly, but not what we want, either. Well, not to fear. Remember that in Template Toolkit, directives will always return a string. It may be an&nbsp;<strong>empty</strong>string, but they’ll always return some kind of string.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As a side note, this may not always be true – some directives will even tell the renderer to stop parsing entirely. But it’s a pretty solid starting assumption. For instance, we could say that encountering the STOP directive just makes all future directives return ”.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Of course, I’m harping on the term ‘string’ for a reason. Internally, everything is an object, and every object has a method that returns a readable value. Our Directive class didn’t specify one, so we get the default that returns ‘$name&lt;$address&gt;’.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let’s supply our own method.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Directive { has $.content; method Str { $.content } }

my @terms = 'a', 'a', Directive.new( :content( 'name' ) ), 'a';
say @terms.join: ', ';
# a, a, name, a</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>There. If we supply a .Str method we can make Directives do what we want. INCLUDE directives would open the file, slurp the contents and return them. Argument directives would take their argument name, look up the value, and return that. Or, more likely, would have a context object passed that does the lookup for them.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Where do we go from here?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Next time we’ll convince Grammars and Actions to work together, making processing a template as simple as:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">parse-template( $text ).join( '' );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Next in this series on writing your own template language using Raku, you should be able to define your own Template Toolkit directives and have them return the pre-processed text. We’ll add support for context and the ability to do simple ‘[% name %]’ tags, and maybe explore how to change ‘[%’..’%]’ tags on-the-fly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thank you again, dear reader, for your interest, comments and critiques.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>69</wp:post_id>
		<wp:post_date>2019-08-08 13:09:35</wp:post_date>
		<wp:post_date_gmt>2019-08-08 11:09:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>templates-ii-electric-boogaloo</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515409]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025539417]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A Regex amuse-bouche</title>
		<link>https://perlfisher.wordpress.com/2019/07/24/a-regex-amuse-bouche/</link>
		<pubDate>Wed, 24 Jul 2019 11:10:22 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=72</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Before continuing with the Template series, I thought I’d talk briefly about an interesting (well, at least to me) solution to a little problem. System and user libraries (the kind that end in .so or .a, not Perl libraries) have a section at the top that maps a function name (‘load_user’ or whatever) to an offset into the library, say, 0x193a.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This arrangement worked fine for many years for C, Algol, FORTRAN and most other languages out there. But then along came languages that upset the apple cart, like C++ and Smalltalk, where a programmer could write two ‘load_user’ functions, call ‘load_user(1234)’ or ‘load_user(“Smith, John”)’ and expect the linker to load the right version of ‘load_user.’</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The problem here is that the library, the linker and all of the other programs in the tool chain expect there to only be one function called ‘load_user’ in any given library.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Those of us that do Perl 5 and Raku programming don’t have to worry about this, but if you ever want to link to a C++ library, you probably should know at least a bit about “name mangling.”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For a while, utilities like ‘CFront’ for the Macintosh (which the author actually filed bug reports on) were used to “rename” functions like ‘load_user(int)’ and ‘load_user(char*)’ to ‘i_load_user’ and ‘cs_load_user’ before being added to the library, and other tools to do the reverse.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Has Your Mother Sold Her Mangle?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Eventually things settled down, and this process of changing names to fit into the library was “baked in” to the tool chains. Not consistently, of course, couldn’t have that. But conventions arose and even today&nbsp;<a href="http://web.archive.org/web/20200212094016/https://en.wikipedia.org/wiki/Name_mangling">Wikipedia</a>&nbsp;lists at least 12 different ways to “mangle” ‘void h(void)’ into the existing library formats.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We’ll just look at the first one, ‘_Z1hv’. The ‘_Z’ can be safely ignored, its purpose there is mainly to tell the linker something “special” is going on. ‘1h’ is the function name, and ‘v’ is its first (and only) parameter. Suppose, then, that you were tasked with writing a tool that undid this name mangling.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Your first cut at extracting something useful might look something like</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_useri' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Assuming&nbsp;<em>$mangle-me</em>&nbsp;has ‘_Z9load_useri’ in it (The mangled version of ‘void load_user(int)’) the regex engine goes through a bunch of simple steps.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Read and ignore ‘_Z’</li><li>Read and ignore ‘9’</li><li>Capture ‘load_user’ into $0</li><li>Capture ‘i’ into $1</li><li>There is no fifth thing.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>But the person that wrote this library is playing silly buggers with someone (obviously&nbsp;<strong>us</strong>&nbsp;in this case) and there’s also a ‘_Z9load_userss’ which comes out of the other end of the mangle looking like ‘void load_user(char*, char*)’, loading a user with first and last names.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now we’re in a bit of a quandary. Run the same expression and see what happens:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_userss' ~~ m{ ^ '_Z' \d+ (\w+) (.) $ };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Sure enough,&nbsp;<em>$1</em>&nbsp;is ‘s’, just as we wanted it, but what about&nbsp;<em>$0</em>? It’s now ‘load_users’, which… y’know, looks too legit to quit. But we must. And now we’re faced with the quandary. Do we make the first parameter an optional capture? ‘m{ … (.)? (.) $ }’ like so?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>No, that would capture the ‘r’ of ‘_Z9load_users’. There must be something else in the name that we’re overlooking, some clue… Aha! ‘load_user’ has 9 characters, and look just before it, we’ve got the number 9! Surely that tells us the number of characters in the function name! (and thankfully it actually&nbsp;<strong>does</strong>.)</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Regexes 201</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now, how can we use this to our advantage? First things first, let’s get rid of some dead weight. We don’t care (for the moment) about parameters, so let’s just match the name and number of characters. And because we’re getting all serious up in here, let’s create a quick test.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;
'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w+) };
is $0, '9';
is $1, 'load_user';</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Run the test script, see if it passes, I’m sure you know the drill. Go ahead and copy that, I’ll wait. Okay, the tests pass, so it’s time to play. I usually am working in a library that’s in git, so I’m usually on the “edit, run tests, git reset, edit…” treadmill by this point.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So… How do we make use of this number? Well, let’s pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes">Regexes</a>&nbsp;page over at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>and look around. Back in Perl 5 there used to be this feature ‘m{ a{5} }x’ that matched just 5 copies of whatever it was in front of, that might be a good place to start looking.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That’s now morphed into ‘m{ a ** 5 }’. Great, so let’s replace 5 with&nbsp;<em>$0</em>&nbsp;and go for it.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** $0) };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>“Quantifier quantifies nothing…” That’s weird.&nbsp;<em>$0</em>&nbsp;is right there, staring me in the face. Maybe I just got the syntax wrong somehow?</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** 9) };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Nope, that works. What’s going on here?&nbsp;<em>$0</em>&nbsp;is defined… Wait, it’s a variable inside a regex, that&nbsp;<strong>used</strong>&nbsp;to require the ‘e’ modifier, didn’t it? Or something like that… &lt;read the manpage, scratch head… nothing there&gt; Hm. Are we at a dead end?</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Kick it up a notch</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>No, we just need to remember about how string interpolation works. In Raku, “Hello, {$name}!” is a perfectly fine way to interpolate variables into your expression, and it works because no matter where it is, {} signals a code block. Let’s try that, surround&nbsp;<em>$0</em>&nbsp;with braces.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {$0}) };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Weird. This time the test failed with ” instead of ‘load_user’. Maybe&nbsp;<em>$0</em>&nbsp;really isn’t defined? Now that it’s just regular Raku code, let’s check.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z' (\d+) (\w ** {warn "Got '$0'"; $0}) };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>“Use of Nil in string context.” So it’s really empty. Now, we have to&nbsp;<strong>really</strong>&nbsp;do some reading. Looking at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#General_quantifier:_**_min..max">general quantifiers</a>&nbsp;says “only basic literal syntax for the right-hand side of the quantifier [what we want to play with] is supported,” so it looks like we’re at a dead end.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But things like ‘{$0}’&nbsp;<strong>do</strong>&nbsp;work, so we&nbsp;<strong>can</strong>&nbsp;use variables. That means that my problem isn’t that the variable is being ignored, it’s just not being populated when I need it. Let’s look at the section on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/regexes#Capture_numbers">Capture numbers</a>&nbsp;to see when they get populated.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Aha, you need to “publish” the capture using ‘{}’ right after it. Let’s see if that works…</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z' (\d+) {} (\w ** {warn "Got '$0'"; $0}) };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Nope, something else is going on. And the next block down tells us the final solution – ‘:my’. This lets us create a variable inside the scope of the regular expression and use it as well, so let’s do just that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">'_Z9load_user' ~~ m{ ^ '_Z'
                     :my $length;          # Put $length in the proper scope
                     (\d+) {$length = +$0} # Capture the length
                     (\w ** {$length})     # And extract that many chars.
                   };</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And reformat things just a wee bit so we’ve got some room to work with. Now the test actually runs, and reads only as many characters of the function name as needs be.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>And just one more thing…</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It’s not just function names that follow this pattern, it’s also namespaces, and any special types that the function might use as parameters, so let’s package this up into something more useful.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my regexp pascalish-string {
  :my $length;
  (\d+) {$length = +$0}
  (\w ** {$length})
};
'_Z9load_user' ~~ m{ ^ '_Z' &lt;pascalish-string&gt; };
is $/&lt;pascalish-string&gt;[0], 9;
is $/&lt;pascalish-string&gt;[1], 'load_user';</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Pascal implementations were done back when RAM was at more of a premium, and stored a string like ‘load_user’ as ‘\x{09}load_user’ so the compiler knew how many bytes were available immediately rather than having to guess. It was limiting, but this was on computers like the early Macs (we’re talking pre-OS X, for that matter pre-System 7, for those of you that remember that far back.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So we can use this&nbsp;<em>&lt;pascalish-string&gt;</em>&nbsp;regular expression anywhere we want to match one of our counted terms. Because we’re using ‘my’ inside a regular expression nested inside another regular expression inside a burrito wrapped in an enigma, there are no scoping troubles.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are probably other ways of doing this, and I would love to see them. If you do come up with a better way to solve this, let me know in the comments and I’ll work your solution into an upcoming article.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As usual, gentle reader, thank you for your time and attention, and if you have any comments, questions, clarifications or criticisms (constructive, please) let me know.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date>2019-07-24 13:10:22</wp:post_date>
		<wp:post_date_gmt>2019-07-24 11:10:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-regex-amuse-bouche</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515459]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025563538]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Templates and a Clean Start</title>
		<link>https://perlfisher.wordpress.com/2019/07/18/templates-and-a-clean-start/</link>
		<pubDate>Thu, 18 Jul 2019 11:11:17 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=75</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Before I get into the meat of the topic, which will eventually lead to a self-modifying grammar (yes, you heard me, self-modifying…) I have a confession to make, in that a series of articles on the old site may have led people astray. I wrote that series thinking to make parsing things where no grammar existed easier.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It may have backfired. So, as a penance, I’m simultaneously pointing theperlfisher.{com,net} to this new site, and starting a new series of articles on Raku programming with a different approach. This time I’ll be incorporating more of my thoughts and what hopefully will be a different approach.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Begin as you mean to go on.</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I would love to dump the CMS I’m currently using for something written in Raku. Among the many challenges that presents is displaying HTML, and to paraphrase Clint Eastwood,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.youtube.com/watch?v=_VrFV5r8cs0">I do know my limitations.</a>&nbsp;So, I don’t want to write HTML. Ideally, not ever.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, that means&nbsp;<s>steal</s>&nbsp;borrowing HTML from other sites and making it my own. Since those are usually Perl 5 sites, that means dealing with Template Toolkit. And already I can hear some of you screaming “Raku already handles everything TT used to! Just use interpolated here-docs!”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And, for the most part, you’re absolutely correct. Instead of the clunky ‘[% variable_name %]’ notation you can use clean inline interpolation with ‘{$variable-name}’, and being able to insert blocks of code inline means you don’t have to go through many of the hoops that you’re required to jump through with Template Toolkit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That’s all absolutely true, and I hope to be able to use all of those features and more in the final CMS, whatever that happens to be. This approach ignores the fact that most HTML out there is written with Template Toolkit, and that rewriting HTML, even if it’s just a few tiny tags, is an investment of time that could be better done elsewhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If only there were Template Toolkit for Raku…</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Let’s dive in!</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you’re not familiar with&nbsp;<a href="http://web.archive.org/web/20200212094016/http://template-toolkit.org/">Template Toolkit</a>, it’s a fairly lightweight programming language for writing HTML templates, among others. Please don’t confuse it with a markup language, designed to be rendered&nbsp;<strong>into</strong>&nbsp;HTML. This is a language that lets you combine your own code with a template and generate dynamic displays.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>That is a simple bit of Template Toolkit. Doesn’t look like much, does it? It’s obviously a fragment of a proper HTML document because there’s no ‘&lt;html&gt;’..'&lt;/html&gt;’ bracketing it, and obviously whatever’s between ‘[%’ and ‘%]’ is being treated specially. In this case, it’s being rendered by an engine that fills in the name, maybe something like…</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$tt.render( 'hello.tt', :name( 'Jeff' ) );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>where&nbsp;<em>hello.tt</em>&nbsp;is the name of the template file containing the previous code, and ‘Jeff’ is the name we want to substitute. We’ve got a lot of work to go through before we can get there, though. If you’ve read previous articles of mine on the subject, please try to ignore what I’ve said there.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Off the Deep End</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>First things first, we need a package to work in. For this, I generally rely on&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.perl6.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do the hard work for me. Start by installing the package with&nbsp;<em>zef</em>, and then we’ll get down to business. (It should be installed by default, if you’re still using rakudobrew please don’t.)</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">$ zef install App::Mi6
{a bit of noise}
$ mi6 new Template::Toolkit
Successfully created Template-Toolkit
$ cd Template-Toolkit</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Ultimately, we want this test (in t/01-basic.t – go ahead and add it) to pass:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;
use Template::Toolkit;
my $tt = Template::Toolkit.new;
is $tt.render( 'hello.tt', :name( 'Jeff' ) ), '&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;';</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>It’ll fail (and miserably, at that) but at least it’ll give us a goal. Also it should give us an idea of how others will use our API. Let’s think about that for a few moments, just to make sure we’re not painting ourselves into any obvious corners.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In order to be useful, our module has to parse Perl 5 Template Toolkit files, and process them in a way that’s useful in Raku. Certain things will go by the wayside, to be sure, but the core will be a module that lets us load, maybe compile, and fill in a template.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hrm, I just said ‘fill in’ rather than ‘render’, what I said above. Should I change the method name? No, not really, the new module will still&nbsp;<strong>do</strong>&nbsp;what the Perl 5 code used to, it just won’t do it using Perl 5, so some of the old conventions won’t work. Let’s leave that decision for now, and go on.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Retrograde is all the rage</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let’s apply some basic retrograde logic to what we’ve got here, given what we know of Raku tools. In order to get the string ‘&lt;h1&gt;Hello, Jeff!&lt;/h1&gt;’ from ‘&lt;h1&gt;Hello, [% name %]!&lt;/h1&gt;’, we need a lot of mechanics at work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At first glance, it seems pretty obvious that ‘[% name %]’ is a substitution marker, so let’s just do a quick regexp like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$text ~~ s:g{ '[%' (\w+) '%]' } = %args{$0};</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>That should replace every marker in the text with something from an&nbsp;<em>%arguments</em>&nbsp;hash that&nbsp;<em>render()</em>&nbsp;supplies to us. End of column, end of story. But not so fast, if all Template Toolkit supplied to us was the ability to substitute values for keys, then … there’s really no need for the module. And in fact, if you look at the docs, it can do many more things for us.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, ‘[% INCLUDE %]’ lets us include other template files in our own, ‘[% IF %]’ .. ‘[% END %]’ lets us do things conditionally, and a whole host of other “directives” are available. But you’ll see here the one thing they have in common is they all start with ‘[%’ and end with ‘%]’.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Hold the phone</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>That isn’t entirely true, and in fact there’s going to be another article in the series about that. But it’s a good starting point. We may not know much about what the language itself looks like, but I can tell you that tags are balanced, not nested, and every ‘[%’ opening tag has a ‘%]’ tag that closes it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ll also point out that directives ( ‘[% foo %]’ ) can occur one after another without any intervening white space, and may not occur at all. So already some special cases are starting to creep in.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In fact, let’s put this in as a separate test file entirely. So separate that we’re going to put it in a nested directory, in fact. Let’s open t/parser/01-basic.t and add this set of tests:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;
use Template::Toolkit::Parser;

my $p = Template::Toolkit::Parser.new;

0000, AAAA
0001, AAAB
0010, AABA
0011, AABB
0100, ABAA
0101, ABAB
... # and so on up to
1110, BBBA
1111, BBBB</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Now just HOLD THE PHONE here… we’re testing directives for Template Toolkit, not binary numbers, and whatever that other column is! Well, that’s true. We want to test text and directives, and make sure that we can get back text when we want it, and directives when we want them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At first blush you might think it’s just enough to make sure that ‘&lt;h1&gt; Hello,’ is parsed as text, and that ‘[% name %]’ is parsed as a directive, and just leave it at that. But those of you that have worked with regular expressions for a while might wonder how ‘[% name %][% other %]’ gets parsed… does it end at the first ‘%]’, or continue on to the next one?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And what about text mixed with directives? Leading? Trailing text? Wow, a lot of combinations. In fact, if you wanted to be thorough, it wouldn’t hurt to cover all possible combinations of text and directives up to… say, 4 in a row.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s call text ‘T’, and directives ‘D’. I’ve got 4 slots, and only two choices for each. Filling the first slot gives me ‘T_ _ _’ and ‘D_ _ _’, for two choices. I can fill the next slot with ‘T T _ _’, ‘T D _ _’, ‘D T _ _’, and ‘D D _ _’, and I think you can see where we’re going with this.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In fact, replace T with 0 and D with 1, and you’ve got the binary numbers from 0000 to 1111. So, let’s take advantage of this fact, and do some clever editing in our editor of choice:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">0010, 0010                            =&gt;
is-deeply the-tree( '0010, AABA       =&gt;
is-deeply the-tree( '0010' ), [ AABA  =&gt;
is-deeply the-tree( '0010' ), [ AABA ];</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>A few quick search-and-replace commands should get you from the first line to the last line. Now it’s looking more like a Raku test, right? We’re not quite there yet, ‘0010’ still doesn’t look like a string of text and directives, and what’s this AABA thing? One more search-and-replace pass, this time global, should solve that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">is-deeply the-tree( '0010' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx1x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ AABA ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ), [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
          [ 'a', 'a', B'a', ]; =&gt;
is-deeply the-tree( 'xx[% name %]x' ),
    [ 'a', 'a', Directive.new( :content( 'name' ) ), 'a', ];</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Starting out with the padded binary numbers covers every combination of text and directive possible (at least 4 long). A clever bit of search-and-replace in your favorite editor gives us a working set of test cases that check a set of “real-world” strings, and a file you can almost run. Next time we’ll fill in the details, and get from zero to a minimal (albeit working) Template Toolkit implementation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As always, dear reader, feel free to post whatever comments, questions, and/or suggestions that you may have, including ideas for future articles. I read and respond to every comment, and thank you for your time.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>75</wp:post_id>
		<wp:post_date>2019-07-18 13:11:17</wp:post_date>
		<wp:post_date_gmt>2019-07-18 11:11:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>templates-and-a-clean-start</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515515]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025589769]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Logic Programming in Raku</title>
		<link>https://perlfisher.wordpress.com/2019/06/21/logic-programming-in-raku/</link>
		<pubDate>Fri, 21 Jun 2019 11:12:10 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=78</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>This is a small example of conference-driven development. I’m sitting in the board room at TPCiP – TCP in Pittsburgh surrounded by people doing both Perl 5 and Raku programming, and decided to look again at Picat, working on some simple examples. I was thinking that I might be able to translate some of the simpler backtracking examples from Picat to Raku and here’s a simple example.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>First the Picat code:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">fib(0,F) =&gt; F=1.
fib(1,F) =&gt; F=1.
fib(N,F),N&gt;1 =&gt; fib(N-1,F1),fib(N-2,F2),F=F1+F2.</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Now here’s my equivalent Raku code:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi fib( 0, $F is rw ) { $F = 1 }
multi fib( 1, $F is rw ) { $F = 1 }
multi fib( $N is rw where * &gt; 1, $F is rw ) {
  my ( $F1, $F2 ) = 0, 0;
  my $N1 = $N - 1;
  my $N2 = $N - 2;
  fib( $N1, $F1 ) &amp;&amp; fib( $N2, $F2 ) &amp;&amp; $F = $F1 + $F2
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The Raku version is slightly larger because I need to declare some variables that Picat would ordinarily declare for me ($F1, $F2). There may be a way to work around declaring ($N1, $N2), but otherwise the two versions are identical.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>How does it work?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You’ve probably guessed based on the inputs that&nbsp;<em>N</em>&nbsp;is index of the Fibonacci number, and&nbsp;<em>F</em>&nbsp;is the Fibonacci number itself. Picat doesn’t require you to declare variables, so you could ask it for the 7th Fibonacci number by calling fib(7,F) and looking at&nbsp;<em>F</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $Fib = 0;
fib(7,$Fib);
say $Fib     # 21</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Or you could do the above in Raku, letting the code populate&nbsp;<em>$Fib</em>&nbsp;for you. This code relies on the fact that Raku lets you dispatch not just on signatures, not just on argument types, but on&nbsp;<strong>values</strong>. Look at the base case above:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi fib( 0, $F is rw ) { ... }</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p><em>fi</em>b(…) is the function signature, and this function will get called whenever the first argument is 0, like so: fib(0, $Fib). This happens even if ‘multi fib( $N, $F )’ is the one doing the calling, everything gets run through the same dispatcher each time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So fib(2, $Fib) calls fib(1, $Fib) which calls ‘multi fib( 1, $F )’ and gives us a base case, for example. This lets the higher-order functions call our base cases, and still get the right value.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>What are we missing?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Well, the Picat code can do something the Raku code can’t, at least for the moment, and this is what I want to spend some time working on. In Picat, I can call ‘fib(6,F)’ and&nbsp;<em>F</em>&nbsp;will be 13 when the code is done. This works in Raku too.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But Picat will also let you call ‘fib(N,21)’ and&nbsp;<em>N</em>&nbsp;will be 7 when the calculation is finished. Take some time to let that settle. Yes, you can run the calculation both forward and backward. Give&nbsp;<em>N</em>&nbsp;a value, and&nbsp;<em>F</em>&nbsp;will be the Nth Fibonacci number. Give F a value, and it will tell you what&nbsp;<em>N</em>&nbsp;is.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In fact, Picat will go one step further. If you don’t specify a value for either parameter but just specify variables, like ‘fib(N,F)’, then it will generate all the Fibonacci numbers and their indexes until you tell it to stop.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is because of the backtracking engine that it uses, which I want to see if I can mimick. ‘F=F1+F2’ doesn’t mean “Assign the sum of F1 and F2 to F”. Instead, “If any values are missing, find values that satisfy the equation, and keep generating them until you run out of possibilities.”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That’s a bit of a mouthful, so let’s look at just&nbsp;<em>F1</em>. Supposing F=8 and F2=5, the backtracking engine would search all values of&nbsp;<em>F1</em>, and return just the matching value of 3. Now of course, it can’t search&nbsp;<strong>all</strong>&nbsp;values, because that means you’d be waiting forever, so there are pruning algorithms at work here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But the same logic can work with any combination of arguments, so if both&nbsp;<em>F1</em>&nbsp;and&nbsp;<em>F2</em>&nbsp;were missing, then the backtracking engine would run through all possible combinations of values (pruned appropriately) until it found a combination that would work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this case, since in our example F=8, it would return a bunch of combinations, starting with (F1=1, F2=7), (F1=2, F2=6) and so on. But why, then, you ask, does it only return (F1=3, F2=5)? That’s because each value&nbsp;<em>F1</em>&nbsp;<strong>also</strong>&nbsp;has to satisfy fib(N1,F1), which means that&nbsp;<em>F1</em>&nbsp;has to be a Fibonacci number, as does&nbsp;<em>F2</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Breakdown</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This is the part where Raku breaks down a little bit. But what I think I might be able to do is use a trick I used a while ago, relying on the fact that operators are just functions, and they dispatch just like other functions. So I should be able to start out with something crude like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $F = Operator.new( :lhs(3) );
my Value ($F1, $F2);
$F = $F1 + $F2;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This way both&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;are bound to backtracking Values, they return a Operator, and the Operator is part of the backtracking engine. This way once the Operator engine determines the range of possible combinations of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>&nbsp;that add to 3, it can assign them concurrently to&nbsp;<em>@F1.value</em>&nbsp;and&nbsp;<em>@F2.value</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Smooth Operators</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The Operator and Value classes, along with their overloaded operators, would look something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Operator {
  has ( $.lhs, $.rhs ); }
class PlusOperator is Operator { }
class AssignmentOperator is Operator {
  method make-combinations() {...} }
class Value {
  has @.value }
multi infix:&lt;=&gt;( Operator $lhs, Operator $rhs ) {
  AssignmentOperator.new( :$lhs, :$rhs );
}
multi infix:&lt;+&gt;( Value $lhs, Value $rhs ) {
  PlusOperator.new( :$lhs, :$rhs );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This is purely a sketch that I haven’t tried out at all. My idea here is that once you’ve executed ‘$F = $F1 + $F2’,&nbsp;<em>$F</em>&nbsp;will be an&nbsp;<em>AssignmentOperator</em>&nbsp;instance. You should be able to call&nbsp;<em>$F.make-combinations()</em>&nbsp;that will solve the equation ‘3 = $F1 + $F2’ for all (constrained) values of&nbsp;<em>$F1</em>&nbsp;and&nbsp;<em>$F2</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That would populate&nbsp;<em>@F1.values</em>&nbsp;and&nbsp;<em>@F2.values</em>&nbsp;with (1,2) and (2,1) respectively. I’m about to play my first game of&nbsp;<em>Azul</em>, so I’ll leave the article here. The next article will hopefully implement this so you can see this all working. It won’t quite be a true backtracking engine, but it’s a start.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Dear Reader, thank you for your attention, and please feel free to add comments, questions and suggestions.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>78</wp:post_id>
		<wp:post_date>2019-06-21 13:12:10</wp:post_date>
		<wp:post_date_gmt>2019-06-21 11:12:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>logic-programming-in-raku</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515559]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025611737]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Quantum Tunneling</title>
		<link>https://perlfisher.wordpress.com/2019/05/20/quantum-tunneling/</link>
		<pubDate>Mon, 20 May 2019 11:12:46 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=81</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Introducing the new Perl Fisher site</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before I get on to the meat of the article, welcome to the new home of The Perl Fisher. I intend to cover both Perl 5 and Raku programming here, but it’ll be mostly Raku content because that’s the language I find the most fun. Please excuse the dust, I’m still very much settling into the new home, and the overall look of the site is bound to change while I play with the new toys available to me.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Defeating Thanos with Raku</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Don’t worry, no spoilers here. We’re just going to talk about a little-known feature of Raku, the quantum-tunneling variable type. If you’ve worked with Raku for any length of time, you’ve probably seen or written a class declaration that looks something like below.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Point2D {
  has Real $.x;
  has Real $.y;
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>While the word ‘has’ does the real work, second-sigil syndrome strikes as well, in the shape of the ‘.’ between the scalar sigil ‘$’ and the variable name. Here it’s syntactical sugar for being an attribute name, but we can enlarge that ‘.’ to a ‘*’ and open up a world of possibilities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we add the ‘*’ sigil to a variable name, we turn that variable into one that can quantum tunnel between scopes and solve problems that you probably used to do with a global variable. You can read more about dynamic variables and how they differ from ordinary globals at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.perl6.org/language/variables#The_*_twigil">The_*_twigil</a>at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/">docs.raku.org</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Testing, testing</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I’m working on a project to try to augment the Raku grammar debugger with an emulator. The tools we have on CPAN and modules.perl6.org respectively are wonderful, but they’re limited because Raku compiles grammar rules down to single methods, which is wonderful for speed, but makes it almost impossible to look into.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The grammar I’m writing isn’t important at the moment, but the testing part is. Below is a sample subtest that I’m writing for each term of a grammar that’s probably going to have ~50 terms by the time I’m done.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
    ok fails( '3g', 'binary-number' );
  };

  is build-ast( '0101', 'binary-number' ), 5;
};</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This tests the ‘binary-number’ rule to see if it properly fails on ‘0b’ and ‘3g’. ‘0b’ fails because it’s the&nbsp;<strong>prefix</strong>&nbsp;of a binary number, and ‘3g’ because neither 3 nor ‘g’ are binary digits. It also makes certain that ‘0101’ gets translated into the decimal number 5. All important when testing a grammar that parses … well, itself eventually. Oroborous redux, as it were.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Dry up, will you…</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The test is simple, and straightforward. ‘0b’ should fail, ‘0101’ should be built into a node of an abstract syntax tree. But it’s got some flaws. It talks too much. See how ‘binary-number’ repeats itself? If I want to copy that, rename it to ‘hex-number’ and add a few changes, I have to copy the block, rename all the incidences of ‘binary-number’ to ‘hex-number’ and&nbsp;<strong>then</strong>&nbsp;fix the existing tests.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus I run the risk of forgetting to update the name ‘binary-number’. And there’s an even greater bugaboo there. If I&nbsp;<strong>don’t</strong>, the test won’t fail. Because the subtest doesn’t know that it’s supposed to be testing the ‘binary-number’ rule. There are a bunch of ways to solve this problem, of course, but for this post we’re going to use Ant-Man(tm).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Entering the Quantum Realm</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I don’t want to do&nbsp;<strong>too</strong>&nbsp;much work here, I just want to get rid of the duplicate ‘binary-number’ entries. So, let’s take a look at what&nbsp;<em>fails()</em>&nbsp;does.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub fails( Str $sample, Str $rule-name ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The ‘!?(…)’ casts&nbsp;<em>$g.parse(…)</em>&nbsp;to a Boolean and negates it, so if&nbsp;<em>$g</em>&nbsp;can’t parse the statement, it returns&nbsp;<em>True</em>. So, first let’s make&nbsp;<em>$rule-name</em>&nbsp;optional.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $rule-name ) );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":4} -->
<h4>Opening the wormhole</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now, we’re going to summon Ant-Man(tm). Remember earlier I mentioned that quantum variables use a wormhole? Well, we’re going to open one end of the wormhole right here in our&nbsp;<em>fails()</em>&nbsp;function, just like this.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Rerun our tests, and … wait, they should fail, we haven’t declared&nbsp;<em>$*ANT-MAN</em>&nbsp;anywhere! Well, just like in quantum physics,&nbsp;<em>$*ANT-MAN</em>&nbsp;doesn’t have enough energy to tunnel over the quantum barrier because we haven’t defined him yet.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So let’s do that, but remember that&nbsp;<em>$*ANT-MAN</em>&nbsp;is a quantum variable, so he can tunnel through the quantum barrier of a function scope. In fact, he can tunnel through any number of them. So, let’s define a new version of&nbsp;<em>subtest()</em>&nbsp;that looks and acts like the old one first before we go boldly where no Raku programmer has gone before.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub Subtest( Str $rule-name, Block $test-code ) {
  subtest $rule-name, $test-code;
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We should be able now to replace the outer&nbsp;<em>subtest()</em>&nbsp;block with our new&nbsp;<em>Subtest()</em>&nbsp;block, and it should act just as it used to.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">Subtest 'binary-number', {
  subtest 'failing', {
    ok fail( '0b', 'binary-number' );
    ...
  };
  ...
};</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":4} -->
<h4>Tunneling through</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Our test suite still works, and the output still is what we expect. Now, let’s give&nbsp;<em>$*ANT-MAN</em>enough energy to tunnel through the quantum barrier by defining him as the subtest name we want:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And now run our test suite. Which… doesn’t change. Come to think of it, we don’t want it to change. If it&nbsp;<strong>did</strong>&nbsp;change, we’d have to go through and change all of our test suites, which would be bad. So, putting things together, this code works just fine.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub fails( Str $sample, Str $rule-name? ) returns Bool {
  !?( $g.parse( $sample, :rule( $*ANT-MAN // $rule-name ) );
}
sub Subtest( Str $rule-name Block $test-code ) {
  my $*RULE-NAME = $rule-name;
  subtest $rule-name, $test-code;
}

Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b', 'binary-number' );
  };
};</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Notice by the way that&nbsp;<em>$*ANT-MAN</em>&nbsp;has tunneled through not one but&nbsp;<strong>two</strong>&nbsp;function signatures to get to where he is. And to prove it, finally, delete the inside ‘binary-number’.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">Subtest 'binary-number', {
  subtest 'failing', {
    ok fails( '0b' );
  };
};</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>So ‘binary-number’ gets passed along to&nbsp;<em>$*ANT-MAN</em>&nbsp;who jumps into the quantum realm, tunnels through the outer&nbsp;<strong>and</strong>&nbsp;inner pairs of braces, and finally lands in&nbsp;<em>fails()</em>&nbsp;where he passes the value on to the :rule() declaration. Whew, that’s a lot of work.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Oh, snap.</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>(sorry, couldn’t resist.) If you’re like me, and I know&nbsp;<em>I</em>&nbsp;am, you’ve probably come across a few cases where this technique would come in handy. Especially if you’re dealing with legacy code. Sometimes you need to add just one little flag to a function and set that flag in a top-level handler on one page of a website.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The catch is that between the lower level and the top level there’s a chain of 8 function calls where you have to add that as a parameter. Wouldn’t it be nice if there was a workaround? Well, in Raku there is.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thanks for getting all the way to the bottom of this, my inaugural article on Raku on the next generation of the Perl Fisher website. Feel free to leave comments and constructive criticism in the comments section below, and come back every so often to watch the website grow over the coming months.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>81</wp:post_id>
		<wp:post_date>2019-05-20 13:12:46</wp:post_date>
		<wp:post_date_gmt>2019-05-20 11:12:46</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>quantum-tunneling</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025634676]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515603]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Spacing Out</title>
		<link>https://perlfisher.wordpress.com/2019/04/12/spacing-out/</link>
		<pubDate>Fri, 12 Apr 2019 11:17:13 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=84</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>After having had some comments about the grammar approach I’ve been using, I’ve started to rethink things. I may have isolated at least one problem people may have been having. I’m working on a grammar for a language called ‘picat’ – you can look up a quick explanation at&nbsp;<a href="http://web.archive.org/web/20190814083216/http://www.picat-lang.org/">picat.org</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It’s a constraint-based programming language that maps insanely well onto Perl 6. A fragment of the grammar I’m working on follows, done in a top-down fashion. The actual grammar rule&nbsp;<em>&lt;comment&gt;</em>&nbsp;isn’t the important thing, because this problem can occur with anything.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you must know, it’s a C-style /* .. */ comment. Of course I ran the test to make sure this little block of code properly matched beforehand. This way I could go along making one small change at a time, simple because it’s fairly late at night and I’ve got a flight to catch tomorrow..&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">&lt;comment&gt;
&lt;comment&gt;
&lt;comment&gt;

'go' '=&gt;'
   'doors(10).'</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":3} -->
<h3>Breaking up is hard to do</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The natural thing to do here is, of course, say to yourself “Hrm, I’ve got 3&nbsp;<em>&lt;comment&gt;</em>&nbsp;comment blocks in a row. We all know there are only 3 important numbers in computer science, 0, 1, and Infinity. So 3 is wrong and should be replaced with&nbsp;<em>&lt;comment&gt;+</em>.”&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">&lt;comment&gt;+

'go' '=&gt;'
   'doors(10).'</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>I then rerun the test, because I’m sticking to my nighttime rule of “one change, one retest”, and to my horror it breaks. I’ve only changed one thing, but … why is it breaking? Surely &lt;A&gt;+ should at&nbsp;<strong>least</strong>&nbsp;match &lt;A&gt; &lt;A&gt; &lt;A&gt; … that’s how DFA equivalences work in finite automata.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That’s also one point where Perl 6 and traditional DFAs (Deterministic Finite Automata) part ways. After a few years of doing Perl 6 programming, I see Perl 6 as almost overly helpful. Tools like&nbsp;<em>flex</em>&nbsp;and&nbsp;<em>bison</em>&nbsp;made me think of grammars as something that belonged outside the language.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Where it all breaks down</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Unfortunately modules like&nbsp;<a href="http://web.archive.org/web/20190814083216/https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a>, through&nbsp;<strong>no</strong>&nbsp;fault of their own, can’t quite help here. While it’s a great module to tell you what particular rule or token failed, the problem here is&nbsp;<strong>between</strong>&nbsp;the terms.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>&lt;A&gt; {whitespace-optional} &lt;A&gt; is subtly different than &lt;A&gt;+ because &lt;A&gt; &lt;A&gt; lets the parser read whitespace between the two terms; &lt;A&gt;+ assumes the terms come one after the other, whitespace be darned.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the simplest solution I have to offer is to let the comment eat the whitespace after it as well, so you can insert your &lt;comment&gt; token anywhere you like and it’ll still eat the whitespace no matter how you add it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another solution proposed on Reddit would be to use &lt;A&gt;˽+, with a space between the closing ‘&gt;’ and the modifier. Said user went beyond the call of duty and composed a “Seven stages of whitespace” post to make the point.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The &lt;comment&gt; token I have, like I said, is for C/C++ style “balanced” comments. Here they’re not balanced; /* This is a comment */ but this is not */, and/* This is a comment /* so is this */ this looks like it should but really isn’t. */&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">token comment
  {
  '/*' .+? '*/' \s*
  }</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And all is well with the grammar. You can put this rule anywhere you like and it’ll behave whether you write &lt;comment&gt; &lt;comment&gt; or &lt;comment&gt;+. This little article was inspired by a Twitter user inspired after reading my first tutorial series. They got into the actual work of creating a grammar and problems started to happen.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Wrapping up</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>My original tutorial series was just that, a tutorial, I felt that getting too deep into the process interrupts the flow, so I didn’t talk about the work that went into it. Now that the series is pretty much done, I think it’ll be beneficial to talk about the actual problems of debugging one of these beasts.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And these thing can most definitely be beasts. Using my&nbsp;<a href="http://web.archive.org/web/20190814083216/https://github.com/drforr/perl6-ANTLR4">ANTLR4 to Perl 6 converter</a>&nbsp;you can generate some incredibly huge grammars. But just generating them doesn’t necessarily mean they’ll compile, although a few do right out of the box, which I’m genuinely amazed at.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The full test suite actually chooses a few grammars, converts them to Perl 6, compiles them and tests against sample input. I’m not sure how faithful they are to the real grammar, but they work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perl 6 does amazing things with precompiling and JITing. Grammars and regular expressions are one of the hardest-working things in Perl 6, so they get compiled down to functions. This means I can’t step into them even inside NQP, the dark side of Perl 6.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve got ideas, so I’m going to keep working on grammar stuff. That means when I run into problems, well, it’s time to write another article. So look forward to a new series. Likely with a prosaic name of “Perl 6 Grammars Debun^wDebugged” or something similar. Thank you again, dear reader. Comments, clarifications and questions are of course welcome.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>84</wp:post_id>
		<wp:post_date>2019-04-12 13:17:13</wp:post_date>
		<wp:post_date_gmt>2019-04-12 11:17:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>spacing-out</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025880944]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515996]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Who ordered that (array)?</title>
		<link>https://perlfisher.wordpress.com/2018/03/14/who-ordered-that-array/</link>
		<pubDate>Wed, 14 Mar 2018 12:20:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=88</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>ou know how it is when coming back to some code after days, weeks or in this case, maybe even months away? I'm going through that right now, and thought I'd talk about one issue I just ran into. While reworking the actions for the ANTLR4 translator, I&nbsp;<strong>really</strong>&nbsp;don't want to rewrite the grammar. It passes the full ANTLR4 corpus, and I don't want to touch that.<br>So I've just finished rewriting a bunch of tests, and am ready to capture ANTLR tokens so that I can rewrite them into Perl 6. The match object looks like this when you dump it ("dump" is a bit overblown - in other languages you might need a separate Dump() method, in Perl 6 "say $/" is all you need.):</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">prequelConstruct =&gt; ｢tokens { INDENT }｣
 tokensSpec =&gt; ｢tokens { INDENT }｣
  token_list_trailing_comma =&gt; ｢INDENT ｣
   tokenName =&gt; ｢INDENT｣
    ID =&gt; ｢INDENT｣</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>But when I started trying to capture the 'INDENT' text with <em>$/&lt;prequelConstruct&gt;&lt;tokensSpec&gt;&lt;token_list_trailing_comma&gt;</em>, I get this weird error:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">Type Array does not support associative indexing.
  in method TOP at /home/jgoff/perl6-ANTLR4/lib/ANTLR4/Actions/Perl6.pm6 (ANTLR4::Actions::Perl6) line 88</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>But... but... it's just&nbsp;<em>prequelConstruct</em>&nbsp;containing a&nbsp;<em>tokensSpec</em>&nbsp;and so on, I don't see any arrays involved. Now, if I were using 'dd' rather than the built-in stringifier I'd probably see the problem right away. Unfortunately if you're using the default 'say $/' stringifier, there's no easy way to see what's going on. What's happening here is the&nbsp;<em>prequelConstruct</em>&nbsp;actually contains an&nbsp;<strong>array</strong>&nbsp;of matches, but the default 'say' output won't show you this.<br>Thankfully, Perl 6, just like its sister Perl 5, encourages experimentation. If you back off and just use 'say $/&lt;prequelConstruct&gt;;', that will work. When you add '&lt;tokensSpec&gt;', which&nbsp;<strong>looks like</strong>&nbsp;what should be the next layer down, you'll get the 'Type Array...' error, which will tell you that&nbsp;<em>prequelConstruct</em>&nbsp;contains an array of stuff. 'dd' should tell you more clearly what portion of the match is an array, and what are hash keys, and I'd recommend using that to clarify what's going on. This is just a little posting to help people debug what I suspect is a common confusion.<br>Thank you again, dear reader. Comments, clarifications and questions are of course welcome.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>88</wp:post_id>
		<wp:post_date>2018-03-14 13:20:02</wp:post_date>
		<wp:post_date_gmt>2018-03-14 12:20:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>who-ordered-that-array</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025903223]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516044]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Abusing multiple-dispatch creatively</title>
		<link>https://perlfisher.wordpress.com/2018/01/11/abusing-multiple-dispatch-creatively/</link>
		<pubDate>Thu, 11 Jan 2018 12:20:54 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=91</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>As part of creating a new POD tree for the Perl 6 utilities in hopes of letting others create their own subclasses, I came across this interesting use of multiple-dispatch. One of the Pod types that the Perl 6 compiler generates is for inline attributes like making&nbsp;<strong>text bold</strong>&nbsp;or&nbsp;<em>italic</em>&nbsp;with formatting codes like 'B&lt;text bold&gt;'. Bold, italic, and underline formatting codes all generate the same&nbsp;<em>Pod::FormattingCode</em>&nbsp;object, with a different&nbsp;<em>.type</em>&nbsp;value, so they look something like</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Pod::FormattingCode {
  has Str $.type; # This is 'B', 'I', etcetera as the need arises.
}
class Pod::FormattingCode::Bold { }</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>I have a bunch of&nbsp;<em>.to-node()</em>&nbsp;methods that are specialized on turning raw Pod objects into something a little more useful. One of these, to convert a&nbsp;<em>Pod::FormattingCode</em>&nbsp;into my internal&nbsp;<em>Node::FormattingCode::Bold</em>&nbsp;object, looks like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi method to-node( Pod::FormattingCode $pod ) {
  given $pod.type {
    when 'B' {
      Node::FormattingCode::Bold.new( :type( $pod.type ) )
    }
  }
}

my $bold = Pod::FormattingCode.new( :type( 'B' ) );
self.to-node( $bold ); # Calls the multi method above.
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>All of the methods that convert $something to a node are named&nbsp;<em>.to-node()</em>, and I can rely on Perl 6's multiple dispatch to keep them separate for me. This is important to me mainly because of locality of reference. If you're debugging my code, and you want to know where something gets converted to a&nbsp;<em>Node::</em>&nbsp;object, just look through the&nbsp;<em>.to-node()</em>&nbsp;methods. Now, looking at the&nbsp;<em>given-when</em>&nbsp;block, that's going to grow, and by quite a bit. At least three lines for every formatting code that I find in the documentation.<br>And it gets a bit worse. Say I want to do the right thing, and factor out the '.new(...)' lines into their own method, because I'm pretty sure they'll grow, as I find neat little corner cases for each of the Pod types. I'd have to name them something ugly, which breaks up my idea.<br>Since the method still converts a&nbsp;<em>Pod</em>&nbsp;object to a&nbsp;<em>Node</em>&nbsp;object, it'd be nice to be able to reuse the&nbsp;<em>.to-node()</em>&nbsp;method, but to fit it into the existing scheme of things I"d have to create a new object like a&nbsp;<em>Pod::FormattingCode::Bold</em>, create a new instance of that, and then I'd be able to do multiple-dispatch on&nbsp;<strong>that</strong>&nbsp;type. But that means creating not one but&nbsp;<strong>two</strong>&nbsp;new classes for every&nbsp;<em>Pod::FormattingCode</em>&nbsp;- one for the "shim" that I use to dispatch on, and another one for the actual object I'm going to return to the user. And it's even&nbsp;<strong>worse</strong>than that, because it's possible, though very unlikely, that the Perl 6 team will one day create a&nbsp;<em>Pod::FormattingCode::Bold</em>&nbsp;class and trounce on my own name-space, undoing my hard work.<br>Well, as you might have guessed, there&nbsp;<strong>is</strong>&nbsp;a solution, and it doesn't involve trouncing on anyone's namespaces. And it&nbsp;<strong>still</strong>&nbsp;lets us stick to the principle of reusing&nbsp;<em>.to-node()</em>&nbsp;for all of our node-conversion needs. Here's how you write it:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi method to-node( Pod::FormattingCode $pod ) {
  self.to-node( $pod, $pod.type );
}
multi method to-node( Pod::FormattingCode $pod, 'B' ) {
  Node::FormattingCode::Bold.new( :type( 'B' ) );
}

my $bold = Pod::FormattingCode.new( :type( 'B' ) );
self.to-node( $bold ); # Returns a Node::FormattingCode::Bold object.
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>What this does may not be obvious at first glance, so I'll walk through it. We create a&nbsp;<em>Pod::FormattingCode</em>&nbsp;object of type 'B' for Bold, and magic happens. The first magical bit is that multiple-dispatch kicks in, so that when&nbsp;<em>.to-node()</em>&nbsp;gets called, Perl 6 does its best to find the closest signature. And in this case it's a perfect match.&nbsp;<em>.to-node( Pod::FormattingCode )</em>&nbsp;is perfectly matched by the first method. Inside&nbsp;<strong>that</strong>&nbsp;method, we do something a little sneaky. We break out the type, and rely&nbsp;<strong>again</strong>&nbsp;on multiple dispatch. This time we're calling&nbsp;<em>.to-node( Pod::FormattingCode $pod, 'B' )</em>, and&nbsp;<strong>again</strong>&nbsp;we have a perfect match, but this time it's the second method, down below. That creates the new&nbsp;<em>Node::FormattingCode::Bold</em>&nbsp;object and returns it.<br>How did that work, you might ask? Well, multiple dispatch in languages like C++ or Java work based on types. You can&nbsp;<strong>sort of</strong>&nbsp;simulate what we just did in C++ with templates, and Java's generic&nbsp;<strong>sort of</strong>&nbsp;do what we did, but not quite, and with much more work. TL;DR Perl 6's multiple dispatch works on argument&nbsp;<strong>values</strong>&nbsp;as well as types, so you can dispatch both on a generic&nbsp;<em>Str</em>&nbsp;class as well as a specific instance "foo" of&nbsp;<em>Str</em>. This means you can write Haskell-like code in Perl 6.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi sub fib( $n where * &lt; 0 ) { 0 }
multi sub fib( 0 ) { 0 }
multi sub fib( 1 ) { 1 }
multi sub fib( $n ) { fib( $n - 1 ) + fib( $n - 2 ) }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The&nbsp;<em>where</em>&nbsp;declaration there lets us cleanly handle negative values as well, as a bonus. No matter what (integer) value the client passes to the&nbsp;<em>fib</em>&nbsp;subroutine, Perl 6 will dispatch it cleanly, so that&nbsp;<em>fib(2)</em>&nbsp;will call&nbsp;<em>sub fib(1)</em>&nbsp;and return 1, rather than calling&nbsp;<em>sub fib($n)</em>&nbsp;and going into an infinite regress. I was just working along on&nbsp;<em>Pod::To::Tree</em>, did that particular bit of refactoring and thought you might like to hear about it. This is your friendly neighborhood Perl Fisher, signing off.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>91</wp:post_id>
		<wp:post_date>2018-01-11 13:20:54</wp:post_date>
		<wp:post_date_gmt>2018-01-11 12:20:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>abusing-multiple-dispatch-creatively</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025926144]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516097]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Tree Surgery</title>
		<link>https://perlfisher.wordpress.com/2018/01/07/tree-surgery/</link>
		<pubDate>Sun, 07 Jan 2018 12:21:47 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=94</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>HTML and I tend to get along like a house on fire. I can work with it when the need arises, but I still prefer to do semantic markup and let CSS do with it what the end-user wants to see, which these days is shiny sidebars, blogroll posts and code blocks that neatly let the user just drag-and-select the text they want and copy it into their editor of choice.<br>As you can see by this posting, I haven't quite gotten there yet. Equally, you can see that I haven't given up altogether, because I'm still here, posting and tweaking things. A couple of months ago (okay, it just&nbsp;<strong>feels</strong>&nbsp;that way) I figured out that it'd be much simpler for me to take a Perl 6 POD document and add the markup that I need to that.<br>After some pondering I realized "Wait, isn't there already a Perl 6 POD converter out there? Called&nbsp;<em>perl6 --doc</em>? And can't I re-purpose what it does to generate Blogspot-ready HTML?"<br><a href="http://web.archive.org/web/20190103092939/https://github.com/perl6/Pod-To-HTML">Pod::To::HTML</a>&nbsp;already is out there, but the way the code is written made it hard if not impossible to subclass, because most of the important stuff was inside&nbsp;<em>sub</em>&nbsp;blocks, not out in&nbsp;<em>method</em>s where they could easily be sub-classed.<br>So I started rewriting it. A few days later, after grumbling and wondering why&nbsp;<strong>this</strong>&nbsp;particular bit had been written the way it was, I went onto the usual suspect&nbsp;<a href="http://web.archive.org/web/20190103092939/https://perl6.org/community/irc">Perl IRC</a>&nbsp;channel where the author likely hung out, so I could get a useful answer. He wasn't around, but someone pointed me to another module,&nbsp;<a href="http://web.archive.org/web/20190103092939/https://github.com/houseabsolute/perl6-Pod-TreeWalker">Pod::TreeWalker</a>, and told me that he too was interested in fixing this.<br>So, as things happen, conversation started. I rewrote the guts of what I had with&nbsp;<a href="http://web.archive.org/web/20190103092939/https://github.com/houseabsolute/perl6-Pod-TreeWalker">Pod::TreeWalker</a>, and found that it did some things I really didn't want it to. All I wanted... hoo boy. I know that phrase all too well, it usually means I'm going to end up rewriting some module only to run into the problems&nbsp;<strong>they</strong>&nbsp;encountered. Well, once more into the breach, and all that.<br>So, I decided that while I liked&nbsp;<a href="http://web.archive.org/web/20190103092939/https://github.com/houseabsolute/perl6-Pod-TreeWalker">Pod::TreeWalker</a>'s style - it's an event-driven system, it did place some limitations on how you could work with it. For example, when a pod-table-start event came along, it was pretty easy to figure out "Hey, this is the start of a POD table, so I can generate a `&lt;table&gt;' string and add it to my running HTML." And this worked fine, for all of about 20 minutes. Because it also generated other events in places where I didn't think it should, such as paragraphs inside a list item, which made the generated HTML look odd.<br>For instance,</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">=item foo</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>generates this sequence, when marshalled back out to HTML:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">&lt;li&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/li&gt;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>What's happening here is that the library sends out:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>An 'item-start' event, so I tack on '&lt;li&gt;' to the HTML.<ul><li>A 'paragraph-start' event, so I tack on '&lt;p&gt;' to the HTML.</li><li>A 'text' event, with 'foo' as the txt, so I tack on 'foo'.</li><li>A 'paragraph-end' event, so I tack on '&lt;/p&gt;' to the HTML.</li></ul></li><li>An 'item-end' event, so I tack on '&lt;/li&gt;' to the HTML.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Now, as I've mentioned earlier, I didn't particularly like the fact that the sequencer created a paragraph event, when there's no particular need to do so. But I'm stuck with it. I still have possibilities, though. I can...</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Post-process the HTML and do a quick regex to remove the &lt;p&gt;..&lt;/p&gt; tags, but, and repeat after me, friends don't let friends run regex on HTML.</li><li>When a 'paragraph-start' event is encountered, see if the HTML has &lt;li&gt; already there, and ignore it if so. But see #1.</li><li>Hack the module to pass along the "parent" event when firing off an event, so I could look at the "parent" event and if that's a paragraph, ignore it.</li><li>Wait a minute, parent... &lt;digs_through_source/&gt; it's already got a tree of POD it's walking, if I pull out just the tree, then it's actually&nbsp;<strong>less</strong>&nbsp;code to walk the tree, and when I encounter the &lt;p&gt; node I can tell it to look at its parent... right.</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Armed with this realization, I sally forth. Lucky for me, Perl 6 POD is already laid out as a tree, so it's pretty simple to start walking it. Now, there are a bunch of straightforward ways to write a walker like this, but I rather prefer to use the multiple-dispatch features of Perl 6 for this purpose.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method walk( $node ) {
  self.visit( $node );
  if $node.^can('contents') {
    for @( $node.contents ) -&gt; $child {
      self.walk( $child );
    }
  }
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>POD nodes are laid out in a pretty simple fashion. They're either "leaves" like text blocks (our infamous paragraph contents) or they're shells, like a list of items. An easy way to tell whether a node is a leaf or not is whether it has 'contents', and we do that by the "^can('contents')" test. Just calling the method directly would work as well, but every time we called it on a leaf node, we'd get a runtime error. Not good.<br>Once you know that bit, the code sort of falls into place.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Visit $node (AKA "do something with it", like print its text)</li><li>If it's got children:<ul><li>For each child (that's the "@( $node.contents ) -&gt; $child" bit)</li><li>Walk over that child.</li></ul></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So your user-declared&nbsp;<em>visit()</em>&nbsp;method will get called once on every node in the entire tree, in a depth-first search, so it's in the perfect order to return HTML to you. Well, almost, but the exceptions aren't worth talking about.<br>Great, we can walk the tree in depth-first order, and we've got a handy&nbsp;<em>visit()</em>&nbsp;method that'll do something. We can even add a&nbsp;<em>$.html</em>&nbsp;attribute that we can accumulate our HTML into as we go along, problem solved!</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has Str $.html;
method visit( $node ) {
  if $node ~~ Pod::Table {
    $.html ~ '&lt;table&gt;'; # .. hey, wait a minute...
  }
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Hold the phone, this just tells me when we've encountered, say, a Table node. I wanted to be able to write something when a table starts, and when it ends. And I wanted to know what the table's parent was, like we talked about lo those many paragraphs ago.<br>No worries, we're really close, honest. I'll change the&nbsp;<em>walk()</em>&nbsp;method just to show you.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method walk( $node, $parent = Nil ) {
  self.start-node( $node, $parent );
  if $node.^can('contents') {
    for @( $node.contents ) -&gt; $child {
      self.walk( $child, $node );
    }
  }
  self.end-node( $node, $parent );
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The '= Nil' is a handy shortcut so that you can call the&nbsp;<em>walk()</em>&nbsp;without having to specify a Nil parent. In your code you can just call&nbsp;<em>walk($pod)</em>&nbsp;without anything special, Perl 6 will just fill in the missing argument for you.<br>Also, you'll see that the generic&nbsp;<em>visit()</em>&nbsp;call is gone, there's now in its place a&nbsp;<em>start-node($node,$parent)</em>&nbsp;and&nbsp;<em>end-node($node,$parent)</em>&nbsp;call. We can easily use them like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has $.html;
method start-node( $node, $parent ) {
  given $node {
    when Pod::Table { $!html ~= '&lt;table&gt;' }
  }
}
method end-node( $node, $parent ) {
  given $node {
    when Pod::Table { $!html ~= '&lt;/table&gt;' }
  }
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And voilá!&nbsp;<em>start-node()</em>&nbsp;gets called when a table starts, and its companion&nbsp;<em>end-node()</em>&nbsp;gets called after all of the table contents are displayed, so we can write in the '&lt;/table&gt;' tag at the right time. And we can even check out the table's parent node at&nbsp;<em>$parent</em>. If there isn't one, then we're at the top of the tree!<br>There are a few minor downsides to this, though. For one, every time we learn about a new Pod node, we're going to have to update both the&nbsp;<em>start-node()</em>&nbsp;and&nbsp;<em>end-node()</em>&nbsp;method. But we can fix that simply. Perl 6 lets us dispatch methods by type, using the&nbsp;<em>multi</em>&nbsp;keyword. So, let's try that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has $.html;
method start-node( Pod::Table $node, $parent ) { $!html ~= '&lt;table&gt;' }
method end-node( Pod::Table $node, $parent ) { $!html ~= '&lt;/table&gt;' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Much less noise, and Perl 6 will know exactly how to dispatch our types. But when the code out in the wild encounters a new Pod node that we didn't know about, it'll break with a horrible stacktrace, so let's fix that right now.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has $.html;
method start-node( $node, $parent ) { die "Unknown node " ~ $node.^WHAT.perl }
method end-node( $node, $parent ) { die "Unknown node " ~ $node.^WHAT.perl }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>There, now our code will gracefully die when it's encountered a node that it's never seen before, and report exactly what the node is so that when someone makes a bug report on GitHub we'll know what to do.<br>Now, I should reveal that my upcoming&nbsp;<a href="http://web.archive.org/web/20190103092939/https://github.com/drforr/perl6-Pod-To-HTMLBody.git">Pod::To::HTMLBody</a>&nbsp;module doesn't quite work like this. I do use some of these techniques behind the scenes, and ultimately I walk the tree almost exactly in the same way, but I've done things differently for several different reasons. I guess you'll have to wait for the next part of this article to learn what's going on, and what new challenges I faced making this particular module.<br>Until then, this is your humble author signing off.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>94</wp:post_id>
		<wp:post_date>2018-01-07 13:21:47</wp:post_date>
		<wp:post_date_gmt>2018-01-07 12:21:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>tree-surgery</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516140]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025945668]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Test All The Things</title>
		<link>https://perlfisher.wordpress.com/2017/11/26/test-all-the-things/</link>
		<pubDate>Sun, 26 Nov 2017 12:22:32 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=97</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Is this thing on? Hello? Great, you can see me. This time is all about unit testing in Perl 6. Are you curious about what that t/ directory is for, and want to fill that empty space with some test files? You've come to the right post. If you don't know what I'm talking about, now might be a good idea to go look at a few&nbsp;<a href="http://web.archive.org/web/20190103092939/https://modules.perl6.org/" target="_blank" rel="noreferrer noopener">Perl 6 modules</a>&nbsp;and check out the testing directory.<br>Perl has a long tradition of extensive test suites for its modules, and Perl 6 continues that tradition. You can start by downloading a module from GitHub following the&nbsp;<a href="http://web.archive.org/web/20190103092939/https://modules.perl6.org/" target="_blank" rel="noreferrer noopener">Perl 6 modules</a>link and checking out its t/ directory.<br>Perl 6 comes with a built-in&nbsp;<a href="http://web.archive.org/web/20190103092939/https://docs.perl6.org/language/testing">Test</a>&nbsp;module, which looks a lot like Perl 5's Test::More module. I'm not going to go into great detail (in this post, at least) about what all the methods do, I'm going to focus on just two or three ideas that I came up with when writing my own test suites.<br>DRYing out your tests<br>Sometimes you get into the zone writing tests, and your tests start to bunch up.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">is sprintf( "%s", "a" ), "a", "'a' roundtrips.";
is sprintf( "%s", "€" ), "€", "'€' roundtrips.";
is sprintf( "%s", "\x[263a]" ), "\x[263a]", "Smiley roundtrips.";
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>While something of a contrived example, it's pretty obvious that all of these tests should be bundled together. You certainly could put them in their own file, and in this case it might be a good idea because being able to roundtrip strings (make sure that the input is the same as the output) needs some pretty thorough testing.<br>Right now, though, as it stands, three lines hardly is worth the effort to think of a new name for the file, copy to the new location, delete the old content, add it to git and do a push. Let's come up with an easier way to group these.<br>Visually separating them with a block certainly works...</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">{
  is sprintf( "%s", "a" ), "a", "'a' roundtrips.";
  is sprintf( "%s", "€" ), "€", "'€' roundtrips.";
  is sprintf( "%s", "\x[263a]" ), "\x[263a]", "Smiley roundtrips.";
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>While it certainly looks better, it doesn't help the repetition any. "roundtrips" still repeats, and every time we come up with a new string that might break&nbsp;<em>sprintf()</em>&nbsp;we've got to add it in three places. Let's tackle that first, before going on to the final round.<br>It's certainly tempting to write a quick subroutine to do this, so let's dash off one.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub roundtrip( $name ) {
  is sprintf( "%s", $name ), $name, "'$name' roundtrips."
}
{
  roundtrip( "a" );
  roundtrip( "€" );
  roundtrip( "\x[263a]" );
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Yippee! We've eliminated almost all of the redundancy, and our test output still works!</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">ok 1 - 'a' roundtrips.
ok 2 - '€' roundtrips.
ok 3 - '☺' roundtrips.
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>There's a problem lurking here, though. A couple, actually. What happens when&nbsp;<em>sprintf()</em>breaks?</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">ok 1 - 'a' roundtrips.
not ok 2 - '€' roundtrips.
# Failed test ''€' roundtrips.'
# at t/10-sprintf.t line 4
ok 3 - '☺' roundtrips.
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Pretending we're in a hurry and this is just one of a number of problems we have to debug this evening (just like in real life), open your editor and go to line 4 to quickly trace down the bug...</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  is sprintf( "%s", $name ), $name, "'$name' roundtrips." # line 4
}
{
  roundtrip( "a" );
  roundtrip( "€" );
  roundtrip( "\x[263a]" );
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Hold the phone here, I expected to jump to the test that failed, and I'm on a test subroutine! This would get even more confusing if I had a test library, and&nbsp;<em>roundtrip()</em>&nbsp;wasn't even in my test file. It'd be even a bit confusing if I just saw the word 'roundtrip' repeated over and over, and just searched for that. Or even worse, imagine that this is a file with 200+ tests in it, and every tenth test is for a low Unicode character, so you've got to page through 20 different tests 'til you find the right one. There's got to be a better way.<br>Now you could certainly throw away your changes, roll back to the point where you refactored and call the time a waste. It's easy enough to salvage, though.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  sprintf( "%s", $name )
}
{
  is roundtrip( "a" ), "a", "'a' roundtrips.";
  is roundtrip( "€" ), "€", "'€' roundtrips.";
  is roundtrip( "\x[263a]" ), "\x[263a]", "'\x[263a]' roundtrips.";
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This solves the problem, so when an&nbsp;<em>is()</em>&nbsp;test fails, we'll get pointed directly at the line number, and can jump there in Atom, Emacs, Vim or whatever. But we've gotten our duplication back. Let's try to refactor our way out of this, while making sure that we don't put the&nbsp;<em>is()</em>&nbsp;back into the helper&nbsp;<em>roundtrip()</em>&nbsp;subroutine.<br>We'll start by noting that&nbsp;<em>is( $string, $roundtripped )</em>&nbsp;(ignoring the&nbsp;<em>$message</em>&nbsp;parameter) is equivalent to&nbsp;<em>ok( $string eq $roundtripped )</em>. Change the test from&nbsp;<em>is()</em>&nbsp;to&nbsp;<em>ok()</em>&nbsp;first, then add&nbsp;<em>eq $name</em>&nbsp;inside&nbsp;<em>roundtrip()</em>, and get rid of the redundant argument.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  sprintf( "%s", $name ) eq $name
}
{
  ok roundtrip( "a" ), "'a' roundtrips.";
  ok roundtrip( "€" ), "'€' roundtrips.";
  ok roundtrip( "\x[263a]" ), "'\x[263a]' roundtrips.";
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>That's pretty good, but there's a constant 'roundtrips.' string there. Also we've got this&nbsp;<em>{..}</em>block that's unused, so let's put that block to work by factoring out the 'roundtrips.' bit, using&nbsp;<em>subtest {..}</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  sprintf( "%s", $name ) eq $name
}
subtest 'roundtrips', {
  ok roundtrip( "a" ), "'a'";
  ok roundtrip( "€" ), "'€'";
  ok roundtrip( "\x[263a]" ), "'\x[263a]'";
};
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Looking good, but we've lost a bit along the way. Earlier, when we ran our test suite, we'd get nicely labeled output. Now... not so much.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  ok 1 - 'a'
  ok 2 - '€'
  ok 3 - '☺'
ok 1 - roundtrips
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In a simple, short file like this, scanning from the&nbsp;<em>ok 1 - 'a'</em>&nbsp;line, thinking "Okay, why are we testing 'a'?... Aha, roundtrip tests." is pretty quick, and the indentation tells us we're grouping a bunch of tests, but it would be&nbsp;<strong>really</strong>&nbsp;nice to be able to put that test message where it belongs, in the roundtrip message. So let's do just that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  sprintf( "%s", $name ) eq $name, "'$name' roundtrips."
}
subtest 'roundtrips', {
  ok roundtrip( "a" );
  ok roundtrip( "€" );
  ok roundtrip( "\x[263a]" );
};
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Great, we've got just one test function that tests and gives us a message! Let's run it!</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  ok 1 -
  ok 2 -
  ok 3 -
ok 1 - roundtrips
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>What's going on here?&nbsp;<em>roundtrip()</em>&nbsp;returns both the truthiness of our test and the message correctly, you can test that on the command line yourself. Yes, Virginia, Perl 6 subroutines&nbsp;<strong>can</strong>&nbsp;return more than one value -&nbsp;<em>perl6 -e'sub test { "foo", "bar" }; say test();'</em>&nbsp;will return&nbsp;<em>[ foo bar ]</em>&nbsp;as you'd expect.<br>So&nbsp;<em>ok()</em>&nbsp;is getting the list that&nbsp;<em>roundtrip()</em>&nbsp;returns, and should be unpacking that list and...hey, waitaminnit.&nbsp;<em>roundtrip()</em>&nbsp;returns a list, and&nbsp;<em>ok()</em>&nbsp;expects one argument and one optional argument... maybe&nbsp;<strong>that's</strong>&nbsp;what's going wrong here. So, how do we solve this?<br>Luckily for us, there's an easy way to unpack our list into two arguments. It's not&nbsp;<strong>quite</strong>destructuring (there's another way to do that) but it works for us. The&nbsp;<strong>| (pipe)</strong>&nbsp;symbol before a list "expands" that list inline into a bunch of individual arguments, so let's put that before the&nbsp;<em>roundtrip()</em>&nbsp;call and unpack the list.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;

sub roundtrip( $name ) {
  sprintf( "%s", $name ) eq $name, "'$name' roundtrips."
}
subtest 'roundtrips', {
  ok |roundtrip( "a" );
  ok |roundtrip( "€" );
  ok |roundtrip( "\x[263a]" );
};
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And rerunning our test suite now, our output is what we expect.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  ok 1 - 'a' roundtrips.
  ok 2 - '€' roundtrips.
  ok 3 - '☺' roundtrips.
ok 1 - roundtrips
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This may be a bridge too far for some, and I respect your decision. Using the&nbsp;<em>subtest()</em>&nbsp;block may be all you need, because you can quickly search for a keyword in the string and bounce immediately to the start of the tests where one fails. You may even want to go to the lengths of using&nbsp;<code>ok( roundtrip($_) ) for &lt; a € ☺ &gt;</code>&nbsp;to get rid of the last duplicated call to&nbsp;<em>roundtrip()</em>, that's your choice. all I'm offering here is some ways to DRY out your test files.<br>Gentle Reader, if you've gotten this far, thank you. I do read all the comments that I get, at least eventually. I'm also @DrForr on Twitter, 'Jeff Goff' on Facebook and LinkedIn. Thank you for your time, and I hope it was worth your while.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>97</wp:post_id>
		<wp:post_date>2017-11-26 13:22:32</wp:post_date>
		<wp:post_date_gmt>2017-11-26 12:22:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>test-all-the-things</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516188]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025967775]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Wrangling Metadata the Right Way</title>
		<link>https://perlfisher.wordpress.com/2017/04/19/wrangling-metadata-the-right-way/</link>
		<pubDate>Wed, 19 Apr 2017 11:23:23 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=100</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>If you're new to Regular Expressions or Grammars (at least as they're used in Perl 6), then I'd suggest starting with&nbsp;<a href="http://web.archive.org/web/20190103092939/http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="noreferrer noopener">the 1st part</a>&nbsp;of a full tutorial on Perl 6 grammars. Now to the heart of the matter!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I'm rewriting the ANTLR -&gt; Perl 6 grammar translator, and the code was simply too old to really be refactored - it predated the Great List Refactor, ask any old Perl 6 hand about that. This&nbsp;<strong>does</strong>&nbsp;require some familiarity with how grammars and Abstract Syntax Trees are related, so please bear with me.<br>Grammar rules (rules that tell Perl 6 how you want to match text) look something like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">rule parserRuleSpec
        {
        &lt;ID&gt;
        ':'
        &lt;parserAltList&gt;
        ';'
        }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Here an &lt;ID&gt; is simply the name of a parser rule, and &lt;parserAltList&gt; is its body, consisting of a series of "alternations". Like YACC, Marpa or ANTLR, you can tell Perl 6 to run a block of code when it successfully parses a &lt;parserRuleSpec&gt; in the target string. Let's assume that our target looks like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">integer : \d+ ;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Even if you don't know the exact details, it shouldn't be hard to guess that &lt;ID&gt; matches 'integer', and &lt;parserAltList&gt; matches '\d+'. If you don't ask Perl 6 to do anything to this, the 'integer' and '\d+' bits tend to sort of get lost in what can look like a confusing blizzard of hashes and arrays, it certainly was confusing to me. But we can help make sense of all of this. When this particular rule succeeds, we can stop right&nbsp;<strong>there</strong>&nbsp;and do something useful with that data. It'd be nice to get back a neat little hash, with some consistently-named keys, so we can do something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method parserRuleSpec( $/ )              # rule parserRuleSpec
        {                                #         {
        make {                           #
             name =&gt;                     #
                 $/&lt;ID&gt;.Str,             #         &lt;ID&gt;
                 # ':'                   #         ':' 
             body =&gt;                     #
                 $/&lt;parserAltList&gt;.Str   #         &lt;parserAltList&gt;
                 # ';'                   #         ';'
             }                           #
        }                                #         }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>[If this doesn't render neatly, my apologies, but I wanted to make it clear what I've done.] I've added a parserRuleSpec() method that will be run whenever the parser completely and correctly matches a parserRuleSpec rule. Whenever I want to inspect a parserRuleSpec rule, I don't have to dig around inside Match objects and look for strings, all I need to do is something like 'say $/&lt;parserRuleSpec&gt;.ast.gist' and now I'll get a nice simple representation of a parserRuleSpec as a hash with 'name' and 'body' keys:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $/&lt;parserRuleSpec&gt;.ast.gist;

# {name =&gt; 'integer', body =&gt; '\d+'}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>So our potentially-gnarly parserRuleSpec is now tamed, and resides in a nice neat data structure. And if you note, it's a pretty mechanical process. Copy the original rule, change 'rule' to 'method', wrap with 'make { }', and give names to the &lt;ID&gt; etc. tags. In fact, you could probably automate it, but that's another article for another time :) My point here is that you don't always want this kind of routinely-generated data structure.<br>If you have a rule like 'integer : \d+ ;', then it's not unreasonable to assume that other rules will follow, like 'float : \d+ "." \d+ ;'. Eventually, you'll want to collect these into some other data structure, maybe like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %rules;
for $/&lt;parserRules&gt; -&gt; $rule
        {
        %rules{ $rule.&lt;name&gt; } = $rule.&lt;body&gt;;
        }
say %rules.gist;

# {integer =&gt; '\d+', float =&gt; '\d+ "." \d+'}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Or you could even write it more compactly:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %rules;
%rules{ $_.&lt;name&gt; } = $_.&lt;body&gt; for $/&lt;parserRules&gt;;
say %rules.gist;

# {integer =&gt; '\d+', float =&gt; '\d+ "." \d+'}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>There are of course other ways to write this, but there's another way altogether to avoid the complications. When I started out on this current project (early last year, as it happens) I was of the opinion that the AST return blocks should contain all of the information they needed, so that I never had to "go back" for more data. During the rewrite I realized that's not necessarily the case, and I can make things more flexible in this case by simply not returning the name as part of the AST, and letting the outer layer do what it wants with the actual name. So, this code now looks like: (skipping the original rule declaration)</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method parserRuleSpec( $/ )
        {
        make $/&lt;parserAltList&gt;.Str
        }

my %rules;
for $/&lt;parserRules&gt; -&gt; $rule
        {
        %rules{ $rule&lt;ID&gt;&gt;.Str } = $rule.ast;
        }
say %rules.gist;

# {integer =&gt; '\d+', float =&gt; '\d+ "." \d+'}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":3} -->
<h3>A bit of philosophy, if I may</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There are two subtle points to be made about this. The first is that I'm separating the metadata (just the name, but ANTLR decorates rules with other things) from the meat of the rule, so that the user doesn't have to wade through as much detail initially. When the user wants to look at the rule, a simple 'say $rule.ast.gist' will give them an idea of what the rule contains, without a blizzard of metadata like actions and exceptions.<br>Second, and more subtle, as the author of the code I don't have to care about what's&nbsp;<strong>in</strong>&nbsp;a rule, I just have to grab the .ast and return it. Say, for instance, I got halfway through coding these rules up, and realized that alongside the 'content' I needed to pass an action parameter as well, so</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %rules;
for $/&lt;parserRules&gt; -&gt; $rule
        {
        %rules{ $rule.&lt;name&gt; } = $rule.&lt;body&gt;;
        }
say %rules.gist;

# {integer =&gt; '\d+', float =&gt; '\d+ "." \d+'}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>now had to have an 'action' hash key added:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %rules;
for $/&lt;parserRules&gt; -&gt; $rule
        {
        %rules{ $rule.&lt;name&gt; } = # If only this were $rule.ast...
            {
            body =&gt; $rule.&lt;body&gt;,
            action =&gt; rule.&lt;action&gt;
            };
        }
say %rules.gist;

# {integer =&gt; {body =&gt; '\d+', action =&gt; '$int-count++'}, float =&gt; {body =&gt; '\d+ "." \d+', action =&gt; '$float-count++'}}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Now, every time I want to add a&nbsp;<strong>new</strong>&nbsp;argument alongside 'body', I have to add it in at least two places - the original method that generated the .ast data structure, and the place in the driver code where I capture the data and store it in a higher-level .ast data structure. Actually I've forgotten about the test code (sigh, yes,&nbsp;<strong>again</strong>) so make that three places. And the documentation makes at least four. Those last two don't count as much because no matter what you do you've got to update test data, and if your test suite didn't catch the change, it really shouldn't be called a test suite unless you're doing some very specific black-box testing.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>In conclusion</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>After this long writeup I'm going to go back to the ANTLR4 test bed with an eye towards eliminating this redundancy. The idea of capturing everything I needed in a grammar layer in a single pass appealed to me when I was first starting to write this, and I imagine the idea of "one grammar rule returns one AST hash" has some appeal. It's of course not as simple, especially since grammar rules can match optional things, match X or Y or Z but not all, and so on, but knowing that everything you need is in a single hash is handy when you're starting out, but I'm now seeing this as a counterexample to the KISS (Keep It Simple, you Silly thing) principle, and am going to check in the current ANTLR layer and refactor with this in mind before doing more work.Gentle Reader, if you've gotten this far, thank you. I do read all the comments that I get, at least eventually. I'm also @DrForr on Twitter, 'Jeff Goff' on Facebook and LinkedIn. Thank you for your time, and I hope it was worth your while.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>100</wp:post_id>
		<wp:post_date>2017-04-19 13:23:23</wp:post_date>
		<wp:post_date_gmt>2017-04-19 11:23:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>wrangling-metadata-the-right-way</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516236]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025990456]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>From Regular Expressions to Grammars, Pt. 4</title>
		<link>https://perlfisher.wordpress.com/2016/02/28/from-regular-expressions-to-grammars-pt-4/</link>
		<pubDate>Sun, 28 Feb 2016 12:24:06 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=103</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>If you're new to Regular Expressions (at least as they're used in Perl 6), then I'd suggest starting with&nbsp;<a href="http://web.archive.org/web/20190103092939/http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="noreferrer noopener">the 1st part</a>&nbsp;of this series. Those of you with a solid grasp of regular expressions may want to skip ahead to&nbsp;<a href="http://web.archive.org/web/20190103092939/http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt_20.html" target="_blank" rel="noreferrer noopener">last week's</a>&nbsp;posting. Now, on with the show!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>In Last Week's Episode</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We were starting to develop a compiler in Perl 6 that would take a JavaScript expression like</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code"> var a = 3; console.log( "Hey, did you know a = " + a + "?" );  
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>and turn it into Perl 6 code that compilers like&nbsp;<a href="http://web.archive.org/web/20190103092939/http://perl6.org/" target="_blank" rel="noreferrer noopener">Rakudo Perl</a>&nbsp;can run. Before we get started it's probably a good idea to figure out what that code will look like. If you already know Perl 5, then code like this should look familiar to you.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $a = 3;
say "Hey, did you know a = " ~ $a ~ "?";</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We'll need to make sure that our regular expressions have captured the essence of the JavaScript. If you remember from last time, we captured our text with this set of regular expressions:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule Number { \d+ };
my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt;+ '"' };
my rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
my rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>If you put this into a Perl 6 source file and run it, the output might look a little strange at first:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">｢var a = 3; console.log( "Hey, did you know a = " + a + "?" );｣
 Assignment-Expression =&gt; ｢var a = 3｣
    Variable =&gt; ｢a ｣
    Number =&gt; ｢3｣
 Function-Call =&gt; ｢console.log( "Hey, did you know a = " + a + "?" )｣
    String =&gt; ｢"Hey, did you know a = " ｣
    Variable =&gt; ｢a ｣
    String =&gt; ｢"?" ｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>If you'll ignore the ｢｣ marks for the moment, you can see that the matches are indented, almost like a file explorer window, with 'Assignment-Expression' being a directory, and 'Variable' and 'Number' being files inside that directory. That's not too far from the truth, actually. When I see this sort of structure, I find that it helps to visualize it like so, with just a bit of added syntax -</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$/ =&gt; ｢var a = 3; console.log( "Hey, did you know a = " + a + "?" );｣
 &lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;Number&gt; =&gt; ｢3｣
 &lt;Function-Call&gt; =&gt; ｢console.log( "Hey, did you know a = " + a + "?" )｣
    &lt;String&gt; =&gt; ｢"Hey, did you know a = " ｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;String&gt; =&gt; ｢"?" ｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This makes it almost too easy to figure out how to print out text, and points out a tiny problem in our regular expression. Let's print out the number we've assigned&nbsp;<em>a</em>&nbsp;to, just to start out with. The first line tells us the root of the directory, or match, tree is&nbsp;<em>$/</em>.&nbsp;&nbsp;If you add 'say $/;' to the end of your test file and rerun it, you'll see the entire expression printed out twice. That must mean that&nbsp;<em>$/</em>&nbsp;is the entire match.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Going down one layer is just as easy as adding what's on the left side of the =&gt; arrow. Change the previous 'say' statement to 'say $/&lt;Assignment-Expression&gt;;', and look at how the output changes. It should now look like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">｢var a = 3｣
  Variable =&gt; ｢a ｣
  Number =&gt; ｢3｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Let's put our (invisible) markers back in, so we can see where to go...&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$/&lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;Number&gt; =&gt; ｢3｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We can now see that our target, the number 3, is just one layer further down. Again, we can add what's on the left-hand side of the expression, so let's do just that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $/&lt;Assignment-Expression&gt;&lt;Number&gt;;
  ｢3｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And we have almost exactly what we want. The ｢｣ are in the way, so let's "cast" the value here back to a number. I've put "cast" in scare quotes because it's not&nbsp;<strong>quite</strong>&nbsp;what C/C++ programmers think of as "casting". What we want to do is roughly the equivalent of 'sscanf(str,"%d",&amp;num)", but in Perl 6, the operation is much simpler.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say +$/&lt;Assignment-Expression&gt;&lt;Number&gt;;
  3
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Without getting into too much detail,&nbsp;<em>$/</em>&nbsp;is an object that has an implicit number, string and boolean value hiding inside of it. Adding '+' to the front reveals the hidden number inside the&nbsp;<em>$/</em>&nbsp;object.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>From JavaScript to Perl</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We're not too far off from being able to generate Perl 6 code from our JavaScript. Let's use what we've learned above with our first statement, the assignment.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'my $' ~ $/&lt;Assignment-Expression&gt;&lt;Variable&gt; ~ ' = ' ~
      $/&lt;Assignment-Expression&gt;&lt;Number&gt; ~ ';';

my $a = 3;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We've just used 7 lines of Perl 6 to turn code in one language into another language. And most of the Perl 6 code is reusable, because strings, numbers and JavaScript/C/Java-style variable names are common across most languages out there.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Last time, we learned how to create matches using regular expressions. This time we've learned how we can&nbsp;<strong>use</strong>&nbsp;what we've matched, and how to find what we want inside a&nbsp;<em>say</em>&nbsp;statement. The invisible matching markers are useful enough that I might actually write a module that puts them back into match expressions, it shouldn't be hard.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is one problem with that scheme, and if we look at the &lt;Function-Call&gt; matches, it's pretty easy to see the problem.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$/&lt;Function-Call&gt; =&gt; ｢console.log( "Hey, did you know a = " + a + "?" )｣
  &lt;String&gt; =&gt; ｢"Hey, did you know a = " ｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;String&gt; =&gt; ｢"?" ｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>When we write "say $/&lt;Function-Call&gt;&lt;String&gt;;", which &lt;String&gt; will we get? Before you run this, try to guess. Is it the first one, because Perl 6 won't replace a match object once it's been created? Is it the last one, because the last one "overwrites" the first one? Does the compiler simply "get confused" and prints nothing? Try it and see!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It actually returns both matches in a list, so you can reference either one. Our invisible markers now get to look like&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$/&lt;Function-Call&gt; =&gt; ｢console.log( "Hey, did you know a = " + a + "?" )｣
  &lt;String&gt;[0] =&gt; ｢"Hey, did you know a = " ｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;String&gt;[1] =&gt; ｢"?" ｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>So if we want to print out the first string, we can write "say $/&lt;Function-Call&gt;&lt;String&gt;[0];" and get back &nbsp;｢"Hey, did you know a = " ｣ complete with the funky Japanese quotation marks. Thankfully there's a shortcut to getting rid of those, just like there was with the number 3.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say ~$/&lt;Function-Call&gt;&lt;String&gt;[0];
  "Hey, did you know a = "
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The '~" operator "stringifies" the match, just like '+' "numifies" the match that gets returned. So, you can probably write the final line yourself...</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'say ' ~ $/&lt;Function-Call&gt;&lt;String&gt;[0] ~ ' ~ '
  ' $' ~ $/&lt;Function-Call&gt;&lt;Variable&gt; ~ ' ~ '
  $&lt;Function-Call&gt;&lt;String&gt;[1] ~ ';';

say "Hey, did you know a = " ~ $a ~ "?";
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And we've compiled our two lines of JavaScript into Perl 6.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Refactoring</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>What we've got works, but there's quite a bit of repetition. Here's what we've got so far.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt;+ '"' };
my rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
my rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };

'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }

say 'my $' ~ $/&lt;Assignment-Expression&gt;&lt;Variable&gt; ~
       ' = ' ~ $/&lt;Assignment-Expression&gt;&lt;Number&gt; ~
       ';';

say 'say ' ~ $/&lt;Function-Call&gt;&lt;String&gt;[0] ~
       ' ~ $' ~ $/&lt;Function-Call&gt;&lt;Variable&gt; ~
      ' ~ ' ~ $/&lt;Function-Call&gt;&lt;String&gt;[1] ~
      ';';
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The rules look pretty good, the repetitions of &lt;String&gt; and &lt;Variable&gt; are pretty much unavoidable, but look at the 'say' statements. You'll see that &lt;Assignment-Expression&gt; and &lt;Function-Call&gt; repeat themselves several times. One way to get rid of this repetition is to create a temporary variable, but that could get ugly.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $assignment-expression = $/&lt;Assignment-Expression&gt;;
say 'my $' ~ $assignment-expression&lt;Variable&gt; ~ ' = ' ~
    $assignment-expression&lt;Number&gt; ~ ';'
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Instead, let's take advantage of Perl 6's subroutine signatures, and reuse the&nbsp;<em>$/</em>&nbsp;variable name so we can reuse the code we wrote above, and just drop out the &lt;Assignment-Expression&gt; part. I'll name the subroutine after the rule, just to keep things straight. (You'll see why later.)</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub assignment-expression( $/ ) {
    'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
}

say assignment-expression( $/&lt;Assignment-Expression&gt; ); 
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Let's do the same for &lt;Function-Call&gt; as well, creating a function with the same name and&nbsp;<em>$/</em>&nbsp;subroutine signature. It now fits neatly on one line, and only repeats the &lt;String&gt; bit because it has to.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub function-call( $/ ) {
    'say ' ~ $/&lt;String&gt;[0] ~ ' ~ ' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';'
}

say function-call( $/&lt;Function-Call&gt; ); 
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Objectification</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I've made quite a few choices along the way to get us to this point in the narrative. Here's where we are after the last bout of refactoring:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">
my rule Number { \d+ };
my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt;+ '"' };
my rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
my rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };

'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }

sub assignment-expression( $/ ) {
    'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
}

sub function-call( $/ ) {
    'say ' ~ $/&lt;String&gt;[0] ~ ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';';
}
say assignment-expression( $/&lt;Assignment-Expression&gt; );
say function-call( $/&lt;Function-Call&gt; );
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Here's where this all pays off. &nbsp;Let's pack up the last two 'say' calls first. We haven't given the top-level rule a name, so let's just call it ... well, 'top' for now.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub top( $/ ) { assignment-expression( $/ ) ~ function-Call( $/ ) }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":3} -->
<h3>Pack up your Troubles&nbsp;</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We haven't done much with the rules sitting at the top of the file for a while, so let's work with those. In Perl 6, and for that matter programming in general, it's a good idea to package up your code for reuse. While Perl 6 lets us package up code with the 'class' keyword, the rules we have really aren't "code" in any sense. While they can be used in code, and we do use them, they don't really make any decisions on their own.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So we shouldn't use the 'class' keyword to package them up. Instead, there's another convenient type meant for packaging up a bunch of regular expressions and rules, called a 'grammar'. It looks just like the syntax for declaring a 'rule', and that's actually by design.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">
grammar JavaScript {
  rule Number { \d+ };
  rule Variable { \w+ };
  rule String { '"' &lt;-[ " ]&gt;+ '"' };
  rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
  rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };

  rule TOP { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' };
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>You'll note that we gave our top-level rule a name as well, and just called it 'TOP' for the time being. If you're playing along at home, you've probably made the change and are wondering how the "'var a = 3;...' ~~ rule { ... }" thing plays out, because trying things like "'var a = 3;...' ~~ JavaScript;" won't quite work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Grammars are just like classes, in that they're really just clumps of potential code. They can't be made to do work on their own, they have to be converted from potential to .. well, kinetic code. We can do that just like you do with any class.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $javaScript = JavaScript.new;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And now we have a variable that we can work with. Now, let's put it to work. All grammar classes come with a built-in 'parse()' method that we can use to get at the regular expressions inside it. Let's modify our match statement to take advantage of that -</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">
$javaScript.parse(
    'var a = 3; console.log( "Hey, did you know a = " + a + "?" );');
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And our code should work again.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Taking Action</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now that we've bundled up all of our matching stuff into one tidy little class, it'd be nice if we could do the same for those subroutines. Let's try that here, and put our subroutines into their own namespace, just like we did with the rules. We'll have to change from 'sub' to 'method', and our 'top' method will have to use 'self.' to call the other methods.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Actions {
    method assignment-expression( $/ ) {
      'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
    }

    method function-call( $/ ) {
      'say ' ~ $/&lt;String&gt;[0] ~ ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';';
    }

    method top( $/ ) {
        self.assignment-expression( $/&lt;Assignment-Expression&gt; ) ~
        self.function-call( $/&lt;Function-Call&gt; )
    }
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And just like before, we can create the Actions object in one line</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code"> my $actions = Actions.new;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And call the top&nbsp;<strong>almost</strong>&nbsp;like we did before.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $actions.top( $/ );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We've changed things around quite a bit, so here's a look at where we stand.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">grammar JavaScript {
  rule Number { \d+ };
  rule Variable { \w+ };
  rule String { '"' &lt;-[ " ]&gt;+ '"' };
  rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
  rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };
  rule TOP { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }
}
my $j = JavaScript.new;

$j.parse('var a = 3; console.log( "Hey, did you know a = " + a + "?" );');

class Actions {
    method assignment-expression( $/ ) {
      'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
    }

    method function-call( $/ ) {
      'say ' ~ $/&lt;String&gt;[0] ~ ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';';
    }

    method top( $/ ) {
      self.assignment-expression( $/&lt;Assignment-Expression&gt; ) ~
      self.function-call( $/&lt;Function-Call&gt; )
    }
}

my $actions = Actions.new;
say $actions.top($/);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Don't worry, we're almost there. Now that we have a separate class for the actions, let's rename the methods to exactly match the grammar rules, so we don't forget what they are.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Actions {
    method Assignment-Expression( $/ ) {
      'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
    }

    method Function-Call( $/ ) {
      'say ' ~ $/&lt;String&gt;[0] ~ ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';';
    }

    method TOP( $/ ) {
      self.Assignment-Expression( $/&lt;Assignment-Expression&gt; ) ~
      self.Function-Call( $/&lt;Function-Call&gt; )
    }
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Furthermore, there's one last bit of magic that we can take advantage of. We're going to combine the $javascript and $actions objects like so.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $javascript.parse('....', :actions($actions) );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The ':actions(...)' is just a fancy way of declaring an optional argument to the 'parse()' method. We're telling the regular expression engine that any time a rule like &lt;Function-Call&gt; or &lt;TOP&gt; matches, we'd like it to call the corresponding method in our class.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This almost works as-is, but if you run the code with these modifications, you'll see the parser returns the original match object, with those Japanese quote marks. So it seems like we're back at square one. Not quite.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Go ahead and add a temporary "say 'Hello!';" to one of the methods, just to confirm that they're getting called. This is important proof that the regex engine is working and properly parsing what it's going over. You can even use some of the tricks we learned above and write "say $/&lt;Variable&gt;;" to see if the match is getting run as you thought it should. Go ahead and play around, come back here when you're done.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Mixed Signals</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>What's happening is the methods are getting called, but their output is being lost. Let's capture the output and use the final (ha!) feature of the grammar, the Abstract Syntax Tree. Now, this might dredge up notions of sitting in classrooms watching boxes and lines being drawn on the chalkboard, but it's not really that bad. We've already seen one, in fact the output from say() is an AST.<br>Let's look at the&nbsp;<strong>other</strong>&nbsp;syntax tree, the one we're building in the background. Add '.ast' to the end of the "$javascript.parse(...).ast;" call, like that. This will show us the syntax tree we're building on our own. Or will it?<br>If you do this, you'll see it prints&nbsp;<em>(Any)</em>, which generally is the equivalent of "failed match", but we know from previous testing that the match hasn't failed. So what's going on here? While our methods are getting run, and they return output, Perl 6 doesn't know what to do with the output, or where it fits in the AST it's been asked to build.<br>The key is a little thing called "make". Add this where we used to put 'say', at the start of the methods.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">class Actions {
    method Assignment-Expression( $/ ) {
      make 'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';'
    }

    method Function-Call( $/ ) {
      make 'say ' ~ $/&lt;String&gt;[0] ~ ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';'
    }

    method TOP( $/ ) {
      make $/&lt;Assignment-Expression&gt;.ast ~ $/&lt;Function-Call&gt;.ast
    }
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Also, because Perl 6 is calling the methods for us, we don't need to call self.Function-Call(...) on our own, all we need to do is look at the syntax tree that Function-Call(...) returns to us. And there we have it. A complete, albeit tiny compiler. In case you've gotten lost with the editing, here's the final result.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">grammar JavaScript {
  rule Number { \d+ };
  rule Variable { \w+ };
  rule String { '"' &lt;-[ " ]&gt;+ '"' };
  rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
  rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };
  rule TOP { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }
}

class Actions {
  method Assignment-Expression( $/ ) {
    make 'my $' ~ $/&lt;Variable&gt; ~ ' = ' ~ $/&lt;Number&gt; ~ ';' }

  method Function-Call( $/ ) {
    make 'say ' ~ $/&lt;String&gt;[0] ~
     ' ~ $' ~ $/&lt;Variable&gt; ~ ' ~ ' ~ $/&lt;String&gt;[1] ~ ';'; }

  method TOP( $/ ) {
    make $/&lt;Assignment-Expression&gt;.ast ~ $/&lt;Function-Call&gt;.ast }
}

my $j = JavaScript.new;
my $a = Actions.new;
say $j.parse(
   'var a = 3; console.log( "Hey, did you know a = " + a + "?" );',
   :actions($a)).ast;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":3} -->
<h3>Where Do We Go From Here&nbsp;</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>One simple but neat change you can do is expand the Assignment-Expression to accept both numbers and strings. We talked last time about alternatives in the rules, so this hint should be enough to get you started:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">rule Assignment-Expression { var &lt;Variable&gt; '=' ( &lt;Number&gt; | &lt;String&gt; ) }</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>You'll have to modify the Assignment-Expression method a little bit to make this work. Or you could get crafty and realize that ( &lt;Number&gt; | &lt;String&gt; ) could be turned into its own little generic "Term" rule, "rule Term { &lt;Number&gt; | &lt;String&gt; }", add an action "method Term( $/ ) { make $/&lt;Number&gt; or $/&lt;String&gt; }" and only change one thing in Assignment-Expression.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Time and again when helping people out online, I've had to say that Perl 5 regular expressions aren't&nbsp;<strong>quite</strong>&nbsp;the tool they need, whether they're trying to find a bit of HTML in a document, rewriting an RTF file or pulling out a title from a LaTeX doc. I've had to say "Use HTML::Parser", or "Check out the RTF modules on CPAN" or "Try Parser::MCG" to tackle these thorny questions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perl 6 regular expressions can handle all of those tasks and much more. Plus, the techniques I've mentioned in this tutorial aren't specific to JavaScript. You can use these same techniques to parse any language that can be broken down into tokens. It may take some creative use of higher-level rules, but it can be done.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Your methods don't have to return Perl 6 text when they parse JavaScript. They could just as easily count up the number of function calls, flag lines of code that can cause problems or do inline optimization. Perl 6 is written in Perl 6, so you could even use these techniques to compile from Perl 6 to JavaScript.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thank you, gentle reader, for making it this far with me. I hope you've learned something along the way, or at least been entertained by what vistas Perl 6 opens up. Next month I'll probably briefly return to Perl 5 and more real-world debugging.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date>2016-02-28 13:24:06</wp:post_date>
		<wp:post_date_gmt>2016-02-28 12:24:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>from-regular-expressions-to-grammars-pt-4</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026013479]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516285]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>From Regular Expressions to Grammars, Pt. 3</title>
		<link>https://perlfisher.wordpress.com/2016/02/20/from-regular-expressions-to-grammars-pt-3/</link>
		<pubDate>Sat, 20 Feb 2016 12:24:52 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=106</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>If you haven't been following this series, please check out&nbsp;<a href="http://web.archive.org/web/20190103092939/http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="noreferrer noopener">Part 1</a>&nbsp;of this series&nbsp;before continuing to read.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Movin' on up</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>After an admittedly whirlwind tour of the basic set of regular expressions, it's time to enter the big league. We'll take it slow, and just for variety, we'll tackle a bit of JavaScript. I've developed this technique over a few prior posts, so if you've been reading past entries this may seem a bit of a refresher.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At the end of the series, we'll have created a small JIT interpreter for a small bit of JavaScript, to wit, this line:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">var a = 3; console.log( "Hey, did you know a = " + a + "?" );
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We'll take this one step at a time. I generally like to put this into source code control so I can easily checkpoint and revert source when an approach doesn't work out. Like many people these days, I use git, but feel free to use mercurial, darcs, SVN or whatever works best for you.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The best compiler in the world won't help if it can't read your input, so let's start with a simple test.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
/'var a = 3; console.log( "Hey, did you know a = " + a + "?" );'/
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The 'say' is included so that we can see the output from the match. Right now, we expect that since we're attempting to match a quoted string against an exact copy of itself, the match should trivially succeed. It's roughly the same as</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'Hello, world!' ~~ /'Hello, world!'/</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The entire expression is enclosed within single quotes, so we don't have to concern ourselves with what gets quoted and what doesn't.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Anyway, copy the "say 'a = 3...." statement into a file somewhere and run 'perl6 test.pl6', assuming your file is called 'test.pl6'. &nbsp;It should print out precisely what it matched, which is the string itself:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">jgoff@Demeisen:~$ perl6 test.pl6

｢var a = 3; console.log( "Hey, did you know a = " + a + "?" );｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This result lets us know that the match succeeded, and tells us that it matched the entire expression. So, go ahead and checkpoint this in your git (or whatever, I'll assume git from here on out) repository and let's dive in to refactor things just a bit.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Use Cases</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If we were at this point to go ahead and write the compiler code, it'd end up being pretty boring. It would be able to compile that exact string to Perl 6 and generate 'my $a = 3; say "Hey, did you know a = " ~ $a ~ "?";', but it couldn't do anything else. See for yourself by changing the "say '...'" part of the expression to test your own variations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>JavaScript commonly gets "minified" before being sent to the browser, with no unnecessary whitespace in the string. So, go ahead and remove the whitespace from the "say '...'" part of your expression, and rerun the test. I'll wait here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Did it match? I thought not. Do a 'git reset --hard' to get back to the last known-working point, and let's continue. While regular expressions are terribly powerful, they can also be very finicky, as we're about to learn. Let's focus for a few moments on just one of the statements in our compiler, the "a = 3;" statement.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Programmers will come up with lots of creative ways to express this simple statement, from the terse 'a=3;' to tabbing out the '= 3' portion to line up with something else, to the extreme of even putting the semicolon on the next line so that they don't have to add it all the time when copying text around. (Yes, I've seen that style in the wild.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Remembering the rule that alphanumerics don't need to be escaped, we can combine what we've just learned and match all possible variants like so -</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'a=3;' ~~ / \s* a \s* '=' \s* 3 \s* ';' \s*/
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Which matches any whitespace variant you can dream up, anything from "a=3;" to "\n &nbsp; &nbsp;a &nbsp; &nbsp; = 3;" and beyond. There are two lessons to be learned here. The first is that by breaking up our string wherever a programmer might want to insert whitespace, we've taken our first step towards "tokenizing" the expression. We'll go into more depth about that later.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The second is that while it's more flexible, the expression now has these \s* scattered throughout it, making it a little harder to read. Also, inserting "\s*" between every word seems like something a computer should be able to do. And in fact, it can. And there's already a shorthand in Perl 6 for this.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'a=3;' ~~ rule { a '=' 3 ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>No more \s* interrupting us between every place we might want to put whitespace. Let's get back to our original expression and apply what we've learned here.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var a '=' 3 ';'
          console '.' log '(' '"Hey, did you know a = "' '+' a '+' '"?"' ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Structure and Form</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You might notice that "Hey, did you know a = " and "?" didn't receive the same quoting treatment as the other parts of the rule. While there are some deep reasons here, the main one is practicality. Eventually this compiler we're writing should be able to accept "!" instead of "?", "Hello world!" instead of "Hey...", and we want to make sure all of these input strings are acceptable.<br>So, it's time for a bit of refactoring. Let's take a fairly short expression, "Hello, world!" to work with. You might remember from the last section that the \w shorthand matches alphanumerics, so a first cut at refactoring "Hello, world!" might look like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say '"Hello, world!"' ~~ rule { '"' \w+ ',' \w+ '!' '"' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And indeed, that will match. It'll match "Goodbye, world!", "Frankly, dear!" and a host of other expressions. It'd be nice, though, if there were a way to combine the \w, ',' and '!' into one thing that we could then match on, because that would let us match "hello!", "Whats up, doc" and a&nbsp;<strong>lot</strong>&nbsp;more. Again, yes, there is a shortcut for that.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say '"Hello, world!"' ~~ rule { '"' &lt;[ \s \w , ! ]&gt;+ '"' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>lets you match a group of characters and/or shortcuts, so &lt;[ a b c ]&gt; on its own would match 'a', 'b' or 'c' but not '3' or '32'. We're still not quite there, because there's a lot more to add in to that expression, you'd have to add '?', '+', '.', ';' for starters, like &lt;[ \s \w , ! ? + . ; ]&gt; and so on. And when you bring Unicode into the mix, you'll have to add another million-plus characters for the CJKV region alone.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>By now you won't be surprised at all to learn that yes, there's a shortcut for this too. The shortest of all shortcuts, it's simply '.'. So our expression now looks like</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say '"Hello, world!"' ~~ rule { '"' .+ '"' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Which says "Match a quotation mark, then anything, then another quotation mark." And if you spell it out like that, you can probably spot the problem as fast as I did. Simply put, the '.' shortcut matches&nbsp;<strong>any</strong>&nbsp;character, and yes, this includes the&nbsp;｢"｣ (using Japanese quotation marks to make the problem a little clearer.) So what we really want to do is "Match a quotation mark, then anything but the quotation mark, then another quotation mark."</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You say "Anything but" in regex-speak like &lt;-[..]&gt;, where the [..] is whatever you&nbsp;<strong>don't</strong>&nbsp;want to match. We want "anything but a quotation mark", so in to the [] the quotation mark goes, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var a '=' 3 ';'
          console '.' log '(' '"' &lt;-[ " ]&gt; '"' '+' a '+' '"' &lt;-[ " ]&gt; '"' ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In real-world code people like to put quotation marks inside quoted strings, but we won't worry about those for the moment.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Nest Eggs</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Checkpoint here, and go ahead and play with the strings and whitespace. It can now match 'a=3;console.log("Hey, "+a+" is 3!");' and a bunch of other expressions. Those single-quoted double-quotes do stand out, though, especially since there are two of them. Since we've already got a rule, let's create a new rule just to hold those, and give it a name.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule String { '"' &lt;-[ " ]&gt; '"' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var a '=' 3 ';'
          console '.' log '(' '"' .+ '"' '+' a '+' '"' .+ '"' ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Of course, we've still got the original text below, so we'll take a cue from the character groups that we touched on briefly, and put the name in '&lt;'...'&gt;' as well.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule String { '"' &lt;-[ " ]&gt; '"' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var a '=' 3 ';'
          console '.' log '(' &lt;String&gt; '+' a '+' &lt;String&gt; ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We've just refactored the 'console.log....' expression into something that humans can readily understand, and in fact expand upon as well. Building on the principle of not repeating yourself, we can notice that the variable is repeated in the string, so let's factor that out as well.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt; '"' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var &lt;Variable&gt; '=' 3 ';'
          console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We may as well factor out the number as well...</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule Number { \d+ };
my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt; '"' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { var &lt;Variable&gt; '=' &lt;Number&gt; ';'
          console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Mere Semantics</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You may have noticed that I used '\w+' to match Variables, rather than 'a'. While this allows users of the eventual compiler to write 'var Lennier = 5;' rather than the more prosaic 'var a = 23;', it also allows users to write semantically invalid code. To wit, 'var Prisoner = 6; console.log("I am not " + a + " a number");' where&nbsp;<em>a</em>&nbsp;is not defined.<br>In principle, we could change the rule so that the second instance of &lt;Variable&gt; must have the same value as the first instance. That way our previous Prisoner example would fail, because 'a' would not be the same as 'Prisoner', and it only allows syntactically and semantically correct code to pass the test.<br>That's wonderful in principle, and keeps the changes localized to the final rule. Great, and your test suite might even pass, and you release your module out into the real world.<br>Then someone comes along and writes 'var test = 1; var a = 2; console.log("Hi, test = " + test + ".");'. Which is perfectly valid JavaScript code, and will compile everywhere... except in your compiler. So you say "fine, I'll check for any assignment statements after the function definition. And then someone writes a closure with a 'console.log( .. + variable_outside_the_function + ...)' and breaks your code again.<br>In summation, let your rules catch syntax errors only, anything else can and should be handled outside. In the fourth and final installment of this series, we'll build a compiler out of this. But let's do one final burst of refactoring in order to clarify the statements.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my rule Number { \d+ };
my rule Variable { \w+ };
my rule String { '"' &lt;-[ " ]&gt;+ '"' };
my rule Assignment-Expression { var &lt;Variable&gt; '=' &lt;Number&gt; };
my rule Function-Call { console '.' log '(' &lt;String&gt; '+' &lt;Variable&gt; '+' &lt;String&gt; ')' };

say 'var a = 3; console.log( "Hey, did you know a = " + a + "?" );' ~~
rule { &lt;Assignment-Expression&gt; ';' &lt;Function-Call&gt; ';' }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>You've seen the individual pieces before, but probably not put together quite like this. The &lt;Assignment-Expression&gt; rule matches the entirety of 'var foo = 27', and the &lt;Function-Call&gt; part matches 'console.log("Take " + foo + " down, pass them around")' Our final rule puts the pieces together, matching an assignment statement followed by a function call. I've left the ';' separators outside the &lt;Assignment-Expression&gt; and &lt;Function-Call&gt; because they separate expressions, they're not&nbsp;<strong>part</strong>&nbsp;of them.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Winding Down</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The technique applied here isn't specific to JavaScript, of course. Generally, if you can put whitespace around something without changing its semantics, you've found a token like &lt;Number&gt; or &lt;String&gt;. Figure out where those breaks are, and you're already halfway to decoding the language in question. Figuring out the higher-level rules is much more fun, and along the way you'll find yourself making notes "Okay, lists act like this, wait, can I put a &lt;List&gt;&nbsp;<strong>inside</strong>&nbsp;a list? Yes? Hey..."<br>Starting from a string, we've split it into chunks, then factored out some of those chunks into their own rules. Once we could abstract out the 32 into a number, foo_bar into a variable and figure out the String type, it's a question of putting them together in combinations, like '&lt;Variable&gt; = &lt;Number&gt;'. If you want, you can even take what we've done above and refactor it down more.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">
my rule Variable-Declaration { var &lt;Assignment-Expression&gt; }
my rule Assignment-Expression { &lt;Variable&gt; '=' ( &lt;Number&gt; | &lt;String&gt; | &lt;Variable&gt; ) }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Hopefully you can see where this is going, because this handles 'var a = 32; var b = c; var d = "hi"' along with so much more. But this will have to wait for Part 4.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>106</wp:post_id>
		<wp:post_date>2016-02-20 13:24:52</wp:post_date>
		<wp:post_date_gmt>2016-02-20 12:24:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>from-regular-expressions-to-grammars-pt-3</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516326]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026034227]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>From Regular Expressions to Grammars: Pt. 2</title>
		<link>https://perlfisher.wordpress.com/2016/02/02/from-regular-expressions-to-grammars-pt-2/</link>
		<pubDate>Tue, 02 Feb 2016 12:28:10 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=109</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>If you're not already familiar with regular expressions, please read&nbsp;<a href="http://web.archive.org/web/20170811041043/http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="noreferrer noopener">Part 1</a>&nbsp;of this tutorial first, to get caught up on the basic idea of what regular expressions are, and why you would want to use them in the first place.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Recap</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When we last left our heroes [sorry, the Game of Thrones soundtrack is on in the background] they were learning about how to refactor Perl 6 regular expressions into easy-to-digest bits. We started off with the task of searching for '2016-02-06T14:36+02:00' in a sample logfile. This slowly evolved into searching for any ISO-8601 timestamp in our sample file, by replacing the explicit digits (0 .. 9) with a generic placeholder '\d' meaning any digit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This fixes the problem of only being able to match a single timestamp but leaves behind an ugly string of '\d\d\d\d' when matching the year (I.E. four digits in a row.) We solved this by replacing '\d\d\d\d' with '\d+', which simply means "Any number of digits in a row."</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This declutters our regular expression, but at a slight cost. Our expression matches '2016-02-13T13:10+02:00', but it also matches '19116-02-13T13:10+02:00' because '\d+' doesn't tell the regular expression engine how&nbsp;<strong>many</strong>&nbsp;digits to match, it just says "Match as many as you can." This may be what you want in some situations, but not here.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>A person has got to know their limitations.</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Luckily, Perl 6 has just the expression we need. A quick scan through&nbsp;<a href="http://web.archive.org/web/20170811041043/http://doc.perl6.org/language/regexes#General_quantifier%3A_**_min..max" target="_blank" rel="noreferrer noopener">Regexes</a>&nbsp;on&nbsp;<a href="http://web.archive.org/web/20170811041043/http://docs.perl6.org/" target="_blank" rel="noreferrer noopener">docs.perl6.org</a>&nbsp;leads us to the quantifier section, and near the end of the list we find "min .. max" which tells the regular expression engine to match what's before it at least min times, and at&nbsp;<strong>most</strong>&nbsp;max times. There's even a shortcut which tells us the regex engine to match what's before it exactly&nbsp;<strong>N</strong>&nbsp;times.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my regex Date { \d ** 4 '-' \d ** 2 '-' \d ** 2 }
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This also stops the regular expression from matching '19116-02-100', which, while the sort of thing you worry about if you work at the&nbsp;<a href="http://web.archive.org/web/20170811041043/http://longnow.org/" target="_blank" rel="noreferrer noopener">Long Now foundation</a>, isn't the sort of time problem that comes up in general.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>By way of recapping, /literal string here/ matches a sequence of alphanumerics. Anything that's not alphanumeric (by the way, alphanumeric here isn't restricted to US ASCII, any character with the 'Letter' or 'Number' Unicode property qualifies) has to be quoted or escaped in some fashion, lest it be confused with a current or future metacharacter.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to make something optional, follow it with '?', like in:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">"Skyfall" ~~ /Sky 'fall'?/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This matches both 'Sky' and 'Skyfall', thus treating 'fall' as an option when matching 'Sky'. If you're being particularly diligent in writing tests, you might notice that 'Skyfalling' also matches this expression, as does 'Skyfail'.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perl 6 regular expressions, like most RE engines, stop when they've found a match. Going from left to right, in the case of 'Skyfalling', the process looks like this, roughly:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>"Skyfalling" ~~ /Sky 'fall'?/ # Try 'Sky', succeed</li><li>"Skyfalling" ~~ /Sky 'fall'?/ # Try 'fall', succeed, report success</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The RE engine has matched all of the terms in the regular expression, so after matching 'Skyfall', it's done, so even though there's more of the string left over, the match succeeds. If only there were a way to tell it the match isn't quite done&nbsp;<strong>yet</strong>.<br>Lucky for us, there is. In fact, true to Perl's nature, there are several ways, each appropriate for different situations. The most common case is that 'Skyfall' appears in a sentence, and you want to look for it in "Come to Skyfall, Mr. Bond", "Mr. Bond, come to Skyfall." or "The Sky is Falling, Mr. Bond."<br>As you can see, the term 'Skyfall' (or just 'Sky', remember the optional clause) is followed by either a ',', ' ' or '.'. You could try to match all of those combinations, and possibly miss many more because of the wealth of Unicode punctuation, or you could use the built-in '&gt;&gt;' shortcut. This stops the match at the end of the word, so this expression will now fail as you expect:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">"Skyfalling" ~~ /Sky 'fall'? &gt;&gt;/
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>For this to match, 'Skyfall' or 'Sky' have to be followed by either the end of a string, or something that's&nbsp;<strong>not</strong>&nbsp;an alphanumeric character, like '.' or ';' (which we left out in the example above, to prove a point.) So now, this regular expression matches "Sky diving today!" or "Skyfall, as it crumbles..." but not "Skyfail" or "Isle of Skye".</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>I want my M(atch)TV</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Regular expressions are pretty powerful on their own, there are entire UNIX tools dedicated to nothing but regular expressions (I.E.&nbsp;<em>grep.</em>) But sometimes it's helpful to be able to do more than just tell whether you've found a match in your input.<br>Suppose, for instance, that you're doing some DBA work, and you've been given 2 different SQL files that both have to be merged into the same database table. One looks like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">INSERT INTO tag VALUES( 1, 'Perl 6' );
INSERT INTO tag VALUES( 2, 'Moose' );
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And the other set looks&nbsp;<strong>almost</strong>&nbsp;the same:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">INSERT INTO tag VALUES( 1, 'Pearlbee' );
INSERT INTO tag VALUES( 2, 'Dancer' );
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>All of this data has to get into your tag table somehow, and the tag IDs have to be unique to boot. This sort of thing happens in real life when trying to reconstruct tables from sharded data, so it's not a theoretical problem. The solution is simple once you stumble across it - modify the first file to insert at IDs 1, 3, 5, 7, 9... and modify the other file to insert at IDs 2, 4, 6, 8 and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's dig in. We already have most of the tools we need, so let's try to match our first statement:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say "INSERT INTO tag VALUES( 1, 'Perl 6' );" ~~
/'( ' \d+ ','/
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Previously we've matched the entire statement, but here we'll just match the "( 1," portion. Regular expressions don't have to match the&nbsp;<strong>entire</strong>&nbsp;string in order to find a hit, they just have to find enough to be a unique match.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It's looking for '(' followed by an integer followed by a comma, which is exactly what '( 1,' is in our input. So we've found a match, wonderful. We can even do this in a loop like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">for @lines -&gt; $line {
  say $line ~~ /'( ' \d+ ','/
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>which is wonderful, and tells us that we've matched all of our input, confirming that we can read our SQL file. Great. Now what?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It's time to&nbsp;<strong>capture</strong>&nbsp;our data so we can do something with it. Let's introduce the capturing group, '( .. )'. This captures what the regular expression engine matches, and puts it into a variable that we can access later, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">for @lines -&gt; $line {
  if $line ~~ /'( ' ( \d+ ) ','/ {
    say "Found ID $0"
  }
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We can even capture both the ID and the tag name like so, modify the ID and write the file back out, like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">for @lines -&gt; $line {
  if $line ~~ /'( ' ( \d+ ) ',' ( \' .+ \' )/ {
    say "INSERT INTO tag VALUES( {2 * $0 - 1}, $1 );"
  }
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This recreates the old file with "INSERT INTO tag VALUES( &nbsp;1, 'foo' ); INSERT INTO tag VALUES( 3, 'bar' );" and so on, skipping every other ID. Change the formula from {2 * $0 - 1} to just {2 * $0}, and you now have two new files, one with odd IDs:&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">INSERT INTO tag VALUES( 1, 'Perl 6' ); -- 1 -&gt; (2 * 1 - 1) == 1
INSERT INTO tag VALUES( 3, 'Moose' ); -- 2 -&gt; (2 * 2 - 1) == 3
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And the other file with even IDs:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">INSERT INTO tag VALUES( 2, 'Pearlbee' ); -- 1 -&gt; (2 * 1) == 2
INSERT INTO tag VALUES( 4, 'Dancer' ); -- 2 -&gt; (2 * 2) == 4&lt;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>So now you can load the two files in any old order, and since one has the odd-numbered IDs and the other has even-numbered IDs, at the end you'll have both sets of data inserted into the database, collision-free. Incidentally, just change the constant 2 to 3 or more, and this trick generalizes to any number of files - rewrite 1,2,3 to 1, 4, 7, the next file to 2, 5, 8, and the last file to 3, 6, 9. Again, the IDs won't collide because each file's IDs goes exactly in the space left by the other two files.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You might be wondering to yourself, though, what that '.+' is doing there. We've used the '+' above, when dealing with dates, so you remember that means "One or more of what's before it." In this case, what's "before it" is just a bare '.', which we haven't seen before. This is another placeholder, and it stands for "any character", so the entire expression "( \' .+ \' )" can be read as 'Capture (...) everything that starts with a single quote, has one or more characters (we don't care what) inside, and ends with another single quote."</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>&nbsp;Coverage</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We've now covered the basic regular expression metacharacters: +, *, ? and '.'. At the end we also talked about how to actually&nbsp;<strong>use</strong>&nbsp;the captured text in Perl 6 code, and combined what we've learned along the way into a final expression that uses grouping, metacharacters and actually&nbsp;<strong>processing</strong>&nbsp;the data using a real-world example of munging a database table together from independent shards.<br>Stay tuned for the next installment in this series, where we pull what we've learned together into a Perl 6 grammar that reads and interprets JavaSrcript code in a JIT compiler.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>109</wp:post_id>
		<wp:post_date>2016-02-02 13:28:10</wp:post_date>
		<wp:post_date_gmt>2016-02-02 12:28:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>from-regular-expressions-to-grammars-pt-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026118865]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>From Regular Expressions to Grammars: Pt. 1</title>
		<link>https://perlfisher.wordpress.com/2016/02/06/from-regular-expressions-to-grammars-pt-1/</link>
		<pubDate>Sat, 06 Feb 2016 12:28:51 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=112</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->
<h2>Old-School Text Matching</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This tutorial is based around&nbsp;<a href="http://web.archive.org/web/20170811041043/https://github.com/drforr/talk-Perl6-Regex-To-Javascript" target="_blank" rel="noreferrer noopener">Perl6-Regex-To-Javascript</a>, a talk I gave at&nbsp;<a href="http://web.archive.org/web/20170811041043/https://fosdem.org/2016/" target="_blank" rel="noreferrer noopener">FOSDEM 2016</a>. We'll start out writing simple regular expressions, and slowly build the expressions out into a full-blown compiler. Our starting point will be the humble ISO-8601 timestamp, used worldwide in all sorts of logging programs. There are a few minor variants, but this is the one we're most concerned with:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">2016-02-06T14:36+02:00
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Regular expressions, for those of you that don't know, are a way to find partial matches in a potentially very large document. For the moment, you can consider it the equivalent of the 'Find' dialog in your favorite text editor.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Suppose you want to find this particular timestamp in... say, a blog posting, much like this one. Most languages have a function like Perl 6's&nbsp;<a href="http://web.archive.org/web/20170811041043/http://doc.perl6.org/routine/index" target="_blank" rel="noreferrer noopener">index</a>&nbsp;method, which searches for a substring inside a larger string, and returns either the offset if the string matches, or -1 if it can't find a match. In Perl 6, using that would look like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say index( $logfile, '2016-02-06T14:36+02:00 );
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And it would print out either -1 for no match, or a positive number telling us where to look in the logfile for our match. This is efficient and fast, and works with any string, even something your user has given as input. If you were searching for timestamps on a given day, you could even cut down your search string to just '2016-02-06T' to find all timestamps on a given day.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We've added the trailing 'T' to the timestamp because it's entirely possible that somewhere in your logfile there may be a REST query that looks like '/post/2016-02-06/' that you wouldn't want to match. That's just a user request for a posting from a given day, which could be a user in March requesting a post from last month.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You could even use the same technique to search for all timestamps in a given timezone, just looking for '+02:00'. You'd likely get even more false positives, because '+02:00' could easily appear in other places in our web logfile. One way to cut down on the number of false positives is to do 10 searches, one for '0+02:00', one for '1+02:00' and so on up to '9+02:00'.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Into the Breach</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Another way is to use a regular expression, that will search for&nbsp;<strong>exactly</strong>&nbsp;the timestamp format you're looking for with no false positives. For this, instead of the&nbsp;<em>index</em>&nbsp;function, we'll ask Perl 6 to perform smart matching on our string, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ /2016-02-06T14:36+02:00/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This will do exactly what the <em>index</em> function did above, but uses Perl 6's smartmatch operator.  Well, not quite. While it should return whether we've found a match in our logfile, what we actually get is this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">===SORRY!===<br>Unrecognized regex metacharacter - (must be quoted to match literally)<br>at /home/jgoff/Talks/Javascript/slide03.pl6:12<br>------&gt; /2016⏏-01-29T13:25+01:00/;<br>Unable to parse regex; couldn't find final '/' at /home/jgoff/Talks/Javascript/slide03.pl6:12<br>------&gt; /2016-⏏01-29T13:25+01:00/;</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>If you're used to languages like C where you get a terse one-line syntax error, or Java where you can get page-long stacktraces, this may seem like a mystery. &nbsp;For the moment let's ignore the "Unrecognized..." and "Unable..." bits and look at "(must be quoted to match literally)".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is telling us that we need to quote the dashes in our expression. In fact, this is an instance of a general rule in Perl 6 regular expressions. Anything that's not an alphanumeric character ('a'..'z', 'A'..'Z', '0'..'9') has to be quoted. So, let's do just that:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ /2016 '-' 02 '-' 06T14 ':' 36 '+' 02 ':' 00/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>And now we get back this equally strange expression:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code"> ｢2016-01-29T13:25+01:00｣
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This is just telling us that the ~~ operator matched some text, and here's the text that it matched. The ｢｣ are Japanese quotation marks, deliberately designed to stand out from the rest of the text. When you're experimenting with regular expressions, what used to be common in Perl 5 was printing out the matched string surrounded by '' so you could see&nbsp;<strong>exactly</strong>&nbsp;where the match boundaries lie. This isn't always obvious, and whitespace and return characters could cause a problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So now, Perl 6 defaults to printing the matched object with unambiguous markers that tell you exactly where the start and end of a match lie, without making you go back and add debugging statements to your code.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Generalizing</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Earlier I promised that we would make our timestamp matching more general, so it's time to make good on that promise. This logfile might have been written last year, so one thing we might want to do is match on a timestamp from either 2015 or 2016. Luckily, regular expressions like what we're using have a built-in 'or' operator, called '|'.<br>At first blush, you might think that:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ /2015 | 2016 '-' 02 '-' 06T14 ':' 36 '+' 02 ':' 00/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>would do the trick. And it will, for timestamps in 2016. It will also match anything in 2015, and by 'anything' I mean any string that happens to have '2015' in it. The '|' operator says "Match anything on the left of me or anything on my right", so while it still matches '2016-02-06T14:36+02:00' (what's on the right of the '|', it will also match anything to its left, which includes '2015', '/post/2015/02' or even '/number/120153'.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, basically we need to stop the operator from running amok, and tell it to just apply the 'or' bit to the '2015' and '2016' portion of the string, and not the entire expression. We can do that by bracketing the extent of the match, quite literally:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / [ 2015 | 2016 ] '-' 02 '-' 06T14 ':' 36 '+' 02 ':' 00/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This now will match both '2015-02-06T14...' and '2016-02-06T14...'. Which is fine if you want to match a timestamp from 2015 or 2016, but this logfile goes all the way back to 1997, and who wants to type '[ 1997 | 1998 | 1999 | 2000... 2015 ]' out in full? You could apply what we've learned above and try to be sneaky, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / [1|2] [9|0] [9|0|1] [0|1|2|3|4|5|6|7|8|9].../;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>But thankfully there's a shortcut.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Learning Shorthnd</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The [0|..|9] expression there is so commonly used that there's a convenient shortcut. Instead of writing out the range of '0'..'9' in full, we'll just tell Perl 6 that we want to match digits. While we're at it, we don't know how far back in time this logfile goes, so let's just match 4 digits instead of worrying about whether it's between 1997 and now:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / \d \d \d \d '-' 02 '-' 06T14.../;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Of course, this works for *any* of the digits in our string, so we can take what we have and rewrite it using this shorthand like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / \d\d\d\d '-' \d\d - \d\d T \d\d ':' \d\d '+' \d\d ':' \d\d/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Which now matches any timestamp that looks like &lt;digits&gt; - &lt;digits&gt; - &lt;digits&gt; etcetera. Almost any timestamp. The '+' &lt;digits&gt; : &lt;digits&gt; will only match timezones between +01 and +12, the other timezones are between -11 and -01, so we'll use the 'or' trick we learned above to match either a '+' or '-' sign, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / \d\d\d\d '-' \d\d - \d\d T \d\d ':' \d\d [ '+' | '-' ] \d\d ':' \d\d/; 
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>&nbsp;There, negative and positive timezone offsets accounted for. Well, not quite. Negative and positive timezone offsets are specified relative to Greenwich, but it has its own timezone that's not even a number, it's just called 'Z', for historical reasons. (Timezones used to be assigned letters, and Z was the end of the alphabet.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, one more change, and nesting timezone statements:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">say $logfile ~~ / \d\d\d\d '-' \d\d - \d\d T \d\d ':' \d\d [ [ '+' | '-' ] \d\d ':' \d\d | Z ] /;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading {"level":3} -->
<h3>Refactoring</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>But that '[ '+' ... Z ]' expression is getting pretty long in the tooth, it'd be nice to be able to factor that out somehow. The&nbsp;<em>regex</em>&nbsp;object comes to the rescue, and helps us clean up the code. It's basically a way to treat our regular expression as a separate object we can use later on, so if we ever find a timestamp that has a '+01:00', 'Z' and '-01:00' offset format we'll be ready for it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The&nbsp;<em>regex</em>&nbsp;object looks almost like the matching expression, except that it uses braces to say when to start and stop:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my regex Timezone { Z | [ '+' | '-' ] \d\d ':' \d\d };

say $logfile ~~ / \d\d\d\d '-' \d\d '-' \d\d T \d\d ':' \d\d &lt;Timezone&gt;/;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The &lt;..&gt; visually sets off the refactored expression from the main text, and having the expression for the Timezone separated out means that we can use this elsewhere in the code, or even put it into our own library of expressions if we wanted to. In fact, let's do that for all of the separate bits here, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my regex Date { \d\d\d\d '-' \d\d '-' \d\d };
my regex Time { \d\d ':' \d\d };
my regex Timezone { Z | [ '+' | '-' ] \d\d ':' \d\d };

say $logfile ~~ / &lt;Date&gt; T &lt;Time&gt; &lt;Timezone&gt; /;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Having all of those \d\d sitting in a row is really a bit visually disturbing, so let's factor that out:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my regex Integer { \d+ };
my regex Date { &lt;Integer&gt; '-' &lt;Integer&gt; '-' &lt;Integer&gt; };
my regex Time { &lt;Integer&gt; ':' &lt;Integer&gt; };
my regex Timezone { Z | [ '+' | '-' ] &lt;Integer&gt; ':' &lt;Integer&gt; };

say $logfile ~~ / &lt;Date&gt; T &lt;Time&gt; &lt;Timezone&gt; /;
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The '+' character in the Integer regular expression is new. It's not surrounded by quotes, so it has a special meaning. It just means "Match whatever is before me at least once." In this case "Whatever is before me" is '\d', which is shorthand for "a digit from 0 to 9" (This applies to digits in other languages as well, like ٤ in Arabic.)</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Review Time</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Regular expressions match portions of a string containing arbitrary text.</li><li>They can match literal text, such as /Jane Bloggs/.</li><li>They can also match more complicated expressions, like /\d+ Main Street/.</li><li>You can take pieces out of an expression, like /&lt;Integer&gt; Main Street/.</li><li>These pieces are named, and can be put into their own libraries.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We've only talked here about the shortcut for digits, of course there are many others, and for those you'll want to read&nbsp;<a href="http://web.archive.org/web/20170811041043/http://doc.perl6.org/language/regexes" target="_blank" rel="noreferrer noopener">Regexes</a>&nbsp;at docs.perl6.org, or your local manpages. The most common shorthand expressions are \d (which we've used above), \w which is any "word" character like 'a'..'z', 'A'..'Z' and '0'..'9', and \s which is any whitespace such as ' ', &lt;tab&gt; or &lt;carriage returm&gt;. These all work with the '+' special character, along with a few others we haven't mentioned.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to make something optional, add '?' after it. For instance, if you were looking for someone's name, you might want to check for a leading honorific, like this: / 'Dr. '? John Fredericks/ which would match 'Dr. John Fredericks' or just 'John Fredericks'.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Floating-point numbers can sometimes get you into interesting circumstances. In most languages, '123.456' is a legitimate floating-point number, which you can match with the tools you've learned with /\d+ '.' \d+/. This is to say "One or more digits, followed by a decimal, followed by one or more digits."</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The catch is that some languages require there to be digits after the decimal point, in other languages they're optional, like '123.'. Given what we've talked about above, you might think that one solution would be / \d+ '.' [ \d+ | ] /, and just leaving the "after" part of the '|' blank. This leaves behind a null (empty) regular expression, which is illegal in Perl 6. Does this mean we can't match it?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Of course we can. The trick is to use the other special character, '*'. This can be read as "Match nothing, or whatever is before me at least once." So instead of /\d+/, we use /\d*/, which we can read as "Zero or more digits."</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Confusion abounds</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Using this special character can seem counterintuitive or ever confusing. Writing our full regular expression to match a floating-point number now looks like / \d+ '.' \d* /, which can be thought of as "Match at least one digit, a decimal point, and any number of digits, or even no digits." This matches '123.', '1.23', '0.001' and of course '1.1', all of which have zero or more digits on the right side of the decimal.<br>It's pretty clear when matching digits, but when matching strings, the water gets muddier. For instance, suppose you're a biochemist searching for a sequence 'ATTT...' in a gene. Matching against /AT+/ lets you match 'AT', 'ATT', 'ATTTTTT' etcetera. All seems fine, but in reality the 'TTTTT' part is optional, so you change your expression to /AT*/. 'A' matches, 'AT', 'ATTTTT' all match, as they should. But 'AGT' matches. So does 'AGTTTTT' and 'AGGTA'. How did that 'G' get in the middle?<br>The simple answer is that it didn't. When you asked it to look for "A followed by zero or more Ts", that doesn't mean the same as "A followed by nothing or a string of T's." It searched for "A", found no "T" after it, so it stopped the search and reported a match found. The special characters '?', '+' and '*' don't "look ahead" any more than they have to.<br>This is one reason why expressions like /'"' .+ '"'/ should be viewed with a bit of caution, especially if you're dealing with strings that could have nested strings inside them. We'll talk about those expressions and more in part II of this tutorial series on expressions and grammars.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Stay Tuned for Part II</h2>
<!-- /wp:heading -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>112</wp:post_id>
		<wp:post_date>2016-02-06 13:28:51</wp:post_date>
		<wp:post_date_gmt>2016-02-06 12:28:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>from-regular-expressions-to-grammars-pt-1</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026173221]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593516643]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Bottoms Up</title>
		<link>https://perlfisher.wordpress.com/2016/01/07/bottoms-up/</link>
		<pubDate>Thu, 07 Jan 2016 12:30:47 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>After an evening of playing with bottom-up parsing, I can now explain some more of the decision-making process that goes into a grammar. Yesterday was a bit long-winded, so I'm going to gloss over a few steps. Today's PHP selection is this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">function simple() {
  $a = 0;
  for ($i = 0; $i &lt; 1000000; $i++)
    $a++;

  $thisisanotherlongname = 0;
  for ($thisisalongname = 0; $thisisalongname &lt; 1000000; $thisisalongname++) {
    $thisisanotherlongname++;
  } 
}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This very quickly tokenizes to:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>  &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';'<br>  &lt;FOR&gt; '(' &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '++' ')'<br>    &lt;SCALAR&gt; '++' ';'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';'<br>&lt;FOR&gt; '(' &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '++' ')' '{'<br>  &lt;SCALAR&gt; '++' ';'<br>  '}'<br>'}'</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The first thing I'd like to point out is that I've left structural details such as braces, parens and semicolons as text strings. In a more traditional lex/yacc (or flex/bison, if you prefer GNU) file we'd have to give all of these characters unwieldy names, so you'd end up with &lt;SCALAR&gt; &lt;POSTINCREMENT&gt; &lt;SEMICOLON&gt; or some equivalent nonsense. It's much easier to just keep the characters as they are, plus we're going to lose most of those characters as we go along.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I'm going to assume a test-driven development style, so the first test (and only test, for a while) will be to see that our grammar matches our sole test file:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">use Test; my $g = PHP.new; ok $g.parsefile( "benchmark.php" )</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This assumes that the PHP code at the start is in a file called "benchmark.php" somewhere that your test code can run it. And of course that you're running Perl 6.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This test should pass at all times, and you should be able to regularly commit your changes without having to undo&nbsp;<em>too</em>&nbsp;far down the path. In order to make sure that the test passes at all times, it's critical that we aren't too greedy. So we wouldn't start off creating a `rule function { .. }`, as you might in a more top-down design.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is also a psychological measure to keep frustration levels to a minimum. By taking small bites, we can commit small deltas at a time, and even document each rule as we go along.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Taking a bite out of crime</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Rarely has the advice "Do the least that could possibly work" been more apt. We'll start by creating a tiny, tiny rule that just factors out the '$a++', '$i++' and '$thisisalongname++' in our code. It'll look like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">rule postincrement-expression { &lt;SCALAR&gt; '++' }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>and our first change to our grammar will look like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"> grammar PHP {<br>        rule postincrement-expression { &lt;SCALAR&gt; '++' }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';'<br>      &lt;FOR&gt; '(' &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;postincrement-expression&gt; ')'<br>        &lt;postincrement-expression&gt; ';'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">    &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';'<br>    &lt;FOR&gt; '(' &lt;SCALAR&gt; '=' &lt;DIGITS&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;postincrement-expression&gt;')' '{'<br>      &lt;postincrement-expression&gt; ';'<br>      '}'<br>    '}'<br>        }<br>}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>You might have noticed that we've ignored the trailing semicolon entirely, even though we could have made it optional. We could have chosen to do just that, and the rule would have looked like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">rule postincrement-expression { &lt;SCALAR&gt; '++' ':'? }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Consider this in a larger context, for the moment. We're going to want to have some way to match entire statements, eventually. Our `postincrement-expression` could just as well be part of a much larger rule, where it could look like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">rule postincrement-operator { &lt;SCALAR&gt; '++' ';'? }<br>rule postdecrement-operator { &lt;SCALAR&gt; '--' ';'? }<br>rule statement<br>        { &lt;postincrement-operator&gt;<br>        | &lt;preincrement-operator&gt;<br>        }<br>rule statements<br>        { &lt;statement&gt;+ }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This will work, and `statements` will correctly parse '$a++;$b--;' - '$a++;' is a valid postincrement-operator, and '$b--;' is a valid postdecrement-operator. It will also correctly parse '$a++$b--;' which is&nbsp;<em>not</em>&nbsp;legal.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Also, if we keep the ';' out of the expression we can reuse this all over the place. So, the two things to take away from this short lesson are to keep your grammar rules short, and keep the structural elements like ';' out of play for as long as possible.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Assignments</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Keeping to our rule, we'll turn our attention to '$i = 0', '$a = 0' and '$isalongname = 0'. This gives us a new rule, and replacing every instance of `&lt;SCALAR&gt; '=' &lt;DIGITS&gt;` gives us:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule assignment-expression { &lt;SCALAR&gt; '=' &lt;DIGITS&gt; }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;assignment-expression&gt; ';'<br>      &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;postincrement-expression&gt; ')'<br>        &lt;postincrement-expression&gt; ';'<br> <br>    &lt;assignment-expression&gt; ';'<br>    &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; ';' &lt;postincrement-expression&gt;')' '{'<br>      &lt;postincrement-expression&gt; ';'<br> <br>      '}'<br>    '}'<br>        }<br>}        </pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2>&nbsp;The Virtues of the Approach</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Perl 6 is still a Perl, so the normal 'laziness' virtue still applies here. If you miss an instance of `&lt;SCALAR&gt; '=' &lt;DIGITS&gt;` somewhere in your test file, the test will still pass. You can replace just enough to make sure your test passes, and it's still completely valid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This way, too, there's no "flag day" where you have to change every test because you found some tiny detail and have to backtrack changes in the grammar. If we were designing the grammar top-down, changing the top-level `function-declaration` would cascade throughout the entire test suite.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Comparisons</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Similar reasoning applies to `&lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt;`, because this fragment too can be used elsewhere, say in an 'if ( $a &lt; 3 )' comparison. I'll just show the modified grammar, because the rule is fairly trivial:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule comparison-expression { &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;assignment-expression&gt; ';'<br>      &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;comparison-expression&gt; ';' &lt;postincrement-expression&gt; ')'<br>        &lt;postincrement-expression&gt; ';'<br> <br>    &lt;assignment-expression&gt; ';'<br>    &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;comparison-expression&gt; ';' &lt;postincrement-expression&gt;')' '{'<br>      &lt;postincrement-expression&gt; ';'<br> <br>      '}'<br>    '}'<br>        }<br>}    </pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2>Naked Blocks</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We've got two styles of for loop here, one with a block and one with just a single statement after it. The usual "shortest string" principle applies here, so we're going to create a `for-expression` rule that we can use before a statement&nbsp;<em>or</em>&nbsp;the start of a block, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">rule for-expression { &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;comparison-expression&gt; ';' &lt;postincrement-expression&gt; ')' }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>And the resultant grammar looks like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule for-expression<br>                { &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;comparison-expression&gt; ';' &lt;postincrement-expression&gt; ')'<br>                }<br>        rule TOP { <br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;assignment-expression&gt; ';'<br>      &lt;for-expression&gt;<br>        &lt;postincrement-expression&gt; ';'<br> <br>    &lt;assignment-expression&gt; ';'<br>      &lt;for-expression&gt; '{'<br>        &lt;postincrement-expression&gt; ';'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">      '}'<br>    '}'<br>        }<br>}  </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The TOP rule looks much simpler now, and we can almost see our goal. Let's consolidate the expressions into one place:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule expression<br>                { &lt;assignment-expression&gt; <br>                | &lt;postincrement-expression&gt; <br>                }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;expression&gt; ';'<br>      &lt;for-expression&gt;<br>        &lt;expression&gt; ';'<br> <br>      &lt;expression&gt; ';'<br>      &lt;for-expression&gt; '{'<br>        &lt;expression&gt; ';'<br>      '}'<br>    '}'<br>        }<br>}    </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Since '$a++' and '$a = 0' can occur in regular statements, we're going to group them into one `expression` rule for later use. Now, iterating on the "Don't repeat yourself" principle, we'll create one last trivial rule and make a `statement` rule.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule statement { &lt;expression&gt; ';' }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;statement&gt;<br>      &lt;for-expression&gt;<br>        &lt;statement&gt;<br> <br>      &lt;statement&gt; <br>      &lt;for-expression&gt; '{'<br>        &lt;statement&gt; <br>      '}'<br>    '}' <br>        }<br>}</pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2>Grand Unification</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's create a `for-statement` rule that collapses both kinds of 'for expressions, the ones with and without blocks:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule for-statement<br>                { &lt;for-expression &lt;statement&gt;<br>                | &lt;for-expression&gt; '{' &lt;statement&gt; '}'<br>                }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;statement&gt;<br>      &lt;for-statement&gt;<br> <br>      &lt;statement&gt;<br>      &lt;for-statement&gt;<br>    '}'<br>        }<br>}    </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>And finally, we'll create a `line` rule that unifies `statement` and `for-statement`:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule line<br>                { &lt;statement&gt;<br>                | &lt;for-expression&gt;<br>                }<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;line&gt;<br>      &lt;line&gt;</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">      &lt;line&gt;<br>      &lt;line&gt;<br>    '}'<br>        }<br>}     </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Lo and behold, we've unified all of our code into a single rule, so we can trivially replace the four instances of `&lt;line&gt;` with just one, and account for the possibility that there can be no lines in a function:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP {<br>        rule TOP {<br>    &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>      &lt;line&gt;*<br>    '}'<br>        }<br>}  </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>And there you have it. Rename 'TOP' to 'function', and we have a complete grammar:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP<br>        {<br>        rule assignment-expression { &lt;SCALAR&gt; '=' &lt;DIGITS&gt; }<br>        rule comparison-expression { &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt; }<br>        rule for-expression <br> <br>                { &lt;FOR&gt; '(' &lt;assignment-expression&gt; ';' &lt;comparison-expression&gt; ';' &lt;postincrement-expression&gt; ')'<br> <br>                }<br>        rule expression<br>                { &lt;assignment-expression&gt;<br>                | &lt;postincrement-expression&gt;<br>                }<br>        rule statement { &lt;expression&gt; ';' }<br>        rule for-statement<br>                { &lt;for-expression &lt;statement&gt;<br>                | &lt;for-expression&gt; '{' &lt;statement&gt; '}'<br>                }<br>        rule line<br>                { &lt;statement&gt;<br>                | &lt;for-expression&gt;<br>                } <br>        rule function<br>                {<br>                &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' ')' '{'<br>                &lt;line&gt;*<br>                '}'<br>                }<br>        rule TOP { &lt;function&gt; }<br>        }     </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This will parse our original benchmark.php and so much more. If you want to explore this, there are some obvious starting points, for instance you could add different comparison types like this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        rule comparison-expression<br>                { &lt;SCALAR&gt; '&lt;' &lt;DIGITS&gt;<br>                | &lt;SCALAR&gt; '&gt;=' &lt;DIGITS&gt;<br>                }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Or instead of assignment, add bitshifts with `&lt;SCALAR&gt; '&lt;&lt;' &lt;DIGITS&gt;`. Be well, and write good code.&nbsp;</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date>2016-01-07 13:30:47</wp:post_date>
		<wp:post_date_gmt>2016-01-07 12:30:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>bottoms-up</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026342191]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593517010]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Rough-and-tumble on IRC</title>
		<link>https://perlfisher.wordpress.com/2015/07/11/rough-and-tumble-on-irc/</link>
		<pubDate>Sat, 11 Jul 2015 11:36:55 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=119</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>I just put this up on Facebook, but thought it might be more interesting in general, as something of an insight as to how tempests can start in teapots on IRC.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I've been on IRC for... well, I'd be embarrassed to tell how long. A lot of that time has been trying to help people with problems, but increasingly I find myself running into situations which are simply sheer functional fixation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Put yourself in a novice programmer's shoes, starting out with a new module. You download the module, or yum install it, or local::lib, or whatever. You're in a hurry, so you grab a few lines from the SYNOPSIS section, throw it in your code, add another call that you saw later on, and are surprised&nbsp;when it doesn't work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perl has reported an error whose *very first line* is in the module you're using. You've got some background in C, so your instinct is to fixate on the very last error, which is in this new module's code. So of course this module is at fault. It's written by someone you don't know from Eve, and is probably broken in some weird way, because it's breaking in some place you didn't even *call*.Google doesn't find you any helpful hints (of course, it never does, but that doesn't stop you from trying), so your final lifeline is IRC. And so the conversation begins (OP in "", others in various margins):<br>"Hi, where do I get a new version of module Lemur?"<br>&gt; CPAN, what version are you running?<br>"Dunno, how do I find out?" ... "Okay, 1.30."<br>] Please nopaste your code, there's a pastebin in the topic<br>&gt; That's the latest, what's wrong?<br>] Please, please nopaste your code. Wherever.<br>"Dunno, it broke."<br>} Could you show us the error log?<br>) You probably need to call -&gt;new() with 'frink', 'frink', 'frink'<br>&gt; That's the latest version, so it's probably not broken, what are you doing?<br>"Stuff."<br>&gt; Show us your error log, if you're using Apache it's probably in /var/www/logs<br>] PLEASE PASTE YOUR SOURCE CODE<br>&gt; Fine, show us your code.<br>...15 minutes have passed, and by this time the guy is so frustrated by people not "fixing the module for him" that he simply gives up and logs out.<br>"&gt;" is taking the user at face value, and walking through what's a normal debugging sequence for a broken module. Prosaic and rather slow, but it does keep the OP engaged, and would probably hold enough interest to get him to the end.<br>"]" realizes that the odds are that the OP has a problem in their code, and seeing what they've tried is a quick way to debug the problem. This starts to create resistance, however because the OP may not know much perl, but he knows an error when he sees it, and it ain't in his code. So showing their *own* code is irrelevant, and the requests start to get annoying.<br>"}" also knows the problem is likely in the OP's code, and is trying a different approach to the problem. It also probably feels a bit irrelevant, but might meet with less resistance.<br>")" knows that the most likely newbie mistake is to not call the constructor correctly, and manages to intuit a fix. His voice gets lost in the sea of requests on the channel, and slowly sinks into the waves.<br>Now of course, the OP&nbsp;<strong>really</strong>&nbsp;should have used Catalyst::REST::Plugin instead of the first cgi-lib.pl based module that Google found, and saved 2000 lines of code, but they've already written off IRC as a whole because they just kept hammering him with irrelevant questions and insulting his intelligence because he knows what's wrong, just not how to fix it.<br>In a realtime conversation, the problems I intimated above are amplified tenfold and more, simply because of the interaction between IRC newbie and oldtimer. I've tried a bunch of different conversational styles in the past in order to help get people to interact, but ultimately I've been stymied by the lack of physical proximity. Maybe what we need isn't facial interaction but pheromone recognition.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>119</wp:post_id>
		<wp:post_date>2015-07-11 13:36:55</wp:post_date>
		<wp:post_date_gmt>2015-07-11 11:36:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rough-and-tumble-on-irc</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593517044]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026357996]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A Beginning... is a Very Delicate Time.</title>
		<link>https://perlfisher.wordpress.com/2015/05/10/a-beginning-is-a-very-delicate-time/</link>
		<pubDate>Sun, 10 May 2015 11:37:30 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=122</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Well, they say the first post is the hardest, so let's get this out of the way.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Yes, the title is a play on the opera&nbsp;<a href="http://web.archive.org/web/20160105123320/http://en.wikipedia.org/wiki/Les_p%C3%AAcheurs_de_perles" rel="noreferrer noopener" target="_blank">'The Pearl Fishers'</a>&nbsp;by Georges Bizet, by way of Iain Banks, mentioned in his book&nbsp;<a href="http://web.archive.org/web/20160105123320/http://en.wikipedia.org/wiki/Surface_Detail_(novel)" rel="noreferrer noopener" target="_blank">'Surface Detail'.</a>&nbsp; If you haven't read his works, hie thee unto your favorite bookstore and search for&nbsp;<a href="http://web.archive.org/web/20160105123320/http://en.wikipedia.org/wiki/Consider_Phlebas" rel="noreferrer noopener" target="_blank">'Consider Phlebas',</a><a href="http://web.archive.org/web/20160105123320/http://en.wikipedia.org/wiki/Excession" rel="noreferrer noopener" target="_blank">'Excession'</a>&nbsp;or&nbsp;<a href="http://web.archive.org/web/20160105123320/http://en.wikipedia.org/wiki/Use_of_Weapons" rel="noreferrer noopener" target="_blank">'Use of Weapons'</a>. When I'm not online or hacking offline I have a large collection of twisty puzzles, Sudoku-like puzzles and an electric concert `ukulele to keep me entertained. Or, now that the near-Russian winter has subsided I can get out and explore rural Romania.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>During the workday I do some&nbsp;<a href="http://web.archive.org/web/20160105123320/http://www.perl.org/" rel="noreferrer noopener" target="_blank">perl5</a>&nbsp;hacking, systems architecture, application profiling and performance/scaling improvements. At night I explore the undiscovered country of&nbsp;<a href="http://web.archive.org/web/20160105123320/http://www.perl6.org/" rel="noreferrer noopener" target="_blank">perl6</a>development, especially getting lost in a forest of&nbsp;<a href="http://web.archive.org/web/20160105123320/https://github.com/drforr/perl6-ANTLR4" rel="noreferrer noopener" target="_blank">abstract syntax trees</a>&nbsp;and stalking the wild hyperoperators. I also hang about on the seedy underbelly of IRC (and of course, FB) helping people with their problems, often when they least expect it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A typical topic will likely be "What's in its current tmux(1) session, preciousss?" or "What bug made me curse the most vehememtly today?" when I'm talking programming. Things will get philosophical on occasion, as time and again I see new programmers making the same mistakes as their predecessors. If they're going to make mistakes (and if you don't, you're not learning) I'd at least like them to be new ones.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And on that proverbial bombshell, it's time to start.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>122</wp:post_id>
		<wp:post_date>2015-05-10 13:37:30</wp:post_date>
		<wp:post_date_gmt>2015-05-10 11:37:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-beginning-is-a-very-delicate-time</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593517086]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026378210]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Parsing the easy way</title>
		<link>https://perlfisher.wordpress.com/2016/01/05/parsing-the-easy-way/</link>
		<pubDate>Tue, 05 Jan 2016 12:38:25 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=125</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->
<h2>Caveat Emptor&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There are many Perl 6 tutorials out there, this is not one of them. It assumes some familiarity with the language and some familiarity with regular expressions, the mini-language that Perl 6 grammars derived from. You should probably also have an idea of why someone would want to write one.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I'm going to simply talk about being able to take a file in a given language (PHP is my chosen victim, as being able to interpret PHP code in Perl 6 seems like a useful goal) and create a grammar (giant regular expression) that turns your PHP code into a Perl 6 match object which you can then walk.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If this doesn't sound useful to you, well, it isn't without a bit of additional work. In Perl 6 you can combine this matching object with a set of actions that trigger when a match is made, and&nbsp;<em>those</em>&nbsp;can do many wondrous things. For instance, an action could be made that triggers when '$a = 5;' is matched, and that could set the Perl 6 variable $a to 5, thus setting a Perl 6 variable from inside PHP 5 code.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Inspiration&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I'm working on some talks for upcoming conferences&nbsp; (FOSDEM, OSCON to name a few), and was stuck on how to explain a clean way to write and debug a parser. I'd rather not go the CS 401 generic route of creating the usual expression grammar thing that everyone uses to prove what a pain left-recursion can be, so I figured that PHP would be worthwhile, and if I can get a full PHP grammar out of a talk, so be it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, PHP being a Perl derivative means that the grammar is a bit ... dodgy. If you've ever seen the Perl lexer, you know the challenges we face. There's also the additional challenge of Perl 6 being relatively new, so it's even more important that we work in a stepwise fashion.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When I created&nbsp;<a href="http://web.archive.org/web/20160105123320/https://github.com/drforr/perl6-ANTLR4" target="_blank" rel="noreferrer noopener">perl6-ANTLR4</a>&nbsp;I had the benefit of a grammar to work from, and a reasonable idea of how I was going to convert it. With PHP I really had no such guarantee, so through trial-and-error I came across the following approach. It might not scale to the full language, but it's one way of approaching the problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I'll put the full PHP source up on GitHub once I'm convinced this is a workable approach, but the basic idea I've come up with is as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Collect the sample source into a corpus/ directory.</li><li>Write a test file that parses each file in the corpus.</li><li>Write a stub grammar whose TOP rule consists of each file in the corpus separated by an '|' alternation symbol.</li><li>Run the test file over the corpus.</li><li>For each token you find, create a 'token FOO { ... }' rule. Most of these should be formulaic, and if you're creative with an edge-case test case the rest should fall out.</li><li>Search/replace each occurrence of the token with '&lt;FOO&gt;' (and the appropriate quotes, this does get tedious.)</li><li>Repeat steps 5 and 6 until the grammar is tokenized.</li><li>For each common sequence of tokens you find, create a 'rule bar { ... }' rule that matches them.</li><li>Replace the common sequence of tokens with '&lt;bar&gt;' as need be.</li><li>Repeat steps 8 and 9 until the language is parsed, or you're out of patience.&nbsp;</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>This won't make much sense without some examples, so I'll draw on my current tackling of PHP for inspiration. Incidentally I'm impressed that the existing Perl 6 grammar construct can handle this approach, which I've already applied to sequences of upwards of several thousand tokens in a row.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Here's a sample (suitably truncated) Perl 6 test file:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">use v6;<br>use PHP::Grammar;<br>use Test;       </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">plan 1;</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">my $g = PHP::Grammar.new; </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">ok $g.parsefile('corpus-5/addglob.php');<br>ok $g.parsefile('corpus-5/addpattern.php';</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>In a nutshell, this simply tests that our PHP grammar matches the content of addglob.php and addpattern.php in our corpus-5/ directory. It should do so trivially, because the grammar file consists of almost nothing but these two files verbatim.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The starting grammar file should look like this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">use v6;<br>grammar PHP::Grammar<br>        {<br>        rule TOP<br>                {<br># corpus-5/addglob.php below, just stick it in quotes.                <br>'&lt;?php </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class a {<br>        public function test($arg = c::TESTCONSTANT) {<br>                echo __METHOD__ . "($arg)\n";<br>        }       <br> <br>        static public function staticTest() {<br>        }<br>}'      </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|<br># corpus-5/addpattern.php below, remember to escape "'&lt;'.'?php';?&gt;"<br>'#!/usr/bin/php<br>&lt;?php<br>echo \'&lt;\'.\'?php\';?&gt;</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">foreach(array("SPL", "Reflection", "Phar") as $ext) {<br>        if (!extension_loaded($ext)) {<br>                echo "$argv[0] requires PHP extension $ext.\n";<br>                exit(1);<br>        }       <br>} ?&gt;'<br>                }</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        }<br> </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This is, of course, a&nbsp;<strong>horrible</strong>&nbsp;abuse of the Perl 6 grammar system, but it's a testament to the fact that the system works, and you can incrementally develop your grammar from this baseline. This "parser" just checks its input string to see if it matches the content of addglob.php or addpattern.php, and if so, returns True. You can also ask it for the match contents, and lo and behold, it will return one or the other of the match strings.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Of course, this is only useful if you want your grammar to match the contents of these two files. We're aspiring to something a little greater than this, so bear with me. Incidentally, if you're copy/pasting the source code from this posting, please make sure the "} ?&gt;'" is flush-left in your editor.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Enclosing the entire string in quotes means that the match is open to the vagaries of whitespace, so if you're going to follow me on this journey I'd recommend copying and pasting the files yourself rather than relying on the browser to keep whitespace intact.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Bottoms Up!</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We're going to start by giving each term (like '3', 'foreach' or '"Hello world!"') in our program a name. This is backwards from the usual process, because ordinarily we'd have a grammar description in another language to guide us. The problem is that, well, most grammars like yacc, bison and ANTLR simply aren't Perl, and don't quite map onto the tools we have at our disposal.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Basically, you can think of this process as refactoring a regular expression, but an RE that's far more powerful than what you've had at your disposal with Perl 5 or its brethren and sistren.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's start this process by looking at '!extension_loaded($ext)' in the source. We'll say that everything that corresponds to a&nbsp;<strong>single</strong>&nbsp;string in the source gets labeled in all UPPER CASE. Later on this will keep us from confusing things.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, in this context, `!` is the negation operator, so we'll name it NEGATION-OP. `extension_loaded` is a function name, so we'll call it FUNCTION-NAME. Likewise `$ext` is a scalar variable, so we'll just call it SCALAR.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the grammar, we can replace `!` with `&lt;NEGATION-OP&gt;`, `extension_loaded` with `&lt;FUNCTION-NAME&gt;` and `$ext` gets replaced with `&lt;SCALAR&gt;`. You'll notice that `(` and `)` didn't get names. They're really more placeholders than anything, so we'll keep `(`, `)', `{`, `}` and so on just as raw text.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Break it Down</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>For the moment, though, we'll just give the simple things in the program names, like `static`, `function` and `class`. You can already start to see how things might group though, just looking at this new version:&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">use v6;<br>grammar PHP::Grammar<br>        {<br>        token STATIC { 'static' }<br>        token CLASS { 'class' } <br>        token PUBLIC { 'public' }<br>        token FUNCTION { 'function' }<br>        token FOREACH { 'foreach' }<br>        token AS { 'as' }<br>        token IF { 'if' }<br>        token ECHO { 'echo' }<br>        token EXIT { 'exit' }<br>        rule TOP<br>                {<br> <br>'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;PUBLIC&gt; &lt;FUNCTION&gt; 'test($arg = c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ . "($arg)\n";<br>        }'      </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>        &lt;STATIC&gt; &lt;PUBLIC&gt; &lt;FUNCTION&gt; 'staticTest() {<br>        }<br>}'      </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>|</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; '\'&lt;\'.\'?php\';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(array("SPL", "Reflection", "Phar")' &lt;AS&gt; '$ext) {'<br>        &lt;IF&gt; '(!extension_loaded($ext)) {'<br>                &lt;ECHO&gt; '"$argv[0] requires PHP extension $ext.\n";'<br>                &lt;EXIT&gt; '(1);<br>        }       <br>} ?&gt;'   </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The `token ECHO {...}` is how you assign the string 'echo' its own name, and instead of the raw text 'echo' in the program, you replace it with `&lt;ECHO&gt;`. Don't forget to replace the quotes, because you're effectively interpolating `&lt;ECHO&gt;` into the string.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We've only replaced the static text here, so it's it's still only going to be able to match the original file contents, but that will change soon enough. You can start to see a bit of how we might be able to refactor some of this at a later date.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Keeping in mind that Perl 6 grammars are essentially your old regular expressions on steroids, look at `&lt;STATIC&gt; &lt;PUBLIC&gt; &lt;FUNCTION&gt;`. PHP doesn't require that all functions be statically declared, so we could change that to `&lt;STATIC&gt;?` to make both 'static public function foo(...)' and 'public function foo(...)' legal.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Careful about how far you take this though. If you make both 'static' and 'public' optional like so, `&lt;STATIC&gt;? &lt;PUBLIC&gt;? &lt;FUNCTION&gt;`, this makes 'static function foo(...)' a legal expression. Luckily it is legal in PHP, but other languages might not allow that.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Functionality</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The goal is to give every term here a label, so let's pick on something else. `test(...)` and `selfTest()` seem like the next obvious candidates. Now, our ultimate goal is not to just match these two files, but any PHP program text, and my years of programming experience has led me to deduce that people are going to want to name functions something other than `test` and `selfTest`, so we need to accommodate those people.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We need a way to match a whole range of identifier characters, and lucky for us, this looks just like it did in Perl 5, using the `\w` character class.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&nbsp;grammar PHP::Grammar<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token FUNCTION-NAME { \w+ }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule TOP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br><br>'&lt;?php'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&lt;CLASS&gt; 'a {'&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '($arg = c::TESTCONSTANT) {'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ECHO&gt; '__METHOD__ . "($arg)\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;STATIC&gt; &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; '\'&lt;\'.\'?php\';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '("SPL", "Reflection", "Phar")' &lt;AS&gt; '$ext) {'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '($ext)) {'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ECHO&gt; '"$argv[0] requires PHP extension $ext.\n";'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EXIT&gt; '(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>} ?&gt;'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2>A brief aside</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You might be thinking "Whoa there, if we're just going to match any old string of letters, haven't we lost something here? Where does this go?" Well, it's really a named capture in a slightly different guise. Back in Perl 5 you were used to doing:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">"2+3" =~ /(\d+) \+ (\d+)/x</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>&nbsp;in order to capture the values `2` and `3` in $1 and $2 respectively, and may even have used the named capture feature. In Perl 6, these get renumbered to $0 and $1 respectively, and even better, you get a hash that you can play with, so a statement like:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">"doStuff()" ~~ /&lt;FUNCTION-NAME&gt; '(' ')'/</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>&nbsp;will capture 'doStuff' in $/{'FUNCTION-NAME'}. Not only do you have a hash to play with, but later on we'll exploit the fact that this $/ object is actually a multi-tiered data structure, so you can put named captures&nbsp;<strong>inside</strong>&nbsp;named captures to create a hash of hashes for you, and this all happens automatically.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Syntax and Semantics</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There's one other thing that got swept under the rug here. Since `test` and `staticTest` both got abstracted away under `&lt;FUNCTION-NAME&gt;`, it's entirely possible that once the parser is fully complete, `function dup(){} function dup(){}` will<strong>&nbsp;</strong>actually match, even though it might not be legal PHP code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What we're building doesn't distinguish between&nbsp;<em>legal</em>&nbsp;code and&nbsp;<em>syntactically correct</em>&nbsp;code. Generally speaking, if the compiler immediately returns a syntax error, then your parser should be able to catch it. Otherwise don't worry about it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For testing purposes it is a good idea to add some corner cases like these, but in general the parser should be very laid-back about what it accepts. `my $x; my $x;` may throw a "redefined value" warning, but the parser should just see two variable declarations in a row, put them into a syntax tree, and go on about its business.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>And back to our story.</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now, let's factor out the strings. For our purposes, strings are nothing but a `"`, some stuff that's&nbsp;<strong>not</strong>&nbsp;a `"`, then a final `"` to cap it all off. In Perl 6 regex terms, that looks like this (with single-quoted strings thrown in as well):</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        token DQ-STRING { '"' &lt;-[ " ]&gt; '"' }<br>        token SQ-STRING { '\'' &lt;-[ ' ]&gt; '\'' }<br>        rule TOP<br>                {</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'&lt;?php' <br>&lt;CLASS&gt; 'a {'<br>        &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '($arg = c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;STATIC&gt; &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '() {<br>        }<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; &lt;SQ-STRING&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; '$ext) {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '($ext)) {'<br>                &lt;ECHO&gt; &lt;DQ-STRING&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Let's now do the big one, scalars. They're just like function names, but with a leading `$`.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        token SCALAR { '$' \w+ }<br>        rule TOP<br>                {               <br>'&lt;?php'         <br>&lt;CLASS&gt; 'a {'<br>        &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; '= c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; '; <br>        }'      <br> <br>        &lt;STATIC&gt; &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; '() {<br>        }<br>}'      </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; &lt;SQ-STRING&gt; ';&gt;?'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;ECHO&gt; &lt;DQ-STRING&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>I'd like to point out that if you've been following along in your own Perl 6 terminal window, that the test cases we've been running haven't failed, or had to be rewritten, yet we've been refactoring the grammar like mad. We may be able to continue this way until the end, running more test files through our corpus of parsing until it handles PHP in all its glory. We may not. At each stage, though, the diffs between files make it clear what we've factored out, and what might have gone wrong.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>New Rules</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now that a lot of the underlying confusion has been stripped away, let's think a little bigger. A lot of dealing with grammars is repeating the mantra "Don't repeat yourself." See how `&lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt;` repeats? Let's refactor that out by creating a new rule. We'll also create another convention that when we clump UPPER-CASE names together, we'll give the clump a lower-case name.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since it's almost a function declaration, let's call it that, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        rule function-declaration { &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; }<br>        rule TOP<br>                {<br>'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;function-declaration&gt; '(' &lt;SCALAR&gt; '= c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;STATIC&gt; &lt;function-declaration&gt; '() {<br>        }<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; &lt;SQ-STRING&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;ECHO&gt; &lt;DQ-STRING&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>And that's how you create your own rules. Nothing to it, really. You'll notice that we've sort of left `&lt;STATIC&gt;` behind, though. When you're just starting out, it's best to keep your new rules simple, which means they should be just common sequences of terms.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But again, you can remember too that these rules are just regular expressions in disguise, so you can use your old friend `?` to declare something optional:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        rule function-declaration { &lt;STATIC&gt;? &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; }<br>        rule TOP<br>                {</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;function-declaration&gt; '(' &lt;SCALAR&gt; '= c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;function-declaration&gt; '() {<br>        }<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;ECHO&gt; &lt;SQ-STRING&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;ECHO&gt; &lt;DQ-STRING&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Just like in regular expressions, `?` makes a name optional. You could make `&lt;PUBLIC&gt;` optional as well, since having a `function foo()` with no `static` or `public` declaration is probably legal, but it might be better to verify that with another corpus file.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Expressionless</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now we're going to focus our attention on the `&lt;ECHO&gt; &lt;DQ-STRING&gt;` and `&lt;ECHO&gt; &lt;SQ-STRING&gt;` elements. Since most of the syntax we're using has much in common with regular expressions, you might guess that we can say "either &lt;DQ-STRING&gt; or &lt;SQ-STRING&gt;" with `( &lt;DQ-STRING&gt; | &lt;SQ-STRING&gt; )`, and you'd be right:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        rule echo-expression { &lt;ECHO&gt; ( &lt;SQ-STRING&gt; | &lt;DQ-STRING&gt; ) }<br>        rule TOP<br>                {</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;function-declaration&gt; '(' &lt;SCALAR&gt; '= c::TESTCONSTANT) {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;function-declaration&gt; '() {<br>        }<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;echo-expression&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;echo-expression&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }       <br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>There can be a little trap hiding here, though. This alternation works because the two string types differ in their first character, so the parser doesn't have to look ahead to choose which term to follow. If they differ further down, especially if there are `+` or `*` involved, there could be issues.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Generally you can get rid of these issues by reordering the alternatives, but sometimes it can be something of a waterbed problem. Let's slightly refactor the text after the `&lt;function-declaration&gt;` so we can see another DRY hiding:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"> grammar PHP::Grammar<br>        {<br>        rule echo-expression { &lt;ECHO&gt; ( &lt;SQ-STRING&gt; | &lt;DQ-STRING&gt; ) }<br>        rule TOP<br>                {</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;function-declaration&gt; '(' &lt;SCALAR&gt; '= c::TESTCONSTANT' ')' {'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;function-declaration&gt; '(' ')' {<br>        }<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;echo-expression&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;echo-expression&gt; ';'<br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2>Getting argumentative</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Separating the `(` `)` makes it a little clearer that we have `&lt;function-declaration&gt; '(' {stuff} ')'` and `&lt;function-declaration&gt; '(' ')'`, which kind of makes {stuff} an option, doesn't it?</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">grammar PHP::Grammar<br>        {<br>        rule function-declaration<br>                {<br>                &lt;STATIC&gt;? &lt;PUBLIC&gt; &lt;FUNCTION&gt; &lt;FUNCTION-NAME&gt; <br>                '('<br>                ( &lt;SCALAR&gt; '= c::TESTCONSTANT' )?<br>                ')'<br>                }<br>        rule TOP<br>                {<br> <br>'&lt;?php'<br>&lt;CLASS&gt; 'a {'<br>        &lt;function-declaration&gt; '{'<br>                &lt;ECHO&gt; '__METHOD__ .' &lt;DQ-STRING&gt; ';<br>        }'      </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">        &lt;function-declaration&gt; '{'<br>        '}<br>}'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">|</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">'#!/usr/bin/php<br>&lt;?php'<br>&lt;echo-expression&gt; ';?&gt;'</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">&lt;FOREACH&gt; '(' &lt;FUNCTION-NAME&gt; '(' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ',' &lt;DQ-STRING&gt; ')' &lt;AS&gt; &lt;SCALAR&gt; ') {'<br>        &lt;IF&gt; '(!' &lt;FUNCTION-NAME&gt; '(' &lt;SCALAR&gt; ')) {'<br>                &lt;echo-expression&gt; ';' <br>                &lt;EXIT&gt; '(1);<br>        }<br>} ?&gt;'<br>                }<br>        }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>So, by treating the `&lt;SCALAR&gt; '=...'` as an option, we've factored even more code out, and I hope that by now you can see where to take this. Basically, from here the idea is to take a file, add it to your test suite, boil it down as far as you can, then repeat with a new test file. After two or three iterations of this process, you don't really even need to add the new test file, you'll just be able to add a new test case (please, please don't forget the test case and corner cases) and plug in the new bit of grammar.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And of course most of this really isn't necessary if you have a grammar to work from, but I've found that even when you do have a grammar to work from, sometimes it helps to tear it down and rebuild it from scratch.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Denoument</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I'll be the first to admit that going through an entire corpus of PHP files this way is impractical. But I've also tried going at this problem from the other end, namely taking a large grammar and beating on it until it managed to process the files I wanted it to read. (At least until the GLR, that is, but that's a separate issue.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, even for a fairly large language, you don't have to take each file and tokenize them by hand, it soon becomes apparent what are tokens and what aren't, and Perl 6 has convenient whitespace rules to help the boundaries fall where they may.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I think the issue is the grammar debugger/tracer isn't&nbsp;<em>quite</em>&nbsp;tooled up to where I'd like it to be, and I'm going to take a crack at it after or maybe during FOSDEM.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The last time I checked, the tracer spit out the entire AST in raw .perl format, albeit with some indentation. What I really need to get out of that is simply the text with an &lt;eject&gt; character where the parser bailed, and a traceback of what rules it was running at the time it failed. That would help me more than the raw .perl format, and again I can probably do it, and want to take some time to straighten out the issue. I think the tools give me enough access to do what I want, and at that point I'd love to be able to throw a live debugger into a tmux session, and be able to tweak/rerun the debugging, say "Oh, it was in the expression-core rule at 'a := foo' and that binding expression hasn't been written yet."</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In my copious free time, I guess. In any case, I hope I've laid bare some of the mysteries awaiting you in the depths of the Perl 6 grammars.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thanks and until next time,</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Happy coding!</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>125</wp:post_id>
		<wp:post_date>2016-01-05 13:38:25</wp:post_date>
		<wp:post_date_gmt>2016-01-05 12:38:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>parsing-the-easy-way</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46026515098]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593517374]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Home</title>
		<link>https://perlfisher.wordpress.com/blog/</link>
		<pubDate>Tue, 30 Jun 2020 10:53:01 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?page_id=5</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:cover {"url":"https:\/\/iamtakashinuxtest20200131105336.files.wordpress.com\/2020\/01\/qi-bin-w4hbafegiac-unsplash.jpg","id":26,"dimRatio":10,"align":"full"} -->
<div class="wp-block-cover alignfull has-background-dim-10 has-background-dim" style="background-image:url('https://iamtakashinuxtest20200131105336.files.wordpress.com/2020/01/qi-bin-w4hbafegiac-unsplash.jpg');"><div class="wp-block-cover__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":8,"column1DesktopOffset":2,"column1TabletSpan":8,"column1MobileSpan":4,"column2DesktopOffset":4,"className":"column1-desktop-grid__span-8 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-8 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading {"align":"center","level":1} -->
<h1 class="has-text-align-center">Welcome to your new site.</h1>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center">Welcome to your new site! You can edit this page by clicking on the Edit link. For more information about customizing your site check out <a href="https://href.li/?http://learn.wordpress.com/">http://learn.wordpress.com/</a></p>
<!-- /wp:paragraph -->

<!-- wp:buttons {"align":"center"} -->
<div class="wp-block-buttons aligncenter"><!-- wp:button -->
<div class="wp-block-button"><a class="wp-block-button__link" href="http://learn.wordpress.com" title="learn.wordpress.com">Learn more</a></div>
<!-- /wp:button --></div>
<!-- /wp:buttons --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:cover -->

<!-- wp:group {"backgroundColor":"background","align":"full"} -->
<div class="wp-block-group alignfull has-background-background-color has-background"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":12,"column1TabletSpan":8,"column1MobileSpan":4,"column2DesktopOffset":3,"className":"column1-desktop-grid__span-12 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-12 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading {"level":4} -->
<h4>Latest from the Blog</h4>
<!-- /wp:heading -->

<!-- wp:a8c/blog-posts {"imageShape":"uncropped","showAuthor":false,"showAvatar":false,"postLayout":"grid","typeScale":3} /--></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->

<!-- wp:group {"backgroundColor":"foreground-dark","align":"full"} -->
<div class="wp-block-group alignfull has-foreground-dark-background-color has-background"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":3,"column1DesktopOffset":2,"column1TabletSpan":4,"column1MobileSpan":4,"column2DesktopSpan":5,"column2TabletSpan":4,"column2MobileSpan":4,"column3DesktopOffset":3,"className":"column1-desktop-grid__span-3 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column2-desktop-grid__span-5 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-4 column1-tablet-grid__row-1 column2-tablet-grid__span-4 column2-tablet-grid__start-5 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-3 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column2-desktop-grid__span-5 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-4 column1-tablet-grid__row-1 column2-tablet-grid__span-4 column2-tablet-grid__start-5 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:paragraph {"align":"left","fontSize":"huge"} -->
<p class="has-text-align-left has-huge-font-size">Get new content delivered directly to your inbox.</p>
<!-- /wp:paragraph --></div>
<!-- /wp:jetpack/layout-grid-column -->

<!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:jetpack/subscriptions -->
<div class="wp-block-jetpack-subscriptions">[jetpack_subscription_form show_only_email_and_button="true" custom_background_button_color="undefined" custom_text_button_color="undefined" submit_button_text="Subscribe" submit_button_classes="undefined" show_subscribers_total="false" ]</div>
<!-- /wp:jetpack/subscriptions --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>5</wp:post_id>
		<wp:post_date>2020-06-30 10:53:01</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:53:01</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>blog</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_front_page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_front_page]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Blog</title>
		<link>https://perlfisher.wordpress.com/blog-2/</link>
		<pubDate>Tue, 30 Jun 2020 10:53:00 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?page_id=6</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:cover {"url":"https:\/\/iamtakashinuxtest20200131105336.files.wordpress.com\/2020\/01\/qi-bin-w4hbafegiac-unsplash.jpg","id":26,"dimRatio":10,"align":"full"} -->
<div class="wp-block-cover alignfull has-background-dim-10 has-background-dim" style="background-image:url('https://iamtakashinuxtest20200131105336.files.wordpress.com/2020/01/qi-bin-w4hbafegiac-unsplash.jpg');"><div class="wp-block-cover__inner-container"></div></div>
<!-- /wp:cover -->

<!-- wp:spacer {"height":64,"className":"desktop-only"} -->
<div style="height:64px;" aria-hidden="true" class="wp-block-spacer desktop-only"></div>
<!-- /wp:spacer -->

<!-- wp:a8c/blog-posts {"moreButton":true,"showAvatar":false,"postsToShow":10} /-->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide" />
<!-- /wp:separator -->

<!-- wp:heading {"align":"left","level":3} -->
<h3 class="has-text-align-left">Follow My Blog</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"left"} -->
<p class="has-text-align-left">Get new content delivered directly to your inbox.</p>
<!-- /wp:paragraph -->

<!-- wp:jetpack/subscriptions -->
<div class="wp-block-jetpack-subscriptions">[jetpack_subscription_form show_only_email_and_button="true" custom_background_button_color="undefined" custom_text_button_color="undefined" submit_button_text="Subscribe" submit_button_classes="undefined" show_subscribers_total="false" ]</div>
<!-- /wp:jetpack/subscriptions -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date>2020-06-30 10:53:00</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:53:00</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>blog-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[blog]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Contact</title>
		<link>https://perlfisher.wordpress.com/contact/</link>
		<pubDate>Tue, 30 Jun 2020 10:52:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?page_id=7</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph {"align":"left"} -->
<p class="has-text-align-left">Don't hesitate to reach out with the contact information below, or send a message using the form.</p>
<!-- /wp:paragraph -->

<!-- wp:spacer {"height":32,"className":"desktop-only"} -->
<div style="height:32px;" aria-hidden="true" class="wp-block-spacer desktop-only"></div>
<!-- /wp:spacer -->

<!-- wp:columns {"align":"wide","className":"has-2-columns"} -->
<div class="wp-block-columns alignwide has-2-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:heading {"align":"left"} -->
<h2 class="has-text-align-left">Get in Touch</h2>
<!-- /wp:heading -->

<!-- wp:jetpack/contact-info -->
<div class="wp-block-jetpack-contact-info"><!-- wp:jetpack/address {"address":"10 Street Road","city":"City","postal":"10100","country":"USA"} -->
<div class="wp-block-jetpack-address"><div class="jetpack-address__address jetpack-address__address1">10 Street Road</div><div><span class="jetpack-address__city">City</span>, <span class="jetpack-address__region"></span> <span class="jetpack-address__postal">10100</span></div><div class="jetpack-address__country">USA</div></div>
<!-- /wp:jetpack/address -->

<!-- wp:jetpack/email {"email":"myemail@example.com"} -->
<div class="wp-block-jetpack-email"><a href="mailto:myemail@example.com">myemail@example.com</a></div>
<!-- /wp:jetpack/email -->

<!-- wp:jetpack/phone {"phone":"(123) 456-7890"} -->
<div class="wp-block-jetpack-phone"><a href="tel:1234567890">(123) 456-7890</a></div>
<!-- /wp:jetpack/phone --></div>
<!-- /wp:jetpack/contact-info -->

<!-- wp:social-links -->
<ul class="wp-block-social-links"><!-- wp:social-link-facebook /-->

<!-- wp:social-link-twitter /-->

<!-- wp:social-link-instagram {"url":"instagram.com"} /-->

<!-- wp:social-link-linkedin /-->

<!-- wp:social-link-youtube /-->

<!-- wp:social-link-facebook /-->

<!-- wp:social-link-facebook {"url":"facebook.com"} /-->

<!-- wp:social-link-twitter {"url":"twitter.com"} /-->

<!-- wp:social-link-wordpress {"url":"wordpress.com"} /--></ul>
<!-- /wp:social-links --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:heading {"align":"left"} -->
<h2 class="has-text-align-left">Send Us a Message</h2>
<!-- /wp:heading -->

<!-- wp:jetpack/contact-form -->
<!-- wp:jetpack/field-name {"required":true} /-->

<!-- wp:jetpack/field-email {"label":"Email","required":true} /-->

<!-- wp:jetpack/field-url /-->

<!-- wp:jetpack/field-textarea {"required":true} /-->
<!-- /wp:jetpack/contact-form --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>7</wp:post_id>
		<wp:post_date>2020-06-30 10:52:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:52:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>contact</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[contact]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_g_feedback_shortcode_0bfebc3f6b8d9a4ec37c49217b82b005a48a5b6c</wp:meta_key>
			<wp:meta_value><![CDATA[
[contact-field required="1" type="name" label="Name"/]

[contact-field label="Email" required="1" type="email"/]

[contact-field type="url" label="Website"/]

[contact-field required="1" type="textarea" label="Message"/]
]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_g_feedback_shortcode_atts_0bfebc3f6b8d9a4ec37c49217b82b005a48a5b6c</wp:meta_key>
			<wp:meta_value><![CDATA[a:9:{s:2:"to";s:23:"theperlfisher@gmail.com";s:7:"subject";s:25:"[The Perl Fisher] Contact";s:12:"show_subject";s:2:"no";s:6:"widget";i:0;s:2:"id";i:7;s:18:"submit_button_text";s:6:"Submit";s:14:"customThankyou";s:0:"";s:21:"customThankyouMessage";s:30:"Thank you for your submission!";s:22:"customThankyouRedirect";s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>About</title>
		<link>https://perlfisher.wordpress.com/about/</link>
		<pubDate>Tue, 30 Jun 2020 10:52:58 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?page_id=8</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:spacer {"height":20} -->
<div style="height:20px;" aria-hidden="true" class="wp-block-spacer"></div>
<!-- /wp:spacer -->

<!-- wp:group {"align":"full"} -->
<div class="wp-block-group alignfull"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":3,"column1DesktopOffset":1,"column1TabletSpan":3,"column1MobileSpan":4,"column2DesktopSpan":6,"column2DesktopOffset":1,"column2TabletSpan":5,"column2MobileSpan":4,"column3DesktopOffset":3,"column3TabletOffset":1,"className":""} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-3 column1-desktop-grid__start-2 column1-desktop-grid__row-1 column2-desktop-grid__span-6 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-3 column1-tablet-grid__row-1 column2-tablet-grid__span-5 column2-tablet-grid__start-4 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:image {"id":698,"sizeSlug":"full","className":"is-style-circle-mask"} -->
<figure class="wp-block-image size-full is-style-circle-mask"><img src="https://a8ctm1.files.wordpress.com/2020/01/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg" alt="" class="wp-image-698" /></figure>
<!-- /wp:image --></div>
<!-- /wp:jetpack/layout-grid-column -->

<!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading -->
<h2>Introduce yourself – who you are, what you do, and where you are.</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This is an example of an about page. Unlike posts, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or <a href="//wordpress.com/page">add another page</a>.</p>
<!-- /wp:paragraph --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>8</wp:post_id>
		<wp:post_date>2020-06-30 10:52:58</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:52:58</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>about</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[about-3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/19/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:01 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/19/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>19</wp:post_id>
		<wp:post_date>2020-06-30 10:58:01</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:01</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>19</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/20/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/20/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>20</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>20</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/21/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/21/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>21</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/22/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/22/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>22</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>22</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Facebook</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/facebook/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/facebook/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>facebook</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[23]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://facebook.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Twitter</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/twitter/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/twitter/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>24</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>twitter</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[24]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://twitter.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Instagram</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/instagram/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/instagram/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>25</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>instagram</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[25]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://instagram.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Pinterest</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/pinterest/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/pinterest/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>pinterest</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://pinterest.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Home</title>
		<link>https://perlfisher.wordpress.com/blog-3/</link>
		<pubDate>Tue, 30 Jun 2020 10:12:56 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?page_id=5</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:cover {"url":"https:\/\/iamtakashinuxtest20200131105336.files.wordpress.com\/2020\/01\/qi-bin-w4hbafegiac-unsplash.jpg","id":26,"dimRatio":10,"align":"full"} -->
<div class="wp-block-cover alignfull has-background-dim-10 has-background-dim" style="background-image:url('https://iamtakashinuxtest20200131105336.files.wordpress.com/2020/01/qi-bin-w4hbafegiac-unsplash.jpg');"><div class="wp-block-cover__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":8,"column1DesktopOffset":2,"column1TabletSpan":8,"column1MobileSpan":4,"column2DesktopOffset":4,"className":"column1-desktop-grid__span-8 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-8 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading {"align":"center","level":1} -->
<h1 class="has-text-align-center">Welcome to your new site.</h1>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center">Welcome to your new site! You can edit this page by clicking on the Edit link. For more information about customizing your site check out <a href="https://href.li/?http://learn.wordpress.com/">http://learn.wordpress.com/</a></p>
<!-- /wp:paragraph -->

<!-- wp:buttons {"align":"center"} -->
<div class="wp-block-buttons aligncenter"><!-- wp:button -->
<div class="wp-block-button"><a class="wp-block-button__link" href="http://learn.wordpress.com" title="learn.wordpress.com">Learn more</a></div>
<!-- /wp:button --></div>
<!-- /wp:buttons --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:cover -->

<!-- wp:group {"backgroundColor":"background","align":"full"} -->
<div class="wp-block-group alignfull has-background-background-color has-background"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":12,"column1TabletSpan":8,"column1MobileSpan":4,"column2DesktopOffset":3,"className":"column1-desktop-grid__span-12 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-12 column1-desktop-grid__row-1 column1-tablet-grid__span-8 column1-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading {"level":4} -->
<h4>Latest from the Blog</h4>
<!-- /wp:heading -->

<!-- wp:a8c/blog-posts {"imageShape":"uncropped","showAuthor":false,"showAvatar":false,"postLayout":"grid","typeScale":3} /--></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->

<!-- wp:group {"backgroundColor":"foreground-dark","align":"full"} -->
<div class="wp-block-group alignfull has-foreground-dark-background-color has-background"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":3,"column1DesktopOffset":2,"column1TabletSpan":4,"column1MobileSpan":4,"column2DesktopSpan":5,"column2TabletSpan":4,"column2MobileSpan":4,"column3DesktopOffset":3,"className":"column1-desktop-grid__span-3 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column2-desktop-grid__span-5 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-4 column1-tablet-grid__row-1 column2-tablet-grid__span-4 column2-tablet-grid__start-5 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-3 column1-desktop-grid__start-3 column1-desktop-grid__row-1 column2-desktop-grid__span-5 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-4 column1-tablet-grid__row-1 column2-tablet-grid__span-4 column2-tablet-grid__start-5 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:paragraph {"align":"left","fontSize":"huge"} -->
<p class="has-text-align-left has-huge-font-size">Get new content delivered directly to your inbox.</p>
<!-- /wp:paragraph --></div>
<!-- /wp:jetpack/layout-grid-column -->

<!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:jetpack/subscriptions -->
<div class="wp-block-jetpack-subscriptions">[jetpack_subscription_form show_only_email_and_button="true" custom_background_button_color="undefined" custom_text_button_color="undefined" submit_button_text="Subscribe" submit_button_classes="undefined" show_subscribers_total="false" ]</div>
<!-- /wp:jetpack/subscriptions --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>36</wp:post_id>
		<wp:post_date>2020-06-30 10:12:56</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:12:56</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>blog-3</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_front_page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_front_page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Blog</title>
		<link>https://perlfisher.wordpress.com/blog-2-2/</link>
		<pubDate>Tue, 30 Jun 2020 10:12:55 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?page_id=6</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:cover {"url":"https:\/\/iamtakashinuxtest20200131105336.files.wordpress.com\/2020\/01\/qi-bin-w4hbafegiac-unsplash.jpg","id":26,"dimRatio":10,"align":"full"} -->
<div class="wp-block-cover alignfull has-background-dim-10 has-background-dim" style="background-image:url('https://iamtakashinuxtest20200131105336.files.wordpress.com/2020/01/qi-bin-w4hbafegiac-unsplash.jpg');"><div class="wp-block-cover__inner-container"></div></div>
<!-- /wp:cover -->

<!-- wp:spacer {"height":64,"className":"desktop-only"} -->
<div style="height:64px;" aria-hidden="true" class="wp-block-spacer desktop-only"></div>
<!-- /wp:spacer -->

<!-- wp:a8c/blog-posts {"moreButton":true,"showAvatar":false,"postsToShow":10} /-->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide" />
<!-- /wp:separator -->

<!-- wp:heading {"align":"left","level":3} -->
<h3 class="has-text-align-left">Follow My Blog</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"left"} -->
<p class="has-text-align-left">Get new content delivered directly to your inbox.</p>
<!-- /wp:paragraph -->

<!-- wp:jetpack/subscriptions -->
<div class="wp-block-jetpack-subscriptions">[jetpack_subscription_form show_only_email_and_button="true" custom_background_button_color="undefined" custom_text_button_color="undefined" submit_button_text="Subscribe" submit_button_classes="undefined" show_subscribers_total="false" ]</div>
<!-- /wp:jetpack/subscriptions -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>37</wp:post_id>
		<wp:post_date>2020-06-30 10:12:55</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:12:55</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>blog-2-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[blog]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Contact</title>
		<link>https://perlfisher.wordpress.com/contact-2/</link>
		<pubDate>Tue, 30 Jun 2020 10:12:54 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?page_id=7</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph {"align":"left"} -->
<p class="has-text-align-left">Don't hesitate to reach out with the contact information below, or send a message using the form.</p>
<!-- /wp:paragraph -->

<!-- wp:spacer {"height":32,"className":"desktop-only"} -->
<div style="height:32px;" aria-hidden="true" class="wp-block-spacer desktop-only"></div>
<!-- /wp:spacer -->

<!-- wp:columns {"align":"wide","className":"has-2-columns"} -->
<div class="wp-block-columns alignwide has-2-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:heading {"align":"left"} -->
<h2 class="has-text-align-left">Get in Touch</h2>
<!-- /wp:heading -->

<!-- wp:jetpack/contact-info -->
<div class="wp-block-jetpack-contact-info"><!-- wp:jetpack/address {"address":"10 Street Road","city":"City","postal":"10100","country":"USA"} -->
<div class="wp-block-jetpack-address"><div class="jetpack-address__address jetpack-address__address1">10 Street Road</div><div><span class="jetpack-address__city">City</span>, <span class="jetpack-address__region"></span> <span class="jetpack-address__postal">10100</span></div><div class="jetpack-address__country">USA</div></div>
<!-- /wp:jetpack/address -->

<!-- wp:jetpack/email {"email":"myemail@example.com"} -->
<div class="wp-block-jetpack-email"><a href="mailto:myemail@example.com">myemail@example.com</a></div>
<!-- /wp:jetpack/email -->

<!-- wp:jetpack/phone {"phone":"(123) 456-7890"} -->
<div class="wp-block-jetpack-phone"><a href="tel:1234567890">(123) 456-7890</a></div>
<!-- /wp:jetpack/phone --></div>
<!-- /wp:jetpack/contact-info -->

<!-- wp:social-links -->
<ul class="wp-block-social-links"><!-- wp:social-link-facebook /-->

<!-- wp:social-link-twitter /-->

<!-- wp:social-link-instagram {"url":"instagram.com"} /-->

<!-- wp:social-link-linkedin /-->

<!-- wp:social-link-youtube /-->

<!-- wp:social-link-facebook /-->

<!-- wp:social-link-facebook {"url":"facebook.com"} /-->

<!-- wp:social-link-twitter {"url":"twitter.com"} /-->

<!-- wp:social-link-wordpress {"url":"wordpress.com"} /--></ul>
<!-- /wp:social-links --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:heading {"align":"left"} -->
<h2 class="has-text-align-left">Send Us a Message</h2>
<!-- /wp:heading -->

<!-- wp:jetpack/contact-form -->
<!-- wp:jetpack/field-name {"required":true} /-->

<!-- wp:jetpack/field-email {"label":"Email","required":true} /-->

<!-- wp:jetpack/field-url /-->

<!-- wp:jetpack/field-textarea {"required":true} /-->
<!-- /wp:jetpack/contact-form --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>38</wp:post_id>
		<wp:post_date>2020-06-30 10:12:54</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:12:54</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>contact-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[contact]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_g_feedback_shortcode_atts_0bfebc3f6b8d9a4ec37c49217b82b005a48a5b6c</wp:meta_key>
			<wp:meta_value><![CDATA[a:9:{s:2:"to";s:23:"theperlfisher@gmail.com";s:7:"subject";s:25:"[The Perl Fisher] Contact";s:12:"show_subject";s:2:"no";s:6:"widget";i:0;s:2:"id";i:38;s:18:"submit_button_text";s:6:"Submit";s:14:"customThankyou";s:0:"";s:21:"customThankyouMessage";s:30:"Thank you for your submission!";s:22:"customThankyouRedirect";s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_g_feedback_shortcode_0bfebc3f6b8d9a4ec37c49217b82b005a48a5b6c</wp:meta_key>
			<wp:meta_value><![CDATA[
[contact-field required="1" type="name" label="Name"/]

[contact-field label="Email" required="1" type="email"/]

[contact-field type="url" label="Website"/]

[contact-field required="1" type="textarea" label="Message"/]
]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>About</title>
		<link>https://perlfisher.wordpress.com/about-2/</link>
		<pubDate>Tue, 30 Jun 2020 10:12:53 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?page_id=8</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:spacer {"height":20} -->
<div style="height:20px;" aria-hidden="true" class="wp-block-spacer"></div>
<!-- /wp:spacer -->

<!-- wp:group {"align":"full"} -->
<div class="wp-block-group alignfull"><div class="wp-block-group__inner-container"><!-- wp:jetpack/layout-grid {"column1DesktopSpan":3,"column1DesktopOffset":1,"column1TabletSpan":3,"column1MobileSpan":4,"column2DesktopSpan":6,"column2DesktopOffset":1,"column2TabletSpan":5,"column2MobileSpan":4,"column3DesktopOffset":3,"column3TabletOffset":1,"className":""} -->
<div class="wp-block-jetpack-layout-grid alignfull column1-desktop-grid__span-3 column1-desktop-grid__start-2 column1-desktop-grid__row-1 column2-desktop-grid__span-6 column2-desktop-grid__start-6 column2-desktop-grid__row-1 column1-tablet-grid__span-3 column1-tablet-grid__row-1 column2-tablet-grid__span-5 column2-tablet-grid__start-4 column2-tablet-grid__row-1 column1-mobile-grid__span-4 column1-mobile-grid__row-1 column2-mobile-grid__span-4 column2-mobile-grid__row-2"><!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:image {"id":698,"sizeSlug":"full","className":"is-style-circle-mask"} -->
<figure class="wp-block-image size-full is-style-circle-mask"><img src="https://a8ctm1.files.wordpress.com/2020/01/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg" alt="" class="wp-image-698" /></figure>
<!-- /wp:image --></div>
<!-- /wp:jetpack/layout-grid-column -->

<!-- wp:jetpack/layout-grid-column -->
<div class="wp-block-jetpack-layout-grid-column wp-block-jetpack-layout-grid__padding-none"><!-- wp:heading -->
<h2>Introduce yourself – who you are, what you do, and where you are.</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This is an example of an about page. Unlike posts, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or <a href="//wordpress.com/page">add another page</a>.</p>
<!-- /wp:paragraph --></div>
<!-- /wp:jetpack/layout-grid-column --></div>
<!-- /wp:jetpack/layout-grid --></div></div>
<!-- /wp:group -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>39</wp:post_id>
		<wp:post_date>2020-06-30 10:12:53</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:12:53</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>about-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_headstart_post</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>switch_like_status</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;N;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_starter_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[about-3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_skip_all_services</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_checklist_post_type</wp:meta_key>
			<wp:meta_value><![CDATA[_hs_extra]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Rewriting Perl code for Raku Part V</title>
		<link>https://perlfisher.wordpress.com/2019/12/15/rewriting-perl-code-for-raku-part-v/</link>
		<pubDate>Sun, 15 Dec 2019 11:19:50 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?p=31</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/">Last week</a>&nbsp;we started to talk about the&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>&nbsp;builtins for Raku and Perl. These aren’t terribly common built-ins to use, so I thought I’d take some time to go over these in detail and talk about how I use them and debug files that use them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As a gentle reminder,&nbsp;<a href="https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>&nbsp;is a Perl module to read and write a subset of the Microsoft OLE storage format. As part of my effort at the start, I’ve got a “translation” of the original Perl code pounded out, without much thought to whether it’ll work, or really even compile. It looks like the Perl version, but with most of the {} changed to &lt;&gt; and -&gt; changed to ..</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What to test first… The reading side seems to be the easiest, because I can check object-by-object to see what the data&nbsp;<strong>should</strong>&nbsp;look like. Replicating that for Raku becomes essentially fixing the bugs I know I’ve introduced on the way.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Testing testing… is this on?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Before we dive into the Raku code, though, let’s just set up a quick test in Perl. There really wasn’t one to begin with, which is a testament to how well-used the module is. I’ve got a ‘test.xls’ file that I’ve already checked in LibreOffice to make sure it works, so I’ll add a test script that reads the file and checks the root object.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test::More;
use OLE::Storage_Lite;

my $root = OLE::Storage_Lite-&gt;new( 'sample/test.xls' );
use YAML; die Dump($root);
isa_ok $root, 'OLE::Storage_Lite::PPS::Root';
is $root-&gt;No, 0;
is $root-&gt;PrevPps, 0xfffffffe;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>You might be reading the code and wondering what the heck&nbsp;<em>die()</em>&nbsp;is doing in a test suite. It’s not because in my current copy it’s commented out, but it’s a quick and dirty way to get the data for the Raku version of the file, which looks almost the same.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use Test;
use OLE::Storage_Lite;

my $root = OLE::Storage_Lite.new( 'sample/test.xls' );
die $root.perl;
isa_ok $root, 'OLE::Storage_Lite::PPS::Root';
is $root.No, 0;
is $root.PrevPps, 0xfffffffe;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Notice there’s hardly any difference overall, just a few minor syntax tweaks. And I don’t need to use YAML. But I’ve got a Q&amp;D way to run my code, and since my screen looks something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":56,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png?w=1024" alt="" class="wp-image-56" /></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>I’ve got most of what I need in my face. This is all a rather plain&nbsp;<a href="https://github.com/tmux/tmux/wiki">TMUX</a>&nbsp;setup, running multiple panes so I can see what’s going on. On the left is vim running in split-screen mode with the Perl and Raku test files open. The rest are shells in the Perl and Raku directories, and some commands to get byte dumps of the files.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve also in my shells set up the following aliases:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">alias 5 = "perl -Ilib"
alias 5p = "prove -Ilib"
alias 6 = "perl6 -Ilib"
alias 6p = "prove -e'perl6 -Ilib'"</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This way I can run both Perl and Raku test suites with just a few keystrokes, and not have to worry about details such as&nbsp;<em>-I</em>&nbsp;paths. You’re of course welcome to do things exactly the same, completely different, or even radically better than I am, in which case please let me know.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You might notice the use of the language’s old name here. I haven’t changed over to the new binaries yet, but the techniques I’ll talk about here won’t change.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Keeping it Clean</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We now have two scripts that should produce the same output, but probably won’t, for any number of reasons. I’ve got a whole article’s worth of things that I had to do to make the new module compile, let alone run. But that’s for a later issue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s start out with this section, which might be familiar to longtime (ha!) readers.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  $rhInfo-&gt;{_FILEH_}-&gt;seek(0, 0);
  $rhInfo-&gt;{_FILEH_}-&gt;read($sWk, 8);
  return undef unless($sWk eq "xD0xCFx11xE0xA1xB1x1AxE1");</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This is in Perl, of course. In Raku I’ve chosen to write</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  $file.seek( 0, SeekFromBeginning );
  my Str $sWk = $file.read( 8 ).unpack('A8');
  die "Header ID incorrect" if $sWk ne HEADER-ID;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>It’s a bit ungraceful to&nbsp;<em>die()</em>&nbsp;inside a module, but this guarantees that execution stops way before it can cause a hard-to-debug problem down the road. The first change is that I’ve refactored&nbsp;<code>$rhInfo-&gt;{_FILEH_}</code>&nbsp;out into its own&nbsp;<em>$file</em>&nbsp;variable so I don’t have to repeat references to&nbsp;<em>$rhInfo</em>&nbsp;all over the place, like the original.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next is using the built-in&nbsp;<em>IO::Handle</em>&nbsp;constant ‘SeekFromBeginning’ instead of the rather anodyne 0 as in Perl. Probably the parent&nbsp;<em>OLE::Storage</em>&nbsp;module looked ahead in the file to determine something before reading in earnest. I’m keeping it here for no good reason other than it might be nice to separate ‘read’ functionality into a different method.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Diving in</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The next line will cause some consternation, so I’ll unpack it slowly. The original author used Hungarian notation for their variable names, so the ‘s’ of&nbsp;<em>$sWk</em>&nbsp;means that it’s a string type. I’ve adopted this for the Raku code as well, actually enforcing the variable type without additional code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>File handles have both a fancy&nbsp;<em>lines()</em>&nbsp;method that lets you read files line-by-line, and a raw&nbsp;<em>read()</em>method that lets you read raw bytes. If I stopped right here and just looked at the raw bytes, the code would actually fail, and I’ve talked about why in earlier parts. Suffice to say that&nbsp;<em>read()</em>returns a buffer of uninterpreted bytes, not a string that you have to decode later.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Decoding here is the job of the&nbsp;<em>unpack()</em>&nbsp;statement. It acts just like its Perl counterpart, but is experimental. Lucky for me, it implements enough of the Perl builtin that I can use it to read the entire OLE file.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, unlike other builtins (again, keeping in mind it’s experimental,) it’s only available as a method call. There is a version of&nbsp;<em>unpack()</em>&nbsp;that works on multiple arguments, but if you try to call it as a builtin, expect:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">===SORRY!=== Error while compiling -e
Undeclared routine:
    unpack used at line 1. Did you mean 'pack'?</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This may be fixed in your version, feel free to try it and let me know if I should upgrade&nbsp;:-)&nbsp;In any case, the last bit you’re wondering about is the ‘A8’ business as its argument. I think this isn’t explained correctly in the documentation, so I’ll explain in my own way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>read()</em>&nbsp;returns a raw string of bytes, without interpretation. If it sees hex 041, it doesn’t “know” if you meant the ASCII character ‘A’ or the number 41, so it doesn’t interpret the data, it just puts the data into the buffer. It relies on the the Buf(fer)’s&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>&nbsp;methods to assign types to the data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So finally,&nbsp;<code>unpack( "A8" )</code>&nbsp;pulls out 8 “ASCII” characters and puts them into&nbsp;<em>$sWk</em>. Now I used scare-quotes there because ASCII is a 7-bit encoding, not 8 bits as many people seem to think. It only encodes from 0x00-0x7f, so anything over that isn’t legal ASCII.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Which just means that the “A” of “A8” doesn’t truly correspond to ASCII, but it’s close enough. So, we call&nbsp;<em>unpack( “A8” )</em>&nbsp;on the buffer that&nbsp;<em>$file.read( 8 )</em>&nbsp;returns, and get back a string that we can finally check against our header.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Debugging</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>But what if the header isn’t what we expect? Your first instinct might be to say you must’ve screwed up and sent it the wrong file. Luckily it’s pretty easy to check that, just call&nbsp;<code>$file.slurp.print;</code>&nbsp;That’ll tell you the contents quickly. If it’s text you’ve probably got the wrong file – OLE files do contain text but it’s usually zip’ed or in UCS-2.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s assume though that it’s an actual binary file, and a real spreadsheet that Excel (or LibreOffice in my case) can read. Since the headers don’t match, it must be a different version of OLE that our code isn’t ready to handle.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That means we need to know what the first 8 bytes of the file actually are. We’ve got a bunch of tools at our disposal, but what I want to introduce is&nbsp;<em>hexdump(1)</em>&nbsp;(don’t worry about the (1), force of habit.) Run this command on the file:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">hexdump -C sample-file.xls | head -1</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This should generate something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">00000000  d0 c9 11 a0 af b1 13 d1  00 00 00 00 00 00 00 00  |................|</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>(original bytes changed to protect the innocent file) The numbers on the left (‘00000000’) tell us how far we are into the file (in hex), the next two groups of 8 are the hex values of the individual bytes of the file, and the dots between ‘|..|’ are where any printable characters would appear, if there were any.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So now we know what the first 8 bytes of this file look like, and we can add (without much muss or fuss) some checks to our original file, and come up with this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$file.seek( 0, SeekFromBeginning );
my Str $sWk = $file.read( 8 ).unpack('A8');
die "Unknown OLE header!" if $sWk eq "xd0xc9x11xa0xafxb1x13xd1";
die "Header ID incorrect" if $sWk ne HEADER-ID;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This check isn’t in my source, so don’t go looking for it. As far as I know there aren’t any other OLE header strings than what I check for, but then I’m trying to get away without reading the spec. My blood pressure doesn’t need that.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Getting at the details</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Of course, binary packed formats contain more stuff than just ASCII strings. OLE was originally written in the days of 16-bit CPUs, so it’s got other ways to pack in data. Let’s look at a fragment of the file format: (not from the spec, this is just my interpretation)</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">0000: 0xD0 0xCF 0x11 0xE0 0xA1 0xB1 0x1A 0xE1 # header
0008: 0x00 0x09           # size of large block of data (in power-of-2)
000a: 0x00 0x06           # size of small block of data
000c: 0x00 0x00 0x00 0x03 # Number of BDB blocks
0010: 0xff 0xff 0xff 0xfe # Starting block</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>So, this is the first 20 (0x0010+4) bytes of an OLE header block. You may have already caught on to the fact that there are at least 3 sizes of data here. The first 8 bytes on line 0000 is the header data we talked about ad nauseam.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next, the header says that a “large” block of data is 2**9 bytes long, and a “small” block of data is 2**6 bytes long, this time in pairs of bytes. Finally we’ve got the number of BDB blocks (whatever those are, probably Berkeley DB) and the starting block’s index number, all in 4-byte chunks.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This means we need to read 2 2-byte chunks and 2 4-byte chunks into memory. This time though, we have to read them as numbers. Once again,&nbsp;<em>unpack()</em>&nbsp;comes to the rescue. Last time we used the ‘A’ character, this time we’ll do something just a little bit different.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s read the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/routine/unpack">documentation</a>&nbsp;for&nbsp;<em>unpack()</em>&nbsp;to see what we can use. Halfway down the page we come to a table which gives us the letter abbreviations for each type of data we can read, and what it is in terms of where it is in memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For now, replace the term ‘element’ with ‘byte’ while you’re reading the documentation. We need to read (0x00, 0x09) as a 2-byte integer, so let’s look for “two elements” on the right-hand side. “Extracts two elements and returns them as a single unsigned integer” seems to be what we need.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So it looks like the letter we need to use is “S”, and since we only want to read one at a time, that’s all we need. But the original Perl source uses “v”, so that’s what I’ll use as well.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  $iWk = _getInfoFromFile($rhInfo-&gt;{_FILEH_}, 0x1E, 2, "v");
  return undef unless(defined($iWk));
  $rhInfo-&gt;{_BIG_BLOCK_SIZE} = 2 ** $iWk;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>But as you can see, the Perl source creates a wrapper around the&nbsp;<em>pack()</em>&nbsp;method, much to my annoyance. I’d prefer to simply write this:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$iWk = $file.read( 2 ).unpack( "v" );
%hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2**$iWk;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>but to keep things looking as similar to the original Perl code as I can, my code looks like&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  my Int $iWk = self._getInfoFromFile( $file, 0x1E, 2, "v" );
  die "Big block size missing" unless defined( $iWk );
  %hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2 ** $iWk;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>which is just one line longer, and that’s because of the safety check. Of course,&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>can take more than one format character at time. In Perl, there’s yet another mini-language (like regex, and what used to be called the&nbsp;<em>format</em>&nbsp;statement) for these builtins, and that’s not quite done yet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But you can still take the entire header we’ve collected so far, and write it into a single&nbsp;<em>unpack()</em>statement like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my ( $header, $large-size, $small-size, $num-bdbs, $start-block ) =
  $file.read( 20 ).unpack( "A8 vv VV" );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>This format is of course much more compact and much easier to read. In all probability once I get done with the main module I’ll convert everything over to this style and the code will become much, much quieter. Binary protocols, especially those for moisture evaporators, tend to have lots of code that looks like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $rev = $file.read(2).unpack("v")
if $rev == 0x01 {
  $r2 = $file.read(2).unpack("v");
} else {
  $d2 = $file.read(4).unpack("V");
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>where the next bytes you read depend upon the version of the protocol. Even though I’ve just been rattling off code based on the Perl version, I don’t know what the protocol may&nbsp;<strong>do</strong>&nbsp;at any given point. So it makes sense to read just one int or long ahead while developing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I could read a version number as “V” because they started out using “v1”, “v2” and so on up to “v42792643522”. But then 30 lines and 2 revs later they may have changed from “V” to “vcc” because they wanted to support “v2.1.0” style.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And if that header were something like “A8 V CC* V vv” I have to go back and break up the format string and statement at the very least. If I go term-by-term I just have to find the version number and add an if-then statement just below.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now that you’ve got a fairly good grounding in&nbsp;<em>unpack()</em>, I think it’s time for break. Next time we’ll cover writing our file back out, the most fun part of the operation.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator" />
<!-- /wp:separator -->

<!-- wp:paragraph -->
<p>Again, many thanks to those of you that have read this far. As usual, Gentle Reader, please feel free to leave constructive questions, comments, critiques and improvements in the comment section. I do require an email address for validation, but I don’t use it for any other purpose. Thank you again, and I’ll see you in part VI of this series.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>51</wp:post_id>
		<wp:post_date>2019-12-15 12:19:50</wp:post_date>
		<wp:post_date_gmt>2019-12-15 11:19:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rewriting-perl-code-for-raku-part-v</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025396347]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593512685]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Rewriting Perl Code for Raku IV: A New Hope</title>
		<link>https://perlfisher.wordpress.com/2019/12/08/rewriting-perl-code-for-raku-iv-a-new-hope/</link>
		<pubDate>Sun, 08 Dec 2019 11:36:34 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://theperlfisher.wordpress.com/?p=39</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Back in&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Part III</a>&nbsp;of our series on Raku programming, we talked about some of the basics of OO programming. This time we’ll talk about another aspect of OO programming. Perl objects can be made from any kind of reference, although the most common is a hash. I think Raku objects can do the same, but in this article we’ll just talk about hash-style Perl objects.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Raku objects let you superclass and subclass them, instantiate them, run methods on them, and store data in them. In previous articles we’ve talked about all but storing data.&nbsp;It’s time to remedy that, and talk about attributes.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Instance attributes</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We used&nbsp;<code>unit class OLE::Storage_Lite;</code>&nbsp;to declare our class, and&nbsp;<code>method save( $x, $y ) { ... }</code>&nbsp;to create methods. Or in our case rewrite existing functions into methods. Now, we focus our attention on some of the variables that should really be instance attributes, and why.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s get to know which variables behave like attributes, and which don’t. This&nbsp;<strong>will</strong>&nbsp;change how we write our Raku code, but hopefully for the better. We’ll start from the outside in, and look at the API. There are a few “test” scripts that use the module, and this fragment is pretty common.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use OLE::Storage_Lite;
my $oOl = OLE::Storage_Lite-&gt;new('test.xls');
my $oPps = $oOl-&gt;getPpsTree(1);
die( "test.xls must be a OLE file") unless($oPps);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The author creates an object (<em>$oOl</em>) from an existing file, then fetches a tree of “Pps” objects, whatever they are. So, one&nbsp;<em>OLE::Storage_Lite</em>&nbsp;object equals one file. This gives me my first instance variable,&nbsp;the filename.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub new($$) {
  my($sClass, $sFile) = @_;
  my $oThis = {
    _FILE =&gt; $sFile,
  };
  bless $oThis;
  return $oThis;
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Above is how they wrote it in Perl, and below is how we’d write it (exactly as specified) in Raku:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has $._FILE;

multi method new( $sFile ) {
  self.new( _FILE =&gt; $sFile );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Later on, we can call&nbsp;<code>my $file = OLE:Storage_Lite.new( 'test.xls' );</code>&nbsp;just like we did in Perl. We wouldn’t even need the&nbsp;<em>new</em>&nbsp;method if we had users call&nbsp;<code>my $file = OLE::Storage_Lite.new( _FILE =&gt; 'text.xls' );</code>. This gives users the option of calling the API in the old Perl fashion or the new Raku fashion without additional work on our part.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Strict Raku-style</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There’s a problem lurking here, though. The constructor Raku provides us lets us call&nbsp;<code>my $file = OLE::Storage_Lite.new();</code>&nbsp;without specifying a value for&nbsp;<em>$._FILE</em>. If you know Perl’s Moose module, though, the ‘has’ there just might look familiar.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And for good reason. A lot of the ideas from Moose migrated into Raku during its design, and the attributes were one of those. Moose lets you do a lot of things with attributes, and so does Raku. One of those is you can add “adverbs” to them. Let’s do that now.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has $._FILE is required;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Calling&nbsp;<code>OLE::Storage_Lite.new()</code>&nbsp;now fails, because you’re not passing in the&nbsp;<em>_FILE</em>&nbsp;argument. That solves one problem. Actually, it solves two, come to think of it. In the original Perl code, you could call&nbsp;<code>OLE:Storage_Lite-&gt;new()</code>&nbsp;too, and it wouldn’t complain. Now we’ve fixed that, with one new term.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Progressive Typing</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>No, we’re not talking about some new editor like&nbsp;<a href="http://web.archive.org/web/20200212094016/https://www.commaide.com/">Comma</a>&nbsp;(the link&nbsp;<strong>does</strong>&nbsp;work, despite the certificate problem.) Our code would run just fine, as-is. Users could call our&nbsp;<em>.new()</em>&nbsp;API, Raku would make sure the filename existed, and we could go on with translating.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But there’s something more we can take advantage of here, and that is the fact that any Raku object (and anything we can instantiate is an object) is a type as well. We haven’t mentioned that because we really couldn’t use that information until now.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The original Perl code is littered with clues to types, hidden in the variable names. When we wrote our own API call, the Perl code called the file name&nbsp;<em>$sNm.</em>&nbsp;The ‘s’ tells the Perl compiler nothing, but it tells us that&nbsp;<em>$sNm</em>&nbsp;is a String type. Perl may not have true types, but Raku does. Let’s fix our attribute with that in mind.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">has Str $._FILE is required;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>We knew all along that&nbsp;<em>$._FILE</em>&nbsp;is a string of some sort, but telling Raku that lets it allocate space more efficiently. Making sure it’s a required attribute lets anyone that calls&nbsp;<em>new()</em>&nbsp;know if they forget an argument. We could go a little farther with this, but locking down attributes will help in the long run, when we start dealing with the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;built-ins.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Packing It All In</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We’re now getting to the heart of the module. There’s a lot of mechanics above us, allocating objects and doing math and checking types, and not much below us. The class’ entire purpose is to read and write OLE-formatted files. We’ll talk more about the boilerplate, but here’s the real meat of the file.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s start with what should be simple, reading in data. Just like in Perl, we open a file and get back a “file handle” (assuming the file exists, of course.) By default, calling&nbsp;<code>my $fh = open $._FILE;</code>gives us a read-only file handle. The file handle itself has a bunch of attributes associated with it, but the important one right now is its encoding.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Namely, the fact that it has none. An OLE file is essentially a miniature filesystem (probably based on FAT) packed onto disk, complete with a root directory, subdirectories and files. File have names encoded in UCS-2, but the rest is entirely dependent upon what the application requires.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The upshot of which is that we can’t read the format with something simple like&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;which would read line after line into the&nbsp;<em>@lines</em>&nbsp;array. Instead we’ll use calls like&nbsp;<em>read()</em>and&nbsp;<em>write()</em>&nbsp;that return byte-oriented buffers.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Buffering…</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>All OLE files start off with the header “xD0xCFx11xE0xA1xB1x1AxE1”, so we should probably start there. That’s important twice in the code, in fact. First, when we’re reading off disk, we can check it against what we’ve just read to make sure this file is OLE, and not, say, a JSON file. Later on, when we’re saving out an OLE file, we can write it as the header string.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>I’ll make it a constant as well, so when I revisit this code in a month I don’t have to go looking in specs for ‘0xd0 0xcf’ to remember what this is. Reading is straight-forward too. It needs just a byte count.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my Buf $header = $fh.read( 8 );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Something important to notice here is the type, ‘Buf’. If our file was in Markdown, or JSON we could get away with just writing&nbsp;<code>my @lines = $fh.lines;</code>&nbsp;like I tried earlier. But these are raw bytes, hindered by no interpretation. Let’s see what happens when we compare these bytes to our&nbsp;<em>HEADER-ID</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">t/01-internals.t ............ Cannot use a Buf as a string, but you called the Stringy method on it
  in method _getHeaderInfo at /home/jgoff/GitHub/drforr/raku-OLE-Storage_Lite/lib/OLE/Storage_Lite.pm6 (OLE::Storage_Lite) line 169
  in block &lt;unit&gt; at t/01-internals.t line 42</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Another brick in the wall</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Ka-blam</strong>. But… hold the phone here a minute, I just said&nbsp;<code>$header eq HEADER-ID</code>, I didn’t write anything like ‘Stringy’! There’s no ‘Stringy’ in the source… oh.&nbsp;<em>HEADER-ID</em>&nbsp;is a string, so Raku is being helpful. I’m trying to use string comparison (‘eq’) between something that’s not a Str (&nbsp;<em>$header</em>&nbsp;) and something that is (<em>HEADER-ID</em>).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Pull up the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Stringy">Stringy</a>&nbsp;documentation, and look for the Type graph. Midway down you’ll see ‘Buf’ and ‘Str’, as of this writing Buf is on the left, and Str is popular so it’s in the middle.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trace the inheritance paths from Buf and Str upwards, and you’ll see they pass Buf -&gt; Blob -&gt; Stringy and Str -&gt; Stringy, and stop. What the error message therefore is saying is this, anthropomorphized:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You wanted to convert&nbsp;<em>Buf</em>&nbsp;to&nbsp;<em>Str</em>, and didn’t care how you did it. So I looked. First, on the&nbsp;<em>Buf</em>&nbsp;type. No .Str method there, at least without arguments. No good. So I looked in its parent,&nbsp;<em>Blob</em>. Nothing doing there. Then I looked at&nbsp;<em>Stringy</em>, and couldn’t find anything else.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There’s nothing above me, nothing below. So I’ll let you know I looked for a conversion method in a bunch of places, stopped at&nbsp;<em>Stringy</em>, and couldn’t go any farther. Sorry.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>Raku</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You’re probably wondering how to get out of this quandary. Reading the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/type/Blob#method_Str">Blob</a>&nbsp;documentation closely, you might think that the&nbsp;<em>encode</em>&nbsp;method is the way out of our present jam. If you look closer, though, there’s a spanner in the works. “xD0” is the&nbsp;<strong>byte</strong>&nbsp;0xd0, so if you try to decode to ASCII, you run into the problem that ASCII only covers 0x00-07xf, everything outside of that is undefined.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Packing for vacation</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you’ve kept up with things, you might surmise by now that the key to our quandary lies in the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins. Specifically&nbsp;<em>unpack()</em>, because we’re trying to “decode” a buffer into something suitable for Raku.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Unless you’ve done things like network programming or security, the&nbsp;<em>pack</em>&nbsp;and&nbsp;<em>unpack</em>&nbsp;builtins are going to be unfamiliar territory. The closest analogue of&nbsp;<em>pack()</em>&nbsp;is the builtin&nbsp;<em>sprintf()</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Both of these builtins take a format string telling the compiler how to arrange its arguments. Both of them take a mixture of string and integer arguments afterwards. But while&nbsp;<em>sprintf()</em>&nbsp;takes the arguments and treats its output as a UTF-8 encoded string,&nbsp;<em>pack()</em>&nbsp;takes the same arguments and treats its output as a raw buffer of bytes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And now you can see one way out of our little predicament. If we could just find the right invocation,&nbsp;<em>pack()</em>&nbsp;would be able to take our string “xd0xcf…” and turn it into a Buf object. Then we could compare the buffer we got by reading 8 bytes to the buffer we expected.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So instead of cluttering up the main code, let’s write a quick test.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use experimental :pack;
constant HEADER-ID = "xD0xCFx11xE0xA1xB1x1AxE1";

use Test;
my $fh = open "test.xls";
my Buf $buf = $fh.read( 8 );

is $buf, pack( "A8", HEADER-ID ); # Pack 8 ASCII characters</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Testing…testing…</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let’s take it from the top. We tell Raku to use the “experimental”&nbsp;<em>pack()</em>&nbsp;builtin, and declare the header we want to check against. Then we tell Raku we want to use the Test module, and open a new Microsoft Excel test file.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Last, we read a chunk of 8 bytes from the file into a buffer, and check to see that the 8 bytes matches the header we expect to see. Now, how did we get that weird ‘A8’ string in there? I thought&nbsp;<em>pack()</em>&nbsp;looked more like&nbsp;<em>sprintf()</em>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, it does, to an extent. I/O routines like&nbsp;<em>sscanf()</em>&nbsp;and&nbsp;<em>sprintf()</em>&nbsp;can do all sorts of things to your strings and numbers on the way in and out, think for example what ‘%-2.10f’ means in a format specifier, for instance. You can follow along with the&nbsp;<a href="http://web.archive.org/web/20200212094016/https://docs.raku.org/routine/unpack">unpack()</a>&nbsp;documentation if you like.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>pack()</em>, by contrast, just takes 8, 16, or 32-bit chunks of your input, and places them into a buffer. The “A” in “A8” says that it wants to convert an ASCII-sized chunk of your input (“xd0” in our case) into a byte in the buffer, so our Buf now looks like ( 0xd0 ).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I could just as well have said “AAAAAAAA” in order to translate all 8 characters of the buffer, but I think it’s a little tidier to use the ‘repeat’ option, and say “A8” in order to convert just 8 characters (yes, yes, I know, they’re&nbsp;<strong>glyphs</strong>, but let’s not confuse matters.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I could write “A*” just as well, but “A8” makes sure that 8 and only 8 (the number that thou shalt count to…) characters get converted. I doubt that the header in an OLE file will change, but it’s a nice bit of forward planning.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator" />
<!-- /wp:separator -->

<!-- wp:paragraph -->
<p>For those of you that made it this far, thank you. As usual, gentle Reader, if you have any comments, criticisms (constructive, please) or questions, feel free to post them below.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next week I’ll delve deeper into the mysteries of&nbsp;<em>pack()</em>,&nbsp;<em>unpack()</em>&nbsp;and some of the tips and tricks I use to keep on my toes and make sure that I generate clean Microsoft-compatible output.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>53</wp:post_id>
		<wp:post_date>2019-12-08 12:36:34</wp:post_date>
		<wp:post_date_gmt>2019-12-08 11:36:34</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rewriting-perl-code-for-raku-iv-a-new-hope</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="perl-programming"><![CDATA[Perl programming]]></category>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025358030]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_session_id</wp:meta_key>
			<wp:meta_value><![CDATA[5efb1b9852518]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_import_original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>original_post_id</wp:meta_key>
			<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2019-12-15]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Rewriting Perl Code for Raku III: The Sorceror</title>
		<link>https://perlfisher.wordpress.com/2019/12/02/rewriting-perl-code-for-raku-iii-the-sorceror/</link>
		<pubDate>Mon, 02 Dec 2019 12:05:55 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=60</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku-ii-electric-boogaloo/">Last week</a>, we started testing, learned how to create proper Raku classes, and the basics of functions. This time we’ll take a closer look at functions, arguments, and make some decisions about the API. And maybe while writing this I’ll argue myself out of a decision. It’s happened before.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>One good thing about writing&nbsp;<strong>about</strong>&nbsp;a module is that you can slip into a certain mindset. For instance, right now I’m thinking a few paragraphs ahead, wondering how to explain why I changed the API from Perl 5 references to regular Raku types.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It’s at odds with some of the principles I laid down at the start, which states that I should have minimal changes in the API from Perl to Raku. In Perl 5, you would create the “filesystem root” object like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $root = OLE::Storage_Lite::PPS::Root-&gt;new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>with a bunch of references to lists. By all rights, and the principles I set up earlier, the Raku equivalent should be almost exactly the same:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my $root = OLE::Storage_Lite::PPS::Root.new(
  [ 0, 0, 0, 25, 1, 100 ],
  [ 0, 0, 0, 25, 1, 100 ],
  [ $workbook, $page_1, $sheet_1 ]
);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In fact, all I did was copy and change two characters, specifically the Perl ‘-&gt;’ to the Raku ‘.’ operator. Clean, and very simple. And I think what I’ll do is actually just change the code back to using the Perl reference, at least in the API. Dereferencing it will be just a few lines, and I’ll have to change it in the tests as well, but I think the pain will be worthwhile.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This way I don’t have to field questions like “Why did you end up potentially breaking old code?” during talks. See, speaking at conferences about your code really <strong>can</strong> be a useful motivator!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>I’d like a formal argument, please</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>So, I think I’ve settled on Perl-style formal references, at least for the current iteration. There are actually better ways to do this, but I’ll leave that for the proper Raku version. For right now, quick-n-dirty is the name of the game.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Moving on, we see an important method in the original Perl code, saving an object to disk.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub save($$;$$) {
  my($oThis, $sFile, $bNoAs, $rhInfo) = @_;
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>As I’ve mentioned before, OLE::Storage_Lite has been around for a long, long time. And it’s obvious here. Function prototypes (<strong>not</strong>&nbsp;signatures, which are a different kettle of fish) and the use of ‘$oThis’ instead of the more conventional ‘$self’.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Being prototypical</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Prototypes were originally meant as a way to save you from having to write checks in your code. Theoretically, if your function was called&nbsp;<code>sub save($$)</code>&nbsp;and you tried to call it with&nbsp;<code>save($fh)</code>&nbsp;you would get an error, because the ‘$$’ means the subroutine took two arguments, and you gave it just one.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But it also predated objects (yes, Virginia, objects in Perl haven’t been around all&nbsp;<strong>that</strong>&nbsp;long.) and they could have unforeseen side effects. So they were a fad for a while, but quickly faded out of existence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>These days they’re a reason for a more experienced Perl hacker to take the junior aside and explain quietly why we don’t use those anymore, and point them to some modern references, like&nbsp;<em><a href="http://web.archive.org/web/20200212094016/https://www.amazon.com/Modern-Perl-chromatic/dp/1680500880/ref=sr_1_1?keywords=Modern+Perl&amp;qid=1574975397&amp;s=books">Modern Perl</a></em>&nbsp;(not an affiliate link, yet.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s at least partially convert that to Raku, like so:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method save($sFile, $bNoAs, $rhInfo) {
  #0.Initial Setting for saving
  $rhInfo = {} unless($rhInfo);
  # ..
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The ‘$oThis’ means that this is a method call, so instead of writing&nbsp;<code>sub save( $oThis, ... )</code>&nbsp;we can rewrite it to a method and gain ‘self’ instead of the arbitrary variable ‘$oThis’. Of course we do have to do a search-and-replace on ‘$oThis’ with ‘self’, but that’s relatively simple. More complex is what to do with the ‘;’ in the original prototype.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Having options</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It’s worth pointing out that&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>&nbsp;is taken at least in part from another (larger) module,&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage">OLE::Storage</a>. This means that the internal code is redundant in a few places. Raku would let us rewrite what we have as:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method save($sFile, $bNoAs, $rhInfo = {}) {
  #0.Initial Setting for saving
  # ..
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>making&nbsp;<em>$rhInfo</em>&nbsp;an optional variable with a default value. Now, this is a pretty common pattern for a recursive method, so I did a bit of digging. Namely I grep’ed for ‘save’ in the original (all-in-one)&nbsp;<em>Storage_Lite.pm</em>&nbsp;module, and found no recursive calls to it.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Debugging both sides now</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This is also where the test suite I wrote earlier comes in handy, as it actually exercises the ‘save’ method. So I added a quick debugging message&nbsp;<code>warn "Saving $rhInfo";</code>&nbsp;to my local copy of the code, and ran the test suite. Seeing just one ‘Saving …’ message in my test output convinced me it wasn’t recursive. So now the code just looks like:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">method save($sFile, $bNoAs) {
  #0.Initial Setting for saving
  my %hInfo;
  # ..
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Also, since&nbsp;<em>$rhInfo</em>&nbsp;is created in this method, there’s no reason to leave it as a reference. So the initial ‘r’ goes away, and we have left just ‘%hInfo’. It may get passed in to other methods, but Raku lets us pass hashes and arrays as ordinary variable types, so I’ll take advantage of that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To be fair, leaving it as a reference would have saved me a bit of typing, but I’d already kind of decided that at least internally I’d try to use Raku types and calling conventions, and that left me with the choice of how to pass variables around.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Having options</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, there’s the question of what to do with the semicolon. Remember at the start, the function prototype was ‘($$;$$)’ which meant&nbsp;<em>$oThis</em>&nbsp;and&nbsp;<em>$sFile</em>&nbsp;were before the semicolon, and&nbsp;<em>$bData</em>&nbsp;and&nbsp;<em>$rhInfo</em>&nbsp;were after. I can now reveal that ‘;’ in a Perl prototype means that whatever appears afterward is optional.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>True to Raku’s nature, I can account for this in at least two ways. One way would be to decide that&nbsp;<em>$bData</em>&nbsp;is always there and just has a default value, probably 0. That would look like&nbsp;<code>method save( $sFile, $bData = 0 )</code>. But the documentation puts&nbsp;<em>$bData</em>&nbsp;in square brackets, indicating that it’s optional.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Raku has an alternate syntax to indicate if a variable is optional, which looks like&nbsp;<code>method save( $sFile, $bData? )</code>. I think this method is better than the alternative syntax because it states clearly that&nbsp;<em>$bData</em>&nbsp;is optional. Both methods work, I just happen to like the ‘?’ modifier.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Waiting for Huffman</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Moving on, we have this wonderful line of code:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$rhInfo-&gt;{_BIG_BLOCK_SIZE}  = 2**
              (($rhInfo-&gt;{_BIG_BLOCK_SIZE})?
                  _adjust2($rhInfo-&gt;{_BIG_BLOCK_SIZE})  : 9);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>When I was translating this initially, I was in something of a drone mindset, not truly thinking about what I was doing. I’d copied the&nbsp;<em>$rhInfo</em>&nbsp;variable into the method signature and just kept on writing. I ended up with a statement that I eventually shortened quite a bit.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">$rhInfo.&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( $rhInfo.&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>The ‘.’ after&nbsp;<em>$rhInfo</em>&nbsp;indicates we’re dealing with a reference, and the &lt;..&gt; notation is now how barewords look inside hashes. The old {_BIG_BLOCK_SIZE} is still there, but it’s pronounced {‘_BIG_BLOCK_SIZE’}. A lot of people use the {‘..’} in Perl already so it’s not a big change, and it actually simplifies the backend enormously.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Also, at the start Larry and Damian pulled statistics on Perl code from CPAN and other repositories. They were looking for operator frequencies, among other things. Frequently used operators like&nbsp;<em>qw()</em>&nbsp;and&nbsp;<em>-&gt;</em>&nbsp;got even shorter in Raku.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Others, like the ternary operator, weren’t so lucky. It got longer, and stretched to ‘?? .. !!’. So this is one place where the code will look a little funky. Maybe one day I’ll write a slang to fix it, but back to work.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Trimming the verge</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Earlier I mentioned that this module was trimmed down from a much larger full OLE reader/writer. This was the first place that became evident. Since&nbsp;<em>$rhInfo</em>&nbsp;is now called&nbsp;<em>%hInfo</em>&nbsp;and initialized&nbsp;<strong>inside</strong>&nbsp;the method, this statement deserves to be looked at a little closer.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %hInfo;
%hInfo&lt;_BIG_BLOCK_SIZE&gt; = 2**
  ( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ??
    _adjust2( %hInfo&lt;_BIG_BLOCK_SIZE&gt; ) !!
                                        9 );</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>After replacing&nbsp;<em>$rhInfo</em>&nbsp;with&nbsp;<em>%hInfo</em>&nbsp;this is what I got. But since&nbsp;<em>%hInfo</em>&nbsp;is defined just above, the test&nbsp;<code>%hInfo&lt;_BIG_BLOCK_SIZE&gt;</code><em>&nbsp;</em>will never be true, so this entire block can be reduced to:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">my %hInfo = _BIG_BLOCK_SIZE =&gt; 2**9;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>While I’m here I’ll delete&nbsp;<em>_adjust2()</em>. No code pathway uses it, so out it goes. I’ll restore it if I have to, but right now I want the test scripts to pass, and that’s it. I’ve got the original source, and a map from Perl to Raku, and that’s all I need.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Culling yaks from the herd</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Where there’s smoke there’s fire, so I stop what I’m doing and grep out every ‘sub X’ call in the source, putting it in a scratch monkey. Then I go through the source (which I have below the new Raku source, deleting lines as I go) and look for methods that aren’t used, like&nbsp;<em>adjust2()</em>. I delete each of these methods with&nbsp;<strong>extreme</strong>&nbsp;prejudice, because each line of code I don’t see is one I don’t have to translate.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Checkpoint in git, and now it’s time for a lunch break. Afterwards, I’m getting into the&nbsp;<em>save()</em>method, and see what looks like a new yak to shave. Or a package to translate, to be precise.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">  if(ref($sFile) eq 'SCALAR') {
    require IO::Scalar;
    my $oIo = new IO::Scalar $sFile, O_WRONLY;
    $rhInfo-&gt;{_FILEH_} = $oIo;
    # ...
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In both Raku and Perl, you can create a single method called&nbsp;<code>new( $sFile )</code>&nbsp;that treats&nbsp;<em>$sFile</em>&nbsp;as either a filename (scalar), file content (scalar reference) or file handle (scalar object.) In Perl, if we wanted to handle filenames, file contents, or file handles differently, we’d have to switch like this, or have different method names.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In Raku, we can handle this differently. In fact I can write the code to save() to a filename, and add save() to a filehandle later with no modifications needed. Above, I briefly touched on the fact that you can write more than one&nbsp;<em>new()</em>&nbsp;method, as long as the two method signatures were distinct.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi method save( Str $filename ) {...}
multi method save( IO::Handle $fh ) {...}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Raku will let you write two methods called&nbsp;<em>save()</em>, as long as it can tell which one to call at runtime. So, I can call&nbsp;<code>$root.save( '/tmp/test.xlsx' );</code>&nbsp;or&nbsp;<code>$root.save( $out_filehandle );</code>&nbsp;and Raku will “dispatch” it to the right&nbsp;<em>save()</em>&nbsp;method automatically.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We call it ‘multiple dispatch’ for just that reason, dispatching a function call to multiple versions of a method. And this means that I can write the first&nbsp;<em>save( Str $filename )</em>&nbsp;method without worrying about the other methods. I don’t have to add a new if-then branch to the existing code, or modify&nbsp;<em>save()</em>&nbsp;in any way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I can just write my&nbsp;<em>save()</em>&nbsp;method and ignore the other IO:: types. Also, if someone gets my code later and wants to add a&nbsp;<em>save()</em>&nbsp;method that saves to something I know nothing about, they can write their new&nbsp;<em>save()</em>&nbsp;method without interfering with mine.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this installment we’ve covered the basics of function and method calls, delved into the ternary operator, removed dead code and learned a little about multiple dispatch. Next time, we’ll open the binary filehandle we created above and delve into the mysteries of&nbsp;<em>pack()</em>&nbsp;and&nbsp;<em>unpack()</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ll also show you a new (yes, I couldn’t resist) grammar-based version of pack() that should cover the entire Perl gamut of packed types, with a bit of patience and a large enough test suite.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As always, gentle Reader, thank you for your time and attention. If you have any (constructive, please) comments, criticisms or questions, please let me know in the comment section below.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>60</wp:post_id>
		<wp:post_date>2019-12-02 13:05:55</wp:post_date>
		<wp:post_date_gmt>2019-12-02 12:05:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rewriting-perl-code-for-raku-iii-the-sorceror</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="perl-programming"><![CDATA[Perl programming]]></category>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515214]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025444807]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Rewriting Perl Code for Raku II: Electric Boogaloo</title>
		<link>https://perlfisher.wordpress.com/2019/11/24/rewriting-perl-code-for-raku-ii-electric-boogaloo/</link>
		<pubDate>Sun, 24 Nov 2019 12:07:18 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/?p=63</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Picking up from&nbsp;<a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Part One</a>, we’d just finished up rewriting a Perl script into the test suite for the Raku translation of&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>. Raku programming is made easier by having lots of tools, but Microsoft documents aren’t yet well-represented in the Raku ecosystem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Being able to read/write OLE allows us to create a whole range of Microsoft documents (at least where they’re documented.) Because of its day-to-day use, we’re focusing on Excel here. Many businesses still rely on Excel for their day-to-day task management, time tracking and home-grown processes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve been known to wax philosophical about this after a few Westmalle Tripels at various conferences. Now is the time for doing something about it. Here’s what our burgeoning test suite looked like, at least in part. The current code is in&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>&nbsp;over on github.com. I’ve gotten rid of most of the Perl 5 test skeleton, but the essence remains.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use v6;
use Test;
use OLE::Storage_Lite;

plan 1;

my $oDt = OLE::Storage_Lite::PPS::Root.new(
  (),
  ( 0, 0, 16, 4, 10, 100 ), # 2000/11/4 16:00:00:0000
  ( $oWk, $oDir )
);
subtest 'Root', {
  isa-ok $oDt, 'OLE::Storage_Lite::PPS::Root';
  is $oDt.Name, 'Root Entry';
  is-deeply $oDt.Time2nd, [ 0, 0, 16, 4, 10, 100 ];
  # ...
};
done-testing;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Originally there really weren’t any Perl 5 tests for this module. I’m sure the original author treated the entire module as a black box, and they were happy to be able to run&nbsp;<em>samples/smpsv.pl</em>, open the new test.xls in Excel, and when it actually read the file, treat that as ‘ok 1’, push it to CPAN and call it a day.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Testing, testing</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>That’s wonderful, and I may eventually adopt that methodology. For the moment, the lack of a test suite leaves me a bit unsatisfied. I suppose I could treat the entire module as a black box and fix the translated version line-by-line as I go through it. I’ll have to do that eventually (spoiler alert: That’s actually where I am – I’m writing these pieces a bit after the fact.)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That leaves me with the question of what to test, and what the quickest way to get there is. The individual Directory, Root and File objects are exposed to the user, and are part of the public API. So it makes some sense to create an object, look at the internals, and do my best to match that in Raku.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>I Think I’m A Clone Now</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There’s always two [implementations] of me standing around… I don’t want to get sidetracked by reading the entire OLE spec. I might start to realize what a huge job this really is, and abandon ship. So, I’m going to limit myself to the following:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Create a narrowly defined 1:1 clone of the exact source of OLE::Storage_Lite in Perl 5. The objects will act exactly like the Perl 5 version, as will the API. This way I don’t have to think about what the API should do, how it should look in Raku, how the objects get laid out, anything fancy. All I need to worry about is:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>When I write&nbsp;<code>warn $oDt.raku</code>, does the output look the same as&nbsp;<code>use YAML; warn Dump($oDt);</code>&nbsp;in Perl 5?</li><li>When I write the final file to disk, does the Raku code output exactly the same file as the original Perl 5 version?</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>That’s it. It takes away a lot of possibilities, but it lets me focus on getting the job done, not how things should look. Being able to test how the individual objects look will tell me that the read API works and saves enough data to be able to reconstruct the object in memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Conversely, being able to match the binary output tells me that the write API works, so I’ve effectively tested as much as the original module did. Plus I can automate some of the process, especially on the read side.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Lost in Translation</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You can check out the current source at&nbsp;<a href="http://web.archive.org/web/20200212094016/https://github.com/drforr/raku-OLE-Storage_Lite">raku-OLE-Storage_Lite</a>, and follow along with some of the changes I’ve made. I also made sure to keep a working copy of the original&nbsp;<a href="http://web.archive.org/web/20200212094016/https://metacpan.org/pod/OLE::Storage_Lite">OLE::Storage_Lite</a>Perl 5 module around. My Raku tree right now is very close to Perl 5.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I can insert a debug statement like&nbsp;<code>die "[$iBlockNo] [$sData]\n"</code>&nbsp;in the Perl 5 code, go to the equivalent line in Raku, and expect that when I run the two test suites, that they’ll die in exactly the same way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This way when they&nbsp;<strong>don’t</strong>, I can immediately narrow down the problem simply by moving the ‘die’ statements up in the code until they return the same values. The line immediately below the ‘die’ statement will be the culprit.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>The Nitty Gritty Perl Band</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I’ll mention one thing in passing – the original Perl 5 source code is in a single file containing all of the packages. That’s not Raku style, so I’ve unpacked it into lib/OLE/Storage_Lite/* following the usual style of one Perl 5 class – one file.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, time to get our hands dirty. The new Raku module won’t compile for quite a while, so we’d better put this into git. I’m also using&nbsp;<a href="http://web.archive.org/web/20200212094016/https://modules.raku.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a>&nbsp;to do my development and eventual push to CPAN, so all of that boilerplate is there too.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, cue the montage scene of the dedicated Raku hacker pounding away at the keyboard, with the occasional break for food and/or adult beverage. Looking over her shoulder, we see a familiar split-screen view, with Perl 5 code on top, and a new Raku file below.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use OLE::Storage_Lite::PPS;
package OLE::Storage_Lite::PPS::Root;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root is OLE::Storage_Lite::PPS;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Raku has classes where Perl 5 has packages. The ‘unit’ declaration there says that the class declaration takes up the remainder of the file. This is sort of how Perl 5 does it, but gets rid of the ‘1;’ at the end of your package declaration.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It’s also useful for another reason I’m not going to show. Namely that the Perl 5 code is directly below the Raku code, commented out. I’m flipping between vim windows to delete lines as I translate them by hand. So the ‘unit class’ declaration helps in case I accidentally un-comment Perl 5 code – I’ll get big honkin’ warnings when I run the test suite.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Moosey-ears!</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>(for those of you that remember the module’s release)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Raku borrowed liberally from Perl 5’s Moose OO metamodel, to the point where using Raku will feel very similar. Just drop a few bits of syntactic sugar that Moose needed to work under Perl, and it’ll feel the same.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this case the ‘is’ does the same job as in Moose, to introduce a parent class. Raku doesn’t need the sugar that Moose sweetens your code with, so you can just say your class ‘is’ a subclass of any other class.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s keep rolling along here, with the next lines of the Perl 5 library:</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">require Exporter;
use strict;
use IO::File;
use IO::Handle;
use Fcntl;
use vars qw($VERSION @ISA);
@ISA = qw(OLE::Storage_Lite::PPS Exporter);
$VERSION = '0.19';
sub _savePpsSetPnt($$$);
sub _savePpsSetPnt2($$$);</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">use OLE::Storage_Lite::PPS;
unit class OLE::Storage_Lite::PPS::Root:ver&lt;0.19&gt; is OLE::Storage_Lite::PPS;</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Moving along… Okay, ya caught me, ‘:ver&lt;0.19&gt;’ is something new that we should add. Versions are now integrated into classes, so you can check them and even instantiate based on version number.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The module actually doesn’t export anything, so we don’t need Exporter at all. Raku enables ‘strict’ automatically, has IO modules in core, and doesn”t need Fcntl. The forward declarations aren’t needed for Raku, so all that’s left is the module’s version number, which gets added to the class name. You can add other attributes, too.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Making things functional</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>To keep things simple for me writing the code, and me having to read the code weeks, months or years later, I want as close to a 1:1 relation between Perl 5 and Raku as I can. Another place where this requires an accommodation (but not much of one) is just a few lines down, writing the creation method ‘new’.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub new ($;$$$) {
    my($sClass, $raTime1st, $raTime2nd, $raChild) = @_;
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>By this point you’ll probably see more of why I say this module is a hard worker. It’s been around a long time, and function prototypes like this are one easy way to tell. Let’s rewrite it in a more modern Perl 5 style before making the jump to Raku, with function signatures.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">sub new($sClass, $raTime1st, $raTime2nd, $raChild) {
    OLE::Storage_Lite::PPS::_new(
        $sClass,
        undef,
        # ...
    )
}
</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>Just drop the old function prototype, and replace it with the variables we need to populate. Well, almost. If you know what a subroutine prototype is, you might think I’m pulling a fast one on you. And you’d be right. Look back at the original Perl 5 code, and you’ll see ‘($;$$$)’ is the prototype.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The ‘;’ separates required variables from optional variables, and we haven’t accounted for that in our Perl 5 code. Since I’m not here to modernize Perl 5 code but convert it to Raku, I’m going to ignore that in Perl 5 and go straight to Raku.</p>
<!-- /wp:paragraph -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">multi method new( @aTime1st?, @aTime2nd?, @aChild? ) {
  self.bless(
    Time1st =&gt; @aTime1st,
    Time2nd =&gt; @aTime2nd,
    Child =&gt; @aChild
  );
}</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:heading -->
<h2>Under Construction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>And there we are. Now, there’s quite a bit to take in, so I’ll take things slow. The first thing you’ll notice is the keyword ‘multi’. In Perl 5, you get to hand-roll your own constructors, so you can make them any way you like. In this case, the author chose to write&nbsp;<code>new($raTime1st, $raTime2nd, $raChild)</code>, which is pretty common.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Raku gives me a default ‘new’ method, so I only need to hand-roll constructors when I want. Since I want to keep as close as reasonable to the original API, I’ll write a constructor that takes 3 arguments too. In my case I chose to simplify things just a bit here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve found over several years of writing Raku code that I rarely use references. In Perl 5 they were pretty much the&nbsp;<strong>only</strong>&nbsp;way to pass arrays or hashes into a function, because of its propensity to “flatten” arguments.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In Raku, you can still use the Perl 5 style, but formal argument lists are the way to go in my opinion. If you need to pass both an array and a hash to a Raku function, go for it. I encourage that in my tutorial courses, and recommend it to help break students out of their Perl 5 mindset.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is not to say that there’s anything wrong with Perl 5’s argument list, in fact they’ve taken some ideas from Raku for formal argument lists, and I encourage that. Cross-pollination of ideas should be encouraged, it’s how both languages grow and add new features.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="http://web.archive.org/web/20200212094016/http://www.theperlfisher.com/index.php/2019/11/24/rewriting-legacy-code-for-raku/">Last week</a>&nbsp;was about the overall module, this week we delved a bit into the OO workings. Next week we’ll talk about references, attributes, and maybe progressive typing.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>63</wp:post_id>
		<wp:post_date>2019-11-24 13:07:18</wp:post_date>
		<wp:post_date_gmt>2019-11-24 12:07:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rewriting-perl-code-for-raku-ii-electric-boogaloo</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="perl-programming"><![CDATA[Perl programming]]></category>
		<category domain="category" nicename="raku-programming"><![CDATA[Raku programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_date</wp:meta_key>
			<wp:meta_value><![CDATA[2020-06-30]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>timeline_notification</wp:meta_key>
			<wp:meta_value><![CDATA[1593515293]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_publicize_job_id</wp:meta_key>
			<wp:meta_value><![CDATA[46025483018]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>WordPress</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/wordpress/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/wordpress/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>27</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>wordpress</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>5</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://wordpress.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Placeholder Image</title>
		<link>https://perlfisher.wordpress.com/placeholder-image/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:02 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">http://perlfisher.files.wordpress.com/2020/06/qi-bin-w4hbafegiac-unsplash.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>28</wp:post_id>
		<wp:post_date>2020-06-30 10:58:02</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>placeholder-image</wp:post_name>
		<wp:status>inherit</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>attachment</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url>https://perlfisher.files.wordpress.com/2020/06/qi-bin-w4hbafegiac-unsplash.jpg</wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key>_wp_attached_file</wp:meta_key>
			<wp:meta_value><![CDATA[/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/qi-bin-w4hbafegiac-unsplash.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_attachment_metadata</wp:meta_key>
			<wp:meta_value><![CDATA[a:6:{s:5:"width";i:1600;s:6:"height";i:1066;s:4:"file";s:104:"/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/qi-bin-w4hbafegiac-unsplash.jpg";s:5:"sizes";a:0:{}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}s:8:"filesize";i:50995;}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Placeholder Image</title>
		<link>https://perlfisher.wordpress.com/placeholder-image-2/</link>
		<pubDate>Tue, 30 Jun 2020 10:58:03 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">http://perlfisher.files.wordpress.com/2020/06/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>29</wp:post_id>
		<wp:post_date>2020-06-30 10:58:03</wp:post_date>
		<wp:post_date_gmt>2020-06-30 10:58:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>placeholder-image-2</wp:post_name>
		<wp:status>inherit</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>attachment</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url>https://perlfisher.files.wordpress.com/2020/06/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg</wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key>_wp_attached_file</wp:meta_key>
			<wp:meta_value><![CDATA[/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_attachment_metadata</wp:meta_key>
			<wp:meta_value><![CDATA[a:6:{s:5:"width";i:1560;s:6:"height";i:1560;s:4:"file";s:114:"/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/rachel-pfuetzner-0fn7fxv1ewa-unsplash.jpg";s:5:"sizes";a:0:{}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"1";s:8:"keywords";a:0:{}}s:8:"filesize";i:56258;}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>tmux-vim-screen-1</title>
		<link>https://perlfisher.wordpress.com/tmux-vim-screen-1/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:04 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">http://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>33</wp:post_id>
		<wp:post_date>2020-06-30 13:01:04</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>tmux-vim-screen-1</wp:post_name>
		<wp:status>inherit</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>attachment</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url>https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1.png</wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key>_wp_attachment_metadata</wp:meta_key>
			<wp:meta_value><![CDATA[a:6:{s:5:"width";i:1457;s:6:"height";i:1002;s:4:"file";s:94:"/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/tmux-vim-screen-1.png";s:5:"sizes";a:0:{}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}s:8:"filesize";i:65165;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_attached_file</wp:meta_key>
			<wp:meta_value><![CDATA[/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/tmux-vim-screen-1.png]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/40/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>40</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>40</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[36]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/41/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>41</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>41</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[37]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/42/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>42</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>42</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://perlfisher.wordpress.com/2020/06/30/43/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>43</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>43</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="primary"><![CDATA[Primary]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[38]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Facebook</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/facebook-2/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/facebook-2/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>44</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>facebook-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[44]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://facebook.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Twitter</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/twitter-2/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/twitter-2/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>45</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>twitter-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[45]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://twitter.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Instagram</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/instagram-2/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/instagram-2/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>46</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>instagram-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[46]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://instagram.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Pinterest</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/pinterest-2/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/pinterest-2/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>47</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>pinterest-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[47]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://pinterest.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>WordPress</title>
		<link>https://perlfisher.wordpress.com/2020/06/30/wordpress-2/</link>
		<pubDate>Tue, 30 Jun 2020 11:01:59 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">https://perlfisher.wordpress.com/2020/06/30/wordpress-2/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>48</wp:post_id>
		<wp:post_date>2020-06-30 13:01:59</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:01:59</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>wordpress-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>5</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="social"><![CDATA[Social]]></category>
		<wp:postmeta>
			<wp:meta_key>_publicize_pending</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[48]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[https://wordpress.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>tmux-vim-screen-1-1</title>
		<link>https://perlfisher.wordpress.com/tmux-vim-screen-1-1/</link>
		<pubDate>Tue, 30 Jun 2020 11:05:12 +0000</pubDate>
		<dc:creator>theperlfisherdaaea6189e</dc:creator>
		<guid isPermaLink="false">http://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>56</wp:post_id>
		<wp:post_date>2020-06-30 13:05:12</wp:post_date>
		<wp:post_date_gmt>2020-06-30 11:05:12</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>tmux-vim-screen-1-1</wp:post_name>
		<wp:status>inherit</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>attachment</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url>https://perlfisher.files.wordpress.com/2020/06/tmux-vim-screen-1-1.png</wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key>_wp_attached_file</wp:meta_key>
			<wp:meta_value><![CDATA[/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/tmux-vim-screen-1-1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_attachment_metadata</wp:meta_key>
			<wp:meta_value><![CDATA[a:6:{s:5:"width";i:1457;s:6:"height";i:1002;s:4:"file";s:96:"/home/wpcom/public_html/wp-content/blogs.dir/ebe/179562945/files/2020/06/tmux-vim-screen-1-1.png";s:5:"sizes";a:0:{}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}s:8:"filesize";i:65165;}]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
